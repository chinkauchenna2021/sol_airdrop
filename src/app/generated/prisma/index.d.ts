
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model UserAchievement
 * 
 */
export type UserAchievement = $Result.DefaultSelection<Prisma.$UserAchievementPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model TwitterAnalytics
 * 
 */
export type TwitterAnalytics = $Result.DefaultSelection<Prisma.$TwitterAnalyticsPayload>
/**
 * Model TwitterEngagement
 * 
 */
export type TwitterEngagement = $Result.DefaultSelection<Prisma.$TwitterEngagementPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model AdminSession
 * 
 */
export type AdminSession = $Result.DefaultSelection<Prisma.$AdminSessionPayload>
/**
 * Model AdminAuditLog
 * 
 */
export type AdminAuditLog = $Result.DefaultSelection<Prisma.$AdminAuditLogPayload>
/**
 * Model FraudAlert
 * 
 */
export type FraudAlert = $Result.DefaultSelection<Prisma.$FraudAlertPayload>
/**
 * Model CampaignConfig
 * 
 */
export type CampaignConfig = $Result.DefaultSelection<Prisma.$CampaignConfigPayload>
/**
 * Model TaskCompletion
 * 
 */
export type TaskCompletion = $Result.DefaultSelection<Prisma.$TaskCompletionPayload>
/**
 * Model Claim
 * 
 */
export type Claim = $Result.DefaultSelection<Prisma.$ClaimPayload>
/**
 * Model PointHistory
 * 
 */
export type PointHistory = $Result.DefaultSelection<Prisma.$PointHistoryPayload>
/**
 * Model Referral
 * 
 */
export type Referral = $Result.DefaultSelection<Prisma.$ReferralPayload>
/**
 * Model SystemConfig
 * 
 */
export type SystemConfig = $Result.DefaultSelection<Prisma.$SystemConfigPayload>
/**
 * Model Analytics
 * 
 */
export type Analytics = $Result.DefaultSelection<Prisma.$AnalyticsPayload>
/**
 * Model DailyEarning
 * 
 */
export type DailyEarning = $Result.DefaultSelection<Prisma.$DailyEarningPayload>
/**
 * Model AirdropSeason
 * 
 */
export type AirdropSeason = $Result.DefaultSelection<Prisma.$AirdropSeasonPayload>
/**
 * Model AirdropClaim
 * 
 */
export type AirdropClaim = $Result.DefaultSelection<Prisma.$AirdropClaimPayload>
/**
 * Model NftCollection
 * 
 */
export type NftCollection = $Result.DefaultSelection<Prisma.$NftCollectionPayload>
/**
 * Model NftDistribution
 * 
 */
export type NftDistribution = $Result.DefaultSelection<Prisma.$NftDistributionPayload>
/**
 * Model NftClaimApproval
 * 
 */
export type NftClaimApproval = $Result.DefaultSelection<Prisma.$NftClaimApprovalPayload>
/**
 * Model UserNftHolding
 * 
 */
export type UserNftHolding = $Result.DefaultSelection<Prisma.$UserNftHoldingPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TwitterActivity: {
  HIGH: 'HIGH',
  MEDIUM: 'MEDIUM',
  LOW: 'LOW'
};

export type TwitterActivity = (typeof TwitterActivity)[keyof typeof TwitterActivity]


export const NotificationType: {
  INFO: 'INFO',
  SUCCESS: 'SUCCESS',
  WARNING: 'WARNING',
  ERROR: 'ERROR',
  ACHIEVEMENT: 'ACHIEVEMENT'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const EngagementType: {
  LIKE: 'LIKE',
  RETWEET: 'RETWEET',
  COMMENT: 'COMMENT',
  QUOTE: 'QUOTE',
  FOLLOW: 'FOLLOW'
};

export type EngagementType = (typeof EngagementType)[keyof typeof EngagementType]


export const TaskType: {
  SOCIAL_TWITTER: 'SOCIAL_TWITTER',
  SOCIAL_DISCORD: 'SOCIAL_DISCORD',
  WALLET_CONNECT: 'WALLET_CONNECT',
  REFERRAL: 'REFERRAL',
  DAILY_CHECK_IN: 'DAILY_CHECK_IN',
  CUSTOM: 'CUSTOM'
};

export type TaskType = (typeof TaskType)[keyof typeof TaskType]


export const ClaimStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type ClaimStatus = (typeof ClaimStatus)[keyof typeof ClaimStatus]


export const PaymentMethod: {
  SOLANA: 'SOLANA',
  USDC: 'USDC'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]

}

export type TwitterActivity = $Enums.TwitterActivity

export const TwitterActivity: typeof $Enums.TwitterActivity

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type EngagementType = $Enums.EngagementType

export const EngagementType: typeof $Enums.EngagementType

export type TaskType = $Enums.TaskType

export const TaskType: typeof $Enums.TaskType

export type ClaimStatus = $Enums.ClaimStatus

export const ClaimStatus: typeof $Enums.ClaimStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userAchievement`: Exposes CRUD operations for the **UserAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAchievements
    * const userAchievements = await prisma.userAchievement.findMany()
    * ```
    */
  get userAchievement(): Prisma.UserAchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.twitterAnalytics`: Exposes CRUD operations for the **TwitterAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitterAnalytics
    * const twitterAnalytics = await prisma.twitterAnalytics.findMany()
    * ```
    */
  get twitterAnalytics(): Prisma.TwitterAnalyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.twitterEngagement`: Exposes CRUD operations for the **TwitterEngagement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TwitterEngagements
    * const twitterEngagements = await prisma.twitterEngagement.findMany()
    * ```
    */
  get twitterEngagement(): Prisma.TwitterEngagementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminSession`: Exposes CRUD operations for the **AdminSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminSessions
    * const adminSessions = await prisma.adminSession.findMany()
    * ```
    */
  get adminSession(): Prisma.AdminSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminAuditLog`: Exposes CRUD operations for the **AdminAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminAuditLogs
    * const adminAuditLogs = await prisma.adminAuditLog.findMany()
    * ```
    */
  get adminAuditLog(): Prisma.AdminAuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fraudAlert`: Exposes CRUD operations for the **FraudAlert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FraudAlerts
    * const fraudAlerts = await prisma.fraudAlert.findMany()
    * ```
    */
  get fraudAlert(): Prisma.FraudAlertDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.campaignConfig`: Exposes CRUD operations for the **CampaignConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CampaignConfigs
    * const campaignConfigs = await prisma.campaignConfig.findMany()
    * ```
    */
  get campaignConfig(): Prisma.CampaignConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskCompletion`: Exposes CRUD operations for the **TaskCompletion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskCompletions
    * const taskCompletions = await prisma.taskCompletion.findMany()
    * ```
    */
  get taskCompletion(): Prisma.TaskCompletionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.claim`: Exposes CRUD operations for the **Claim** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Claims
    * const claims = await prisma.claim.findMany()
    * ```
    */
  get claim(): Prisma.ClaimDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pointHistory`: Exposes CRUD operations for the **PointHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PointHistories
    * const pointHistories = await prisma.pointHistory.findMany()
    * ```
    */
  get pointHistory(): Prisma.PointHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referral`: Exposes CRUD operations for the **Referral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referrals
    * const referrals = await prisma.referral.findMany()
    * ```
    */
  get referral(): Prisma.ReferralDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemConfig`: Exposes CRUD operations for the **SystemConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemConfigs
    * const systemConfigs = await prisma.systemConfig.findMany()
    * ```
    */
  get systemConfig(): Prisma.SystemConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.analytics`: Exposes CRUD operations for the **Analytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Analytics
    * const analytics = await prisma.analytics.findMany()
    * ```
    */
  get analytics(): Prisma.AnalyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dailyEarning`: Exposes CRUD operations for the **DailyEarning** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DailyEarnings
    * const dailyEarnings = await prisma.dailyEarning.findMany()
    * ```
    */
  get dailyEarning(): Prisma.DailyEarningDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.airdropSeason`: Exposes CRUD operations for the **AirdropSeason** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AirdropSeasons
    * const airdropSeasons = await prisma.airdropSeason.findMany()
    * ```
    */
  get airdropSeason(): Prisma.AirdropSeasonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.airdropClaim`: Exposes CRUD operations for the **AirdropClaim** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AirdropClaims
    * const airdropClaims = await prisma.airdropClaim.findMany()
    * ```
    */
  get airdropClaim(): Prisma.AirdropClaimDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nftCollection`: Exposes CRUD operations for the **NftCollection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NftCollections
    * const nftCollections = await prisma.nftCollection.findMany()
    * ```
    */
  get nftCollection(): Prisma.NftCollectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nftDistribution`: Exposes CRUD operations for the **NftDistribution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NftDistributions
    * const nftDistributions = await prisma.nftDistribution.findMany()
    * ```
    */
  get nftDistribution(): Prisma.NftDistributionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nftClaimApproval`: Exposes CRUD operations for the **NftClaimApproval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NftClaimApprovals
    * const nftClaimApprovals = await prisma.nftClaimApproval.findMany()
    * ```
    */
  get nftClaimApproval(): Prisma.NftClaimApprovalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userNftHolding`: Exposes CRUD operations for the **UserNftHolding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserNftHoldings
    * const userNftHoldings = await prisma.userNftHolding.findMany()
    * ```
    */
  get userNftHolding(): Prisma.UserNftHoldingDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.1
   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Achievement: 'Achievement',
    UserAchievement: 'UserAchievement',
    Notification: 'Notification',
    TwitterAnalytics: 'TwitterAnalytics',
    TwitterEngagement: 'TwitterEngagement',
    Task: 'Task',
    AdminSession: 'AdminSession',
    AdminAuditLog: 'AdminAuditLog',
    FraudAlert: 'FraudAlert',
    CampaignConfig: 'CampaignConfig',
    TaskCompletion: 'TaskCompletion',
    Claim: 'Claim',
    PointHistory: 'PointHistory',
    Referral: 'Referral',
    SystemConfig: 'SystemConfig',
    Analytics: 'Analytics',
    DailyEarning: 'DailyEarning',
    AirdropSeason: 'AirdropSeason',
    AirdropClaim: 'AirdropClaim',
    NftCollection: 'NftCollection',
    NftDistribution: 'NftDistribution',
    NftClaimApproval: 'NftClaimApproval',
    UserNftHolding: 'UserNftHolding'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "achievement" | "userAchievement" | "notification" | "twitterAnalytics" | "twitterEngagement" | "task" | "adminSession" | "adminAuditLog" | "fraudAlert" | "campaignConfig" | "taskCompletion" | "claim" | "pointHistory" | "referral" | "systemConfig" | "analytics" | "dailyEarning" | "airdropSeason" | "airdropClaim" | "nftCollection" | "nftDistribution" | "nftClaimApproval" | "userNftHolding"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AchievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      UserAchievement: {
        payload: Prisma.$UserAchievementPayload<ExtArgs>
        fields: Prisma.UserAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findFirst: {
            args: Prisma.UserAchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findMany: {
            args: Prisma.UserAchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          create: {
            args: Prisma.UserAchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          createMany: {
            args: Prisma.UserAchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserAchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          delete: {
            args: Prisma.UserAchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          update: {
            args: Prisma.UserAchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          deleteMany: {
            args: Prisma.UserAchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserAchievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          upsert: {
            args: Prisma.UserAchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          aggregate: {
            args: Prisma.UserAchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAchievement>
          }
          groupBy: {
            args: Prisma.UserAchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAchievementCountArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      TwitterAnalytics: {
        payload: Prisma.$TwitterAnalyticsPayload<ExtArgs>
        fields: Prisma.TwitterAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TwitterAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitterAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TwitterAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitterAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.TwitterAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitterAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TwitterAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitterAnalyticsPayload>
          }
          findMany: {
            args: Prisma.TwitterAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitterAnalyticsPayload>[]
          }
          create: {
            args: Prisma.TwitterAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitterAnalyticsPayload>
          }
          createMany: {
            args: Prisma.TwitterAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TwitterAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitterAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.TwitterAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitterAnalyticsPayload>
          }
          update: {
            args: Prisma.TwitterAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitterAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.TwitterAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TwitterAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TwitterAnalyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitterAnalyticsPayload>[]
          }
          upsert: {
            args: Prisma.TwitterAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitterAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.TwitterAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTwitterAnalytics>
          }
          groupBy: {
            args: Prisma.TwitterAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TwitterAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TwitterAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<TwitterAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      TwitterEngagement: {
        payload: Prisma.$TwitterEngagementPayload<ExtArgs>
        fields: Prisma.TwitterEngagementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TwitterEngagementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitterEngagementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TwitterEngagementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitterEngagementPayload>
          }
          findFirst: {
            args: Prisma.TwitterEngagementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitterEngagementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TwitterEngagementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitterEngagementPayload>
          }
          findMany: {
            args: Prisma.TwitterEngagementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitterEngagementPayload>[]
          }
          create: {
            args: Prisma.TwitterEngagementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitterEngagementPayload>
          }
          createMany: {
            args: Prisma.TwitterEngagementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TwitterEngagementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitterEngagementPayload>[]
          }
          delete: {
            args: Prisma.TwitterEngagementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitterEngagementPayload>
          }
          update: {
            args: Prisma.TwitterEngagementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitterEngagementPayload>
          }
          deleteMany: {
            args: Prisma.TwitterEngagementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TwitterEngagementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TwitterEngagementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitterEngagementPayload>[]
          }
          upsert: {
            args: Prisma.TwitterEngagementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TwitterEngagementPayload>
          }
          aggregate: {
            args: Prisma.TwitterEngagementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTwitterEngagement>
          }
          groupBy: {
            args: Prisma.TwitterEngagementGroupByArgs<ExtArgs>
            result: $Utils.Optional<TwitterEngagementGroupByOutputType>[]
          }
          count: {
            args: Prisma.TwitterEngagementCountArgs<ExtArgs>
            result: $Utils.Optional<TwitterEngagementCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      AdminSession: {
        payload: Prisma.$AdminSessionPayload<ExtArgs>
        fields: Prisma.AdminSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          findFirst: {
            args: Prisma.AdminSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          findMany: {
            args: Prisma.AdminSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>[]
          }
          create: {
            args: Prisma.AdminSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          createMany: {
            args: Prisma.AdminSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>[]
          }
          delete: {
            args: Prisma.AdminSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          update: {
            args: Prisma.AdminSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          deleteMany: {
            args: Prisma.AdminSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>[]
          }
          upsert: {
            args: Prisma.AdminSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminSessionPayload>
          }
          aggregate: {
            args: Prisma.AdminSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminSession>
          }
          groupBy: {
            args: Prisma.AdminSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminSessionCountArgs<ExtArgs>
            result: $Utils.Optional<AdminSessionCountAggregateOutputType> | number
          }
        }
      }
      AdminAuditLog: {
        payload: Prisma.$AdminAuditLogPayload<ExtArgs>
        fields: Prisma.AdminAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminAuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminAuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          findFirst: {
            args: Prisma.AdminAuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminAuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          findMany: {
            args: Prisma.AdminAuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>[]
          }
          create: {
            args: Prisma.AdminAuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          createMany: {
            args: Prisma.AdminAuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminAuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>[]
          }
          delete: {
            args: Prisma.AdminAuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          update: {
            args: Prisma.AdminAuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AdminAuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminAuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminAuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AdminAuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          aggregate: {
            args: Prisma.AdminAuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminAuditLog>
          }
          groupBy: {
            args: Prisma.AdminAuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminAuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AdminAuditLogCountAggregateOutputType> | number
          }
        }
      }
      FraudAlert: {
        payload: Prisma.$FraudAlertPayload<ExtArgs>
        fields: Prisma.FraudAlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FraudAlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudAlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FraudAlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudAlertPayload>
          }
          findFirst: {
            args: Prisma.FraudAlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudAlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FraudAlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudAlertPayload>
          }
          findMany: {
            args: Prisma.FraudAlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudAlertPayload>[]
          }
          create: {
            args: Prisma.FraudAlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudAlertPayload>
          }
          createMany: {
            args: Prisma.FraudAlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FraudAlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudAlertPayload>[]
          }
          delete: {
            args: Prisma.FraudAlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudAlertPayload>
          }
          update: {
            args: Prisma.FraudAlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudAlertPayload>
          }
          deleteMany: {
            args: Prisma.FraudAlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FraudAlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FraudAlertUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudAlertPayload>[]
          }
          upsert: {
            args: Prisma.FraudAlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FraudAlertPayload>
          }
          aggregate: {
            args: Prisma.FraudAlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFraudAlert>
          }
          groupBy: {
            args: Prisma.FraudAlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<FraudAlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.FraudAlertCountArgs<ExtArgs>
            result: $Utils.Optional<FraudAlertCountAggregateOutputType> | number
          }
        }
      }
      CampaignConfig: {
        payload: Prisma.$CampaignConfigPayload<ExtArgs>
        fields: Prisma.CampaignConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CampaignConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CampaignConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignConfigPayload>
          }
          findFirst: {
            args: Prisma.CampaignConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CampaignConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignConfigPayload>
          }
          findMany: {
            args: Prisma.CampaignConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignConfigPayload>[]
          }
          create: {
            args: Prisma.CampaignConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignConfigPayload>
          }
          createMany: {
            args: Prisma.CampaignConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CampaignConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignConfigPayload>[]
          }
          delete: {
            args: Prisma.CampaignConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignConfigPayload>
          }
          update: {
            args: Prisma.CampaignConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignConfigPayload>
          }
          deleteMany: {
            args: Prisma.CampaignConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CampaignConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CampaignConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignConfigPayload>[]
          }
          upsert: {
            args: Prisma.CampaignConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CampaignConfigPayload>
          }
          aggregate: {
            args: Prisma.CampaignConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCampaignConfig>
          }
          groupBy: {
            args: Prisma.CampaignConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<CampaignConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.CampaignConfigCountArgs<ExtArgs>
            result: $Utils.Optional<CampaignConfigCountAggregateOutputType> | number
          }
        }
      }
      TaskCompletion: {
        payload: Prisma.$TaskCompletionPayload<ExtArgs>
        fields: Prisma.TaskCompletionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskCompletionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCompletionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskCompletionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCompletionPayload>
          }
          findFirst: {
            args: Prisma.TaskCompletionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCompletionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskCompletionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCompletionPayload>
          }
          findMany: {
            args: Prisma.TaskCompletionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCompletionPayload>[]
          }
          create: {
            args: Prisma.TaskCompletionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCompletionPayload>
          }
          createMany: {
            args: Prisma.TaskCompletionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCompletionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCompletionPayload>[]
          }
          delete: {
            args: Prisma.TaskCompletionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCompletionPayload>
          }
          update: {
            args: Prisma.TaskCompletionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCompletionPayload>
          }
          deleteMany: {
            args: Prisma.TaskCompletionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskCompletionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskCompletionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCompletionPayload>[]
          }
          upsert: {
            args: Prisma.TaskCompletionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskCompletionPayload>
          }
          aggregate: {
            args: Prisma.TaskCompletionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskCompletion>
          }
          groupBy: {
            args: Prisma.TaskCompletionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskCompletionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCompletionCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCompletionCountAggregateOutputType> | number
          }
        }
      }
      Claim: {
        payload: Prisma.$ClaimPayload<ExtArgs>
        fields: Prisma.ClaimFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClaimFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClaimFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          findFirst: {
            args: Prisma.ClaimFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClaimFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          findMany: {
            args: Prisma.ClaimFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>[]
          }
          create: {
            args: Prisma.ClaimCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          createMany: {
            args: Prisma.ClaimCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClaimCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>[]
          }
          delete: {
            args: Prisma.ClaimDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          update: {
            args: Prisma.ClaimUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          deleteMany: {
            args: Prisma.ClaimDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClaimUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClaimUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>[]
          }
          upsert: {
            args: Prisma.ClaimUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClaimPayload>
          }
          aggregate: {
            args: Prisma.ClaimAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClaim>
          }
          groupBy: {
            args: Prisma.ClaimGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClaimGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClaimCountArgs<ExtArgs>
            result: $Utils.Optional<ClaimCountAggregateOutputType> | number
          }
        }
      }
      PointHistory: {
        payload: Prisma.$PointHistoryPayload<ExtArgs>
        fields: Prisma.PointHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PointHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PointHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointHistoryPayload>
          }
          findFirst: {
            args: Prisma.PointHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PointHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointHistoryPayload>
          }
          findMany: {
            args: Prisma.PointHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointHistoryPayload>[]
          }
          create: {
            args: Prisma.PointHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointHistoryPayload>
          }
          createMany: {
            args: Prisma.PointHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PointHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointHistoryPayload>[]
          }
          delete: {
            args: Prisma.PointHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointHistoryPayload>
          }
          update: {
            args: Prisma.PointHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PointHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PointHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PointHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointHistoryPayload>[]
          }
          upsert: {
            args: Prisma.PointHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PointHistoryPayload>
          }
          aggregate: {
            args: Prisma.PointHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePointHistory>
          }
          groupBy: {
            args: Prisma.PointHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PointHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PointHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<PointHistoryCountAggregateOutputType> | number
          }
        }
      }
      Referral: {
        payload: Prisma.$ReferralPayload<ExtArgs>
        fields: Prisma.ReferralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findFirst: {
            args: Prisma.ReferralFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findMany: {
            args: Prisma.ReferralFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          create: {
            args: Prisma.ReferralCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          createMany: {
            args: Prisma.ReferralCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          delete: {
            args: Prisma.ReferralDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          update: {
            args: Prisma.ReferralUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          deleteMany: {
            args: Prisma.ReferralDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReferralUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          upsert: {
            args: Prisma.ReferralUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          aggregate: {
            args: Prisma.ReferralAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferral>
          }
          groupBy: {
            args: Prisma.ReferralGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralCountAggregateOutputType> | number
          }
        }
      }
      SystemConfig: {
        payload: Prisma.$SystemConfigPayload<ExtArgs>
        fields: Prisma.SystemConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findFirst: {
            args: Prisma.SystemConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findMany: {
            args: Prisma.SystemConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          create: {
            args: Prisma.SystemConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          createMany: {
            args: Prisma.SystemConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          delete: {
            args: Prisma.SystemConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          update: {
            args: Prisma.SystemConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          deleteMany: {
            args: Prisma.SystemConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          upsert: {
            args: Prisma.SystemConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          aggregate: {
            args: Prisma.SystemConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemConfig>
          }
          groupBy: {
            args: Prisma.SystemConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigCountAggregateOutputType> | number
          }
        }
      }
      Analytics: {
        payload: Prisma.$AnalyticsPayload<ExtArgs>
        fields: Prisma.AnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          findMany: {
            args: Prisma.AnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>[]
          }
          create: {
            args: Prisma.AnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          createMany: {
            args: Prisma.AnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          update: {
            args: Prisma.AnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnalyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>[]
          }
          upsert: {
            args: Prisma.AnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalytics>
          }
          groupBy: {
            args: Prisma.AnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsCountAggregateOutputType> | number
          }
        }
      }
      DailyEarning: {
        payload: Prisma.$DailyEarningPayload<ExtArgs>
        fields: Prisma.DailyEarningFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DailyEarningFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEarningPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DailyEarningFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEarningPayload>
          }
          findFirst: {
            args: Prisma.DailyEarningFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEarningPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DailyEarningFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEarningPayload>
          }
          findMany: {
            args: Prisma.DailyEarningFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEarningPayload>[]
          }
          create: {
            args: Prisma.DailyEarningCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEarningPayload>
          }
          createMany: {
            args: Prisma.DailyEarningCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DailyEarningCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEarningPayload>[]
          }
          delete: {
            args: Prisma.DailyEarningDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEarningPayload>
          }
          update: {
            args: Prisma.DailyEarningUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEarningPayload>
          }
          deleteMany: {
            args: Prisma.DailyEarningDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DailyEarningUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DailyEarningUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEarningPayload>[]
          }
          upsert: {
            args: Prisma.DailyEarningUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DailyEarningPayload>
          }
          aggregate: {
            args: Prisma.DailyEarningAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDailyEarning>
          }
          groupBy: {
            args: Prisma.DailyEarningGroupByArgs<ExtArgs>
            result: $Utils.Optional<DailyEarningGroupByOutputType>[]
          }
          count: {
            args: Prisma.DailyEarningCountArgs<ExtArgs>
            result: $Utils.Optional<DailyEarningCountAggregateOutputType> | number
          }
        }
      }
      AirdropSeason: {
        payload: Prisma.$AirdropSeasonPayload<ExtArgs>
        fields: Prisma.AirdropSeasonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AirdropSeasonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirdropSeasonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AirdropSeasonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirdropSeasonPayload>
          }
          findFirst: {
            args: Prisma.AirdropSeasonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirdropSeasonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AirdropSeasonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirdropSeasonPayload>
          }
          findMany: {
            args: Prisma.AirdropSeasonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirdropSeasonPayload>[]
          }
          create: {
            args: Prisma.AirdropSeasonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirdropSeasonPayload>
          }
          createMany: {
            args: Prisma.AirdropSeasonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AirdropSeasonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirdropSeasonPayload>[]
          }
          delete: {
            args: Prisma.AirdropSeasonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirdropSeasonPayload>
          }
          update: {
            args: Prisma.AirdropSeasonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirdropSeasonPayload>
          }
          deleteMany: {
            args: Prisma.AirdropSeasonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AirdropSeasonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AirdropSeasonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirdropSeasonPayload>[]
          }
          upsert: {
            args: Prisma.AirdropSeasonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirdropSeasonPayload>
          }
          aggregate: {
            args: Prisma.AirdropSeasonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAirdropSeason>
          }
          groupBy: {
            args: Prisma.AirdropSeasonGroupByArgs<ExtArgs>
            result: $Utils.Optional<AirdropSeasonGroupByOutputType>[]
          }
          count: {
            args: Prisma.AirdropSeasonCountArgs<ExtArgs>
            result: $Utils.Optional<AirdropSeasonCountAggregateOutputType> | number
          }
        }
      }
      AirdropClaim: {
        payload: Prisma.$AirdropClaimPayload<ExtArgs>
        fields: Prisma.AirdropClaimFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AirdropClaimFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirdropClaimPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AirdropClaimFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirdropClaimPayload>
          }
          findFirst: {
            args: Prisma.AirdropClaimFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirdropClaimPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AirdropClaimFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirdropClaimPayload>
          }
          findMany: {
            args: Prisma.AirdropClaimFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirdropClaimPayload>[]
          }
          create: {
            args: Prisma.AirdropClaimCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirdropClaimPayload>
          }
          createMany: {
            args: Prisma.AirdropClaimCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AirdropClaimCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirdropClaimPayload>[]
          }
          delete: {
            args: Prisma.AirdropClaimDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirdropClaimPayload>
          }
          update: {
            args: Prisma.AirdropClaimUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirdropClaimPayload>
          }
          deleteMany: {
            args: Prisma.AirdropClaimDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AirdropClaimUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AirdropClaimUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirdropClaimPayload>[]
          }
          upsert: {
            args: Prisma.AirdropClaimUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AirdropClaimPayload>
          }
          aggregate: {
            args: Prisma.AirdropClaimAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAirdropClaim>
          }
          groupBy: {
            args: Prisma.AirdropClaimGroupByArgs<ExtArgs>
            result: $Utils.Optional<AirdropClaimGroupByOutputType>[]
          }
          count: {
            args: Prisma.AirdropClaimCountArgs<ExtArgs>
            result: $Utils.Optional<AirdropClaimCountAggregateOutputType> | number
          }
        }
      }
      NftCollection: {
        payload: Prisma.$NftCollectionPayload<ExtArgs>
        fields: Prisma.NftCollectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NftCollectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftCollectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NftCollectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftCollectionPayload>
          }
          findFirst: {
            args: Prisma.NftCollectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftCollectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NftCollectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftCollectionPayload>
          }
          findMany: {
            args: Prisma.NftCollectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftCollectionPayload>[]
          }
          create: {
            args: Prisma.NftCollectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftCollectionPayload>
          }
          createMany: {
            args: Prisma.NftCollectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NftCollectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftCollectionPayload>[]
          }
          delete: {
            args: Prisma.NftCollectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftCollectionPayload>
          }
          update: {
            args: Prisma.NftCollectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftCollectionPayload>
          }
          deleteMany: {
            args: Prisma.NftCollectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NftCollectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NftCollectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftCollectionPayload>[]
          }
          upsert: {
            args: Prisma.NftCollectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftCollectionPayload>
          }
          aggregate: {
            args: Prisma.NftCollectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNftCollection>
          }
          groupBy: {
            args: Prisma.NftCollectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<NftCollectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.NftCollectionCountArgs<ExtArgs>
            result: $Utils.Optional<NftCollectionCountAggregateOutputType> | number
          }
        }
      }
      NftDistribution: {
        payload: Prisma.$NftDistributionPayload<ExtArgs>
        fields: Prisma.NftDistributionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NftDistributionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftDistributionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NftDistributionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftDistributionPayload>
          }
          findFirst: {
            args: Prisma.NftDistributionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftDistributionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NftDistributionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftDistributionPayload>
          }
          findMany: {
            args: Prisma.NftDistributionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftDistributionPayload>[]
          }
          create: {
            args: Prisma.NftDistributionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftDistributionPayload>
          }
          createMany: {
            args: Prisma.NftDistributionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NftDistributionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftDistributionPayload>[]
          }
          delete: {
            args: Prisma.NftDistributionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftDistributionPayload>
          }
          update: {
            args: Prisma.NftDistributionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftDistributionPayload>
          }
          deleteMany: {
            args: Prisma.NftDistributionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NftDistributionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NftDistributionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftDistributionPayload>[]
          }
          upsert: {
            args: Prisma.NftDistributionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftDistributionPayload>
          }
          aggregate: {
            args: Prisma.NftDistributionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNftDistribution>
          }
          groupBy: {
            args: Prisma.NftDistributionGroupByArgs<ExtArgs>
            result: $Utils.Optional<NftDistributionGroupByOutputType>[]
          }
          count: {
            args: Prisma.NftDistributionCountArgs<ExtArgs>
            result: $Utils.Optional<NftDistributionCountAggregateOutputType> | number
          }
        }
      }
      NftClaimApproval: {
        payload: Prisma.$NftClaimApprovalPayload<ExtArgs>
        fields: Prisma.NftClaimApprovalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NftClaimApprovalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftClaimApprovalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NftClaimApprovalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftClaimApprovalPayload>
          }
          findFirst: {
            args: Prisma.NftClaimApprovalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftClaimApprovalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NftClaimApprovalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftClaimApprovalPayload>
          }
          findMany: {
            args: Prisma.NftClaimApprovalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftClaimApprovalPayload>[]
          }
          create: {
            args: Prisma.NftClaimApprovalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftClaimApprovalPayload>
          }
          createMany: {
            args: Prisma.NftClaimApprovalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NftClaimApprovalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftClaimApprovalPayload>[]
          }
          delete: {
            args: Prisma.NftClaimApprovalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftClaimApprovalPayload>
          }
          update: {
            args: Prisma.NftClaimApprovalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftClaimApprovalPayload>
          }
          deleteMany: {
            args: Prisma.NftClaimApprovalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NftClaimApprovalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NftClaimApprovalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftClaimApprovalPayload>[]
          }
          upsert: {
            args: Prisma.NftClaimApprovalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NftClaimApprovalPayload>
          }
          aggregate: {
            args: Prisma.NftClaimApprovalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNftClaimApproval>
          }
          groupBy: {
            args: Prisma.NftClaimApprovalGroupByArgs<ExtArgs>
            result: $Utils.Optional<NftClaimApprovalGroupByOutputType>[]
          }
          count: {
            args: Prisma.NftClaimApprovalCountArgs<ExtArgs>
            result: $Utils.Optional<NftClaimApprovalCountAggregateOutputType> | number
          }
        }
      }
      UserNftHolding: {
        payload: Prisma.$UserNftHoldingPayload<ExtArgs>
        fields: Prisma.UserNftHoldingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserNftHoldingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNftHoldingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserNftHoldingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNftHoldingPayload>
          }
          findFirst: {
            args: Prisma.UserNftHoldingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNftHoldingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserNftHoldingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNftHoldingPayload>
          }
          findMany: {
            args: Prisma.UserNftHoldingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNftHoldingPayload>[]
          }
          create: {
            args: Prisma.UserNftHoldingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNftHoldingPayload>
          }
          createMany: {
            args: Prisma.UserNftHoldingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserNftHoldingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNftHoldingPayload>[]
          }
          delete: {
            args: Prisma.UserNftHoldingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNftHoldingPayload>
          }
          update: {
            args: Prisma.UserNftHoldingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNftHoldingPayload>
          }
          deleteMany: {
            args: Prisma.UserNftHoldingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserNftHoldingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserNftHoldingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNftHoldingPayload>[]
          }
          upsert: {
            args: Prisma.UserNftHoldingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserNftHoldingPayload>
          }
          aggregate: {
            args: Prisma.UserNftHoldingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserNftHolding>
          }
          groupBy: {
            args: Prisma.UserNftHoldingGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserNftHoldingGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserNftHoldingCountArgs<ExtArgs>
            result: $Utils.Optional<UserNftHoldingCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    achievement?: AchievementOmit
    userAchievement?: UserAchievementOmit
    notification?: NotificationOmit
    twitterAnalytics?: TwitterAnalyticsOmit
    twitterEngagement?: TwitterEngagementOmit
    task?: TaskOmit
    adminSession?: AdminSessionOmit
    adminAuditLog?: AdminAuditLogOmit
    fraudAlert?: FraudAlertOmit
    campaignConfig?: CampaignConfigOmit
    taskCompletion?: TaskCompletionOmit
    claim?: ClaimOmit
    pointHistory?: PointHistoryOmit
    referral?: ReferralOmit
    systemConfig?: SystemConfigOmit
    analytics?: AnalyticsOmit
    dailyEarning?: DailyEarningOmit
    airdropSeason?: AirdropSeasonOmit
    airdropClaim?: AirdropClaimOmit
    nftCollection?: NftCollectionOmit
    nftDistribution?: NftDistributionOmit
    nftClaimApproval?: NftClaimApprovalOmit
    userNftHolding?: UserNftHoldingOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    dailyEarnings: number
    airdropClaims: number
    engagements: number
    tasks: number
    claims: number
    pointHistory: number
    referrals: number
    achievements: number
    notifications: number
    adminSessions: number
    auditLogs: number
    fraudAlerts: number
    campaigns: number
    nftCollections: number
    nftDistributions: number
    nftHoldings: number
    approvedClaims: number
    airdropSeasons: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dailyEarnings?: boolean | UserCountOutputTypeCountDailyEarningsArgs
    airdropClaims?: boolean | UserCountOutputTypeCountAirdropClaimsArgs
    engagements?: boolean | UserCountOutputTypeCountEngagementsArgs
    tasks?: boolean | UserCountOutputTypeCountTasksArgs
    claims?: boolean | UserCountOutputTypeCountClaimsArgs
    pointHistory?: boolean | UserCountOutputTypeCountPointHistoryArgs
    referrals?: boolean | UserCountOutputTypeCountReferralsArgs
    achievements?: boolean | UserCountOutputTypeCountAchievementsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    adminSessions?: boolean | UserCountOutputTypeCountAdminSessionsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    fraudAlerts?: boolean | UserCountOutputTypeCountFraudAlertsArgs
    campaigns?: boolean | UserCountOutputTypeCountCampaignsArgs
    nftCollections?: boolean | UserCountOutputTypeCountNftCollectionsArgs
    nftDistributions?: boolean | UserCountOutputTypeCountNftDistributionsArgs
    nftHoldings?: boolean | UserCountOutputTypeCountNftHoldingsArgs
    approvedClaims?: boolean | UserCountOutputTypeCountApprovedClaimsArgs
    airdropSeasons?: boolean | UserCountOutputTypeCountAirdropSeasonsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDailyEarningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyEarningWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAirdropClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AirdropClaimWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEngagementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwitterEngagementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCompletionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPointHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReferralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdminSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFraudAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FraudAlertWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCampaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignConfigWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNftCollectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NftCollectionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNftDistributionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NftDistributionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNftHoldingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserNftHoldingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NftClaimApprovalWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAirdropSeasonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AirdropSeasonWhereInput
  }


  /**
   * Count Type AchievementCountOutputType
   */

  export type AchievementCountOutputType = {
    userAchievements: number
  }

  export type AchievementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAchievements?: boolean | AchievementCountOutputTypeCountUserAchievementsArgs
  }

  // Custom InputTypes
  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AchievementCountOutputType
     */
    select?: AchievementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AchievementCountOutputType without action
   */
  export type AchievementCountOutputTypeCountUserAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }


  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    completions: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    completions?: boolean | TaskCountOutputTypeCountCompletionsArgs
  }

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCompletionWhereInput
  }


  /**
   * Count Type AirdropSeasonCountOutputType
   */

  export type AirdropSeasonCountOutputType = {
    claims: number
  }

  export type AirdropSeasonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    claims?: boolean | AirdropSeasonCountOutputTypeCountClaimsArgs
  }

  // Custom InputTypes
  /**
   * AirdropSeasonCountOutputType without action
   */
  export type AirdropSeasonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropSeasonCountOutputType
     */
    select?: AirdropSeasonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AirdropSeasonCountOutputType without action
   */
  export type AirdropSeasonCountOutputTypeCountClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AirdropClaimWhereInput
  }


  /**
   * Count Type NftCollectionCountOutputType
   */

  export type NftCollectionCountOutputType = {
    distributions: number
  }

  export type NftCollectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    distributions?: boolean | NftCollectionCountOutputTypeCountDistributionsArgs
  }

  // Custom InputTypes
  /**
   * NftCollectionCountOutputType without action
   */
  export type NftCollectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftCollectionCountOutputType
     */
    select?: NftCollectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NftCollectionCountOutputType without action
   */
  export type NftCollectionCountOutputTypeCountDistributionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NftDistributionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    twitterFollowers: number | null
    level: number | null
    streak: number | null
    totalPoints: number | null
    rank: number | null
    totalEarnedTokens: number | null
    riskScore: number | null
  }

  export type UserSumAggregateOutputType = {
    twitterFollowers: number | null
    level: number | null
    streak: number | null
    totalPoints: number | null
    rank: number | null
    totalEarnedTokens: number | null
    riskScore: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    walletAddress: string | null
    twitterId: string | null
    twitterUsername: string | null
    twitterName: string | null
    twitterImage: string | null
    twitterFollowers: number | null
    twitterActivity: $Enums.TwitterActivity | null
    level: number | null
    streak: number | null
    lastCheckIn: Date | null
    referralCode: string | null
    email: string | null
    totalPoints: number | null
    rank: number | null
    isAdmin: boolean | null
    isActive: boolean | null
    totalEarnedTokens: number | null
    lastLoginReward: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    riskScore: number | null
    isBanned: boolean | null
    bannedAt: Date | null
    lastActivity: Date | null
    claimsEnabled: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    walletAddress: string | null
    twitterId: string | null
    twitterUsername: string | null
    twitterName: string | null
    twitterImage: string | null
    twitterFollowers: number | null
    twitterActivity: $Enums.TwitterActivity | null
    level: number | null
    streak: number | null
    lastCheckIn: Date | null
    referralCode: string | null
    email: string | null
    totalPoints: number | null
    rank: number | null
    isAdmin: boolean | null
    isActive: boolean | null
    totalEarnedTokens: number | null
    lastLoginReward: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    riskScore: number | null
    isBanned: boolean | null
    bannedAt: Date | null
    lastActivity: Date | null
    claimsEnabled: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    walletAddress: number
    twitterId: number
    twitterUsername: number
    twitterName: number
    twitterImage: number
    twitterFollowers: number
    twitterActivity: number
    level: number
    streak: number
    lastCheckIn: number
    referralCode: number
    email: number
    totalPoints: number
    rank: number
    isAdmin: number
    isActive: number
    totalEarnedTokens: number
    lastLoginReward: number
    createdAt: number
    updatedAt: number
    permissions: number
    riskScore: number
    suspiciousFlags: number
    isBanned: number
    bannedAt: number
    lastActivity: number
    claimsEnabled: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    twitterFollowers?: true
    level?: true
    streak?: true
    totalPoints?: true
    rank?: true
    totalEarnedTokens?: true
    riskScore?: true
  }

  export type UserSumAggregateInputType = {
    twitterFollowers?: true
    level?: true
    streak?: true
    totalPoints?: true
    rank?: true
    totalEarnedTokens?: true
    riskScore?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    walletAddress?: true
    twitterId?: true
    twitterUsername?: true
    twitterName?: true
    twitterImage?: true
    twitterFollowers?: true
    twitterActivity?: true
    level?: true
    streak?: true
    lastCheckIn?: true
    referralCode?: true
    email?: true
    totalPoints?: true
    rank?: true
    isAdmin?: true
    isActive?: true
    totalEarnedTokens?: true
    lastLoginReward?: true
    createdAt?: true
    updatedAt?: true
    riskScore?: true
    isBanned?: true
    bannedAt?: true
    lastActivity?: true
    claimsEnabled?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    walletAddress?: true
    twitterId?: true
    twitterUsername?: true
    twitterName?: true
    twitterImage?: true
    twitterFollowers?: true
    twitterActivity?: true
    level?: true
    streak?: true
    lastCheckIn?: true
    referralCode?: true
    email?: true
    totalPoints?: true
    rank?: true
    isAdmin?: true
    isActive?: true
    totalEarnedTokens?: true
    lastLoginReward?: true
    createdAt?: true
    updatedAt?: true
    riskScore?: true
    isBanned?: true
    bannedAt?: true
    lastActivity?: true
    claimsEnabled?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    walletAddress?: true
    twitterId?: true
    twitterUsername?: true
    twitterName?: true
    twitterImage?: true
    twitterFollowers?: true
    twitterActivity?: true
    level?: true
    streak?: true
    lastCheckIn?: true
    referralCode?: true
    email?: true
    totalPoints?: true
    rank?: true
    isAdmin?: true
    isActive?: true
    totalEarnedTokens?: true
    lastLoginReward?: true
    createdAt?: true
    updatedAt?: true
    permissions?: true
    riskScore?: true
    suspiciousFlags?: true
    isBanned?: true
    bannedAt?: true
    lastActivity?: true
    claimsEnabled?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    walletAddress: string
    twitterId: string | null
    twitterUsername: string | null
    twitterName: string | null
    twitterImage: string | null
    twitterFollowers: number | null
    twitterActivity: $Enums.TwitterActivity | null
    level: number
    streak: number
    lastCheckIn: Date | null
    referralCode: string
    email: string | null
    totalPoints: number
    rank: number
    isAdmin: boolean
    isActive: boolean
    totalEarnedTokens: number
    lastLoginReward: Date | null
    createdAt: Date
    updatedAt: Date
    permissions: JsonValue | null
    riskScore: number
    suspiciousFlags: string[]
    isBanned: boolean
    bannedAt: Date | null
    lastActivity: Date | null
    claimsEnabled: boolean | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletAddress?: boolean
    twitterId?: boolean
    twitterUsername?: boolean
    twitterName?: boolean
    twitterImage?: boolean
    twitterFollowers?: boolean
    twitterActivity?: boolean
    level?: boolean
    streak?: boolean
    lastCheckIn?: boolean
    referralCode?: boolean
    email?: boolean
    totalPoints?: boolean
    rank?: boolean
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: boolean
    lastLoginReward?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permissions?: boolean
    riskScore?: boolean
    suspiciousFlags?: boolean
    isBanned?: boolean
    bannedAt?: boolean
    lastActivity?: boolean
    claimsEnabled?: boolean
    dailyEarnings?: boolean | User$dailyEarningsArgs<ExtArgs>
    airdropClaims?: boolean | User$airdropClaimsArgs<ExtArgs>
    engagements?: boolean | User$engagementsArgs<ExtArgs>
    tasks?: boolean | User$tasksArgs<ExtArgs>
    claims?: boolean | User$claimsArgs<ExtArgs>
    pointHistory?: boolean | User$pointHistoryArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    referredBy?: boolean | User$referredByArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    adminSessions?: boolean | User$adminSessionsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    fraudAlerts?: boolean | User$fraudAlertsArgs<ExtArgs>
    campaigns?: boolean | User$campaignsArgs<ExtArgs>
    nftCollections?: boolean | User$nftCollectionsArgs<ExtArgs>
    nftDistributions?: boolean | User$nftDistributionsArgs<ExtArgs>
    nftHoldings?: boolean | User$nftHoldingsArgs<ExtArgs>
    nftClaimApproval?: boolean | User$nftClaimApprovalArgs<ExtArgs>
    approvedClaims?: boolean | User$approvedClaimsArgs<ExtArgs>
    airdropSeasons?: boolean | User$airdropSeasonsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletAddress?: boolean
    twitterId?: boolean
    twitterUsername?: boolean
    twitterName?: boolean
    twitterImage?: boolean
    twitterFollowers?: boolean
    twitterActivity?: boolean
    level?: boolean
    streak?: boolean
    lastCheckIn?: boolean
    referralCode?: boolean
    email?: boolean
    totalPoints?: boolean
    rank?: boolean
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: boolean
    lastLoginReward?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permissions?: boolean
    riskScore?: boolean
    suspiciousFlags?: boolean
    isBanned?: boolean
    bannedAt?: boolean
    lastActivity?: boolean
    claimsEnabled?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletAddress?: boolean
    twitterId?: boolean
    twitterUsername?: boolean
    twitterName?: boolean
    twitterImage?: boolean
    twitterFollowers?: boolean
    twitterActivity?: boolean
    level?: boolean
    streak?: boolean
    lastCheckIn?: boolean
    referralCode?: boolean
    email?: boolean
    totalPoints?: boolean
    rank?: boolean
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: boolean
    lastLoginReward?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permissions?: boolean
    riskScore?: boolean
    suspiciousFlags?: boolean
    isBanned?: boolean
    bannedAt?: boolean
    lastActivity?: boolean
    claimsEnabled?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    walletAddress?: boolean
    twitterId?: boolean
    twitterUsername?: boolean
    twitterName?: boolean
    twitterImage?: boolean
    twitterFollowers?: boolean
    twitterActivity?: boolean
    level?: boolean
    streak?: boolean
    lastCheckIn?: boolean
    referralCode?: boolean
    email?: boolean
    totalPoints?: boolean
    rank?: boolean
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: boolean
    lastLoginReward?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    permissions?: boolean
    riskScore?: boolean
    suspiciousFlags?: boolean
    isBanned?: boolean
    bannedAt?: boolean
    lastActivity?: boolean
    claimsEnabled?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "walletAddress" | "twitterId" | "twitterUsername" | "twitterName" | "twitterImage" | "twitterFollowers" | "twitterActivity" | "level" | "streak" | "lastCheckIn" | "referralCode" | "email" | "totalPoints" | "rank" | "isAdmin" | "isActive" | "totalEarnedTokens" | "lastLoginReward" | "createdAt" | "updatedAt" | "permissions" | "riskScore" | "suspiciousFlags" | "isBanned" | "bannedAt" | "lastActivity" | "claimsEnabled", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dailyEarnings?: boolean | User$dailyEarningsArgs<ExtArgs>
    airdropClaims?: boolean | User$airdropClaimsArgs<ExtArgs>
    engagements?: boolean | User$engagementsArgs<ExtArgs>
    tasks?: boolean | User$tasksArgs<ExtArgs>
    claims?: boolean | User$claimsArgs<ExtArgs>
    pointHistory?: boolean | User$pointHistoryArgs<ExtArgs>
    referrals?: boolean | User$referralsArgs<ExtArgs>
    referredBy?: boolean | User$referredByArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    adminSessions?: boolean | User$adminSessionsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    fraudAlerts?: boolean | User$fraudAlertsArgs<ExtArgs>
    campaigns?: boolean | User$campaignsArgs<ExtArgs>
    nftCollections?: boolean | User$nftCollectionsArgs<ExtArgs>
    nftDistributions?: boolean | User$nftDistributionsArgs<ExtArgs>
    nftHoldings?: boolean | User$nftHoldingsArgs<ExtArgs>
    nftClaimApproval?: boolean | User$nftClaimApprovalArgs<ExtArgs>
    approvedClaims?: boolean | User$approvedClaimsArgs<ExtArgs>
    airdropSeasons?: boolean | User$airdropSeasonsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      dailyEarnings: Prisma.$DailyEarningPayload<ExtArgs>[]
      airdropClaims: Prisma.$AirdropClaimPayload<ExtArgs>[]
      engagements: Prisma.$TwitterEngagementPayload<ExtArgs>[]
      tasks: Prisma.$TaskCompletionPayload<ExtArgs>[]
      claims: Prisma.$ClaimPayload<ExtArgs>[]
      pointHistory: Prisma.$PointHistoryPayload<ExtArgs>[]
      referrals: Prisma.$ReferralPayload<ExtArgs>[]
      referredBy: Prisma.$ReferralPayload<ExtArgs> | null
      achievements: Prisma.$UserAchievementPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      adminSessions: Prisma.$AdminSessionPayload<ExtArgs>[]
      auditLogs: Prisma.$AdminAuditLogPayload<ExtArgs>[]
      fraudAlerts: Prisma.$FraudAlertPayload<ExtArgs>[]
      campaigns: Prisma.$CampaignConfigPayload<ExtArgs>[]
      nftCollections: Prisma.$NftCollectionPayload<ExtArgs>[]
      nftDistributions: Prisma.$NftDistributionPayload<ExtArgs>[]
      nftHoldings: Prisma.$UserNftHoldingPayload<ExtArgs>[]
      nftClaimApproval: Prisma.$NftClaimApprovalPayload<ExtArgs> | null
      approvedClaims: Prisma.$NftClaimApprovalPayload<ExtArgs>[]
      airdropSeasons: Prisma.$AirdropSeasonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      walletAddress: string
      twitterId: string | null
      twitterUsername: string | null
      twitterName: string | null
      twitterImage: string | null
      twitterFollowers: number | null
      twitterActivity: $Enums.TwitterActivity | null
      level: number
      streak: number
      lastCheckIn: Date | null
      referralCode: string
      email: string | null
      totalPoints: number
      rank: number
      isAdmin: boolean
      isActive: boolean
      totalEarnedTokens: number
      lastLoginReward: Date | null
      createdAt: Date
      updatedAt: Date
      permissions: Prisma.JsonValue | null
      riskScore: number
      suspiciousFlags: string[]
      isBanned: boolean
      bannedAt: Date | null
      lastActivity: Date | null
      claimsEnabled: boolean | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dailyEarnings<T extends User$dailyEarningsArgs<ExtArgs> = {}>(args?: Subset<T, User$dailyEarningsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyEarningPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    airdropClaims<T extends User$airdropClaimsArgs<ExtArgs> = {}>(args?: Subset<T, User$airdropClaimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AirdropClaimPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    engagements<T extends User$engagementsArgs<ExtArgs> = {}>(args?: Subset<T, User$engagementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwitterEngagementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends User$tasksArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCompletionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    claims<T extends User$claimsArgs<ExtArgs> = {}>(args?: Subset<T, User$claimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pointHistory<T extends User$pointHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$pointHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referrals<T extends User$referralsArgs<ExtArgs> = {}>(args?: Subset<T, User$referralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referredBy<T extends User$referredByArgs<ExtArgs> = {}>(args?: Subset<T, User$referredByArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    achievements<T extends User$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, User$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminSessions<T extends User$adminSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$adminSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fraudAlerts<T extends User$fraudAlertsArgs<ExtArgs> = {}>(args?: Subset<T, User$fraudAlertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FraudAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    campaigns<T extends User$campaignsArgs<ExtArgs> = {}>(args?: Subset<T, User$campaignsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    nftCollections<T extends User$nftCollectionsArgs<ExtArgs> = {}>(args?: Subset<T, User$nftCollectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NftCollectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    nftDistributions<T extends User$nftDistributionsArgs<ExtArgs> = {}>(args?: Subset<T, User$nftDistributionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NftDistributionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    nftHoldings<T extends User$nftHoldingsArgs<ExtArgs> = {}>(args?: Subset<T, User$nftHoldingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNftHoldingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    nftClaimApproval<T extends User$nftClaimApprovalArgs<ExtArgs> = {}>(args?: Subset<T, User$nftClaimApprovalArgs<ExtArgs>>): Prisma__NftClaimApprovalClient<$Result.GetResult<Prisma.$NftClaimApprovalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    approvedClaims<T extends User$approvedClaimsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedClaimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NftClaimApprovalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    airdropSeasons<T extends User$airdropSeasonsArgs<ExtArgs> = {}>(args?: Subset<T, User$airdropSeasonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AirdropSeasonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly walletAddress: FieldRef<"User", 'String'>
    readonly twitterId: FieldRef<"User", 'String'>
    readonly twitterUsername: FieldRef<"User", 'String'>
    readonly twitterName: FieldRef<"User", 'String'>
    readonly twitterImage: FieldRef<"User", 'String'>
    readonly twitterFollowers: FieldRef<"User", 'Int'>
    readonly twitterActivity: FieldRef<"User", 'TwitterActivity'>
    readonly level: FieldRef<"User", 'Int'>
    readonly streak: FieldRef<"User", 'Int'>
    readonly lastCheckIn: FieldRef<"User", 'DateTime'>
    readonly referralCode: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly totalPoints: FieldRef<"User", 'Int'>
    readonly rank: FieldRef<"User", 'Int'>
    readonly isAdmin: FieldRef<"User", 'Boolean'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly totalEarnedTokens: FieldRef<"User", 'Float'>
    readonly lastLoginReward: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly permissions: FieldRef<"User", 'Json'>
    readonly riskScore: FieldRef<"User", 'Int'>
    readonly suspiciousFlags: FieldRef<"User", 'String[]'>
    readonly isBanned: FieldRef<"User", 'Boolean'>
    readonly bannedAt: FieldRef<"User", 'DateTime'>
    readonly lastActivity: FieldRef<"User", 'DateTime'>
    readonly claimsEnabled: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.dailyEarnings
   */
  export type User$dailyEarningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEarning
     */
    select?: DailyEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyEarning
     */
    omit?: DailyEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEarningInclude<ExtArgs> | null
    where?: DailyEarningWhereInput
    orderBy?: DailyEarningOrderByWithRelationInput | DailyEarningOrderByWithRelationInput[]
    cursor?: DailyEarningWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DailyEarningScalarFieldEnum | DailyEarningScalarFieldEnum[]
  }

  /**
   * User.airdropClaims
   */
  export type User$airdropClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropClaim
     */
    select?: AirdropClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropClaim
     */
    omit?: AirdropClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropClaimInclude<ExtArgs> | null
    where?: AirdropClaimWhereInput
    orderBy?: AirdropClaimOrderByWithRelationInput | AirdropClaimOrderByWithRelationInput[]
    cursor?: AirdropClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AirdropClaimScalarFieldEnum | AirdropClaimScalarFieldEnum[]
  }

  /**
   * User.engagements
   */
  export type User$engagementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterEngagement
     */
    select?: TwitterEngagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterEngagement
     */
    omit?: TwitterEngagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwitterEngagementInclude<ExtArgs> | null
    where?: TwitterEngagementWhereInput
    orderBy?: TwitterEngagementOrderByWithRelationInput | TwitterEngagementOrderByWithRelationInput[]
    cursor?: TwitterEngagementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TwitterEngagementScalarFieldEnum | TwitterEngagementScalarFieldEnum[]
  }

  /**
   * User.tasks
   */
  export type User$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletion
     */
    select?: TaskCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletion
     */
    omit?: TaskCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionInclude<ExtArgs> | null
    where?: TaskCompletionWhereInput
    orderBy?: TaskCompletionOrderByWithRelationInput | TaskCompletionOrderByWithRelationInput[]
    cursor?: TaskCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskCompletionScalarFieldEnum | TaskCompletionScalarFieldEnum[]
  }

  /**
   * User.claims
   */
  export type User$claimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    cursor?: ClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * User.pointHistory
   */
  export type User$pointHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryInclude<ExtArgs> | null
    where?: PointHistoryWhereInput
    orderBy?: PointHistoryOrderByWithRelationInput | PointHistoryOrderByWithRelationInput[]
    cursor?: PointHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PointHistoryScalarFieldEnum | PointHistoryScalarFieldEnum[]
  }

  /**
   * User.referrals
   */
  export type User$referralsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * User.referredBy
   */
  export type User$referredByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
  }

  /**
   * User.achievements
   */
  export type User$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.adminSessions
   */
  export type User$adminSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    where?: AdminSessionWhereInput
    orderBy?: AdminSessionOrderByWithRelationInput | AdminSessionOrderByWithRelationInput[]
    cursor?: AdminSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminSessionScalarFieldEnum | AdminSessionScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    where?: AdminAuditLogWhereInput
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    cursor?: AdminAuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * User.fraudAlerts
   */
  export type User$fraudAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudAlert
     */
    select?: FraudAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudAlert
     */
    omit?: FraudAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudAlertInclude<ExtArgs> | null
    where?: FraudAlertWhereInput
    orderBy?: FraudAlertOrderByWithRelationInput | FraudAlertOrderByWithRelationInput[]
    cursor?: FraudAlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FraudAlertScalarFieldEnum | FraudAlertScalarFieldEnum[]
  }

  /**
   * User.campaigns
   */
  export type User$campaignsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignConfig
     */
    select?: CampaignConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignConfig
     */
    omit?: CampaignConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignConfigInclude<ExtArgs> | null
    where?: CampaignConfigWhereInput
    orderBy?: CampaignConfigOrderByWithRelationInput | CampaignConfigOrderByWithRelationInput[]
    cursor?: CampaignConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CampaignConfigScalarFieldEnum | CampaignConfigScalarFieldEnum[]
  }

  /**
   * User.nftCollections
   */
  export type User$nftCollectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftCollection
     */
    select?: NftCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftCollection
     */
    omit?: NftCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftCollectionInclude<ExtArgs> | null
    where?: NftCollectionWhereInput
    orderBy?: NftCollectionOrderByWithRelationInput | NftCollectionOrderByWithRelationInput[]
    cursor?: NftCollectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NftCollectionScalarFieldEnum | NftCollectionScalarFieldEnum[]
  }

  /**
   * User.nftDistributions
   */
  export type User$nftDistributionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftDistribution
     */
    select?: NftDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftDistribution
     */
    omit?: NftDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftDistributionInclude<ExtArgs> | null
    where?: NftDistributionWhereInput
    orderBy?: NftDistributionOrderByWithRelationInput | NftDistributionOrderByWithRelationInput[]
    cursor?: NftDistributionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NftDistributionScalarFieldEnum | NftDistributionScalarFieldEnum[]
  }

  /**
   * User.nftHoldings
   */
  export type User$nftHoldingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNftHolding
     */
    select?: UserNftHoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNftHolding
     */
    omit?: UserNftHoldingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNftHoldingInclude<ExtArgs> | null
    where?: UserNftHoldingWhereInput
    orderBy?: UserNftHoldingOrderByWithRelationInput | UserNftHoldingOrderByWithRelationInput[]
    cursor?: UserNftHoldingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserNftHoldingScalarFieldEnum | UserNftHoldingScalarFieldEnum[]
  }

  /**
   * User.nftClaimApproval
   */
  export type User$nftClaimApprovalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftClaimApproval
     */
    select?: NftClaimApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftClaimApproval
     */
    omit?: NftClaimApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftClaimApprovalInclude<ExtArgs> | null
    where?: NftClaimApprovalWhereInput
  }

  /**
   * User.approvedClaims
   */
  export type User$approvedClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftClaimApproval
     */
    select?: NftClaimApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftClaimApproval
     */
    omit?: NftClaimApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftClaimApprovalInclude<ExtArgs> | null
    where?: NftClaimApprovalWhereInput
    orderBy?: NftClaimApprovalOrderByWithRelationInput | NftClaimApprovalOrderByWithRelationInput[]
    cursor?: NftClaimApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NftClaimApprovalScalarFieldEnum | NftClaimApprovalScalarFieldEnum[]
  }

  /**
   * User.airdropSeasons
   */
  export type User$airdropSeasonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropSeason
     */
    select?: AirdropSeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropSeason
     */
    omit?: AirdropSeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropSeasonInclude<ExtArgs> | null
    where?: AirdropSeasonWhereInput
    orderBy?: AirdropSeasonOrderByWithRelationInput | AirdropSeasonOrderByWithRelationInput[]
    cursor?: AirdropSeasonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AirdropSeasonScalarFieldEnum | AirdropSeasonScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementAvgAggregateOutputType = {
    points: number | null
  }

  export type AchievementSumAggregateOutputType = {
    points: number | null
  }

  export type AchievementMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    icon: string | null
    points: number | null
    isSecret: boolean | null
    createdAt: Date | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    icon: string | null
    points: number | null
    isSecret: boolean | null
    createdAt: Date | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    name: number
    description: number
    icon: number
    requirements: number
    points: number
    isSecret: number
    createdAt: number
    _all: number
  }


  export type AchievementAvgAggregateInputType = {
    points?: true
  }

  export type AchievementSumAggregateInputType = {
    points?: true
  }

  export type AchievementMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    points?: true
    isSecret?: true
    createdAt?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    points?: true
    isSecret?: true
    createdAt?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    requirements?: true
    points?: true
    isSecret?: true
    createdAt?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _avg?: AchievementAvgAggregateInputType
    _sum?: AchievementSumAggregateInputType
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: string
    name: string
    description: string
    icon: string
    requirements: JsonValue
    points: number
    isSecret: boolean
    createdAt: Date
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    requirements?: boolean
    points?: boolean
    isSecret?: boolean
    createdAt?: boolean
    userAchievements?: boolean | Achievement$userAchievementsArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    requirements?: boolean
    points?: boolean
    isSecret?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    requirements?: boolean
    points?: boolean
    isSecret?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    requirements?: boolean
    points?: boolean
    isSecret?: boolean
    createdAt?: boolean
  }

  export type AchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "icon" | "requirements" | "points" | "isSecret" | "createdAt", ExtArgs["result"]["achievement"]>
  export type AchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAchievements?: boolean | Achievement$userAchievementsArgs<ExtArgs>
    _count?: boolean | AchievementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AchievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {
      userAchievements: Prisma.$UserAchievementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      icon: string
      requirements: Prisma.JsonValue
      points: number
      isSecret: boolean
      createdAt: Date
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {AchievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements and returns the data updated in the database.
     * @param {AchievementUpdateManyAndReturnArgs} args - Arguments to update many Achievements.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AchievementUpdateManyAndReturnArgs>(args: SelectSubset<T, AchievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userAchievements<T extends Achievement$userAchievementsArgs<ExtArgs> = {}>(args?: Subset<T, Achievement$userAchievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'String'>
    readonly name: FieldRef<"Achievement", 'String'>
    readonly description: FieldRef<"Achievement", 'String'>
    readonly icon: FieldRef<"Achievement", 'String'>
    readonly requirements: FieldRef<"Achievement", 'Json'>
    readonly points: FieldRef<"Achievement", 'Int'>
    readonly isSecret: FieldRef<"Achievement", 'Boolean'>
    readonly createdAt: FieldRef<"Achievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement createManyAndReturn
   */
  export type AchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
  }

  /**
   * Achievement updateManyAndReturn
   */
  export type AchievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to delete.
     */
    limit?: number
  }

  /**
   * Achievement.userAchievements
   */
  export type Achievement$userAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
  }


  /**
   * Model UserAchievement
   */

  export type AggregateUserAchievement = {
    _count: UserAchievementCountAggregateOutputType | null
    _avg: UserAchievementAvgAggregateOutputType | null
    _sum: UserAchievementSumAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  export type UserAchievementAvgAggregateOutputType = {
    progress: number | null
  }

  export type UserAchievementSumAggregateOutputType = {
    progress: number | null
  }

  export type UserAchievementMinAggregateOutputType = {
    id: string | null
    userId: string | null
    achievementId: string | null
    unlockedAt: Date | null
    progress: number | null
  }

  export type UserAchievementMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    achievementId: string | null
    unlockedAt: Date | null
    progress: number | null
  }

  export type UserAchievementCountAggregateOutputType = {
    id: number
    userId: number
    achievementId: number
    unlockedAt: number
    progress: number
    _all: number
  }


  export type UserAchievementAvgAggregateInputType = {
    progress?: true
  }

  export type UserAchievementSumAggregateInputType = {
    progress?: true
  }

  export type UserAchievementMinAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    unlockedAt?: true
    progress?: true
  }

  export type UserAchievementMaxAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    unlockedAt?: true
    progress?: true
  }

  export type UserAchievementCountAggregateInputType = {
    id?: true
    userId?: true
    achievementId?: true
    unlockedAt?: true
    progress?: true
    _all?: true
  }

  export type UserAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievement to aggregate.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAchievements
    **/
    _count?: true | UserAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAchievementMaxAggregateInputType
  }

  export type GetUserAchievementAggregateType<T extends UserAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAchievement[P]>
      : GetScalarType<T[P], AggregateUserAchievement[P]>
  }




  export type UserAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithAggregationInput | UserAchievementOrderByWithAggregationInput[]
    by: UserAchievementScalarFieldEnum[] | UserAchievementScalarFieldEnum
    having?: UserAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAchievementCountAggregateInputType | true
    _avg?: UserAchievementAvgAggregateInputType
    _sum?: UserAchievementSumAggregateInputType
    _min?: UserAchievementMinAggregateInputType
    _max?: UserAchievementMaxAggregateInputType
  }

  export type UserAchievementGroupByOutputType = {
    id: string
    userId: string
    achievementId: string
    unlockedAt: Date
    progress: number
    _count: UserAchievementCountAggregateOutputType | null
    _avg: UserAchievementAvgAggregateOutputType | null
    _sum: UserAchievementSumAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  type GetUserAchievementGroupByPayload<T extends UserAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
        }
      >
    >


  export type UserAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    unlockedAt?: boolean
    progress?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    unlockedAt?: boolean
    progress?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    unlockedAt?: boolean
    progress?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>

  export type UserAchievementSelectScalar = {
    id?: boolean
    userId?: boolean
    achievementId?: boolean
    unlockedAt?: boolean
    progress?: boolean
  }

  export type UserAchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "achievementId" | "unlockedAt" | "progress", ExtArgs["result"]["userAchievement"]>
  export type UserAchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }
  export type UserAchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }
  export type UserAchievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    achievement?: boolean | AchievementDefaultArgs<ExtArgs>
  }

  export type $UserAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAchievement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      achievement: Prisma.$AchievementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      achievementId: string
      unlockedAt: Date
      progress: number
    }, ExtArgs["result"]["userAchievement"]>
    composites: {}
  }

  type UserAchievementGetPayload<S extends boolean | null | undefined | UserAchievementDefaultArgs> = $Result.GetResult<Prisma.$UserAchievementPayload, S>

  type UserAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserAchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserAchievementCountAggregateInputType | true
    }

  export interface UserAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAchievement'], meta: { name: 'UserAchievement' } }
    /**
     * Find zero or one UserAchievement that matches the filter.
     * @param {UserAchievementFindUniqueArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAchievementFindUniqueArgs>(args: SelectSubset<T, UserAchievementFindUniqueArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserAchievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserAchievementFindUniqueOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAchievementFindFirstArgs>(args?: SelectSubset<T, UserAchievementFindFirstArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany()
     * 
     * // Get first 10 UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAchievementFindManyArgs>(args?: SelectSubset<T, UserAchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserAchievement.
     * @param {UserAchievementCreateArgs} args - Arguments to create a UserAchievement.
     * @example
     * // Create one UserAchievement
     * const UserAchievement = await prisma.userAchievement.create({
     *   data: {
     *     // ... data to create a UserAchievement
     *   }
     * })
     * 
     */
    create<T extends UserAchievementCreateArgs>(args: SelectSubset<T, UserAchievementCreateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserAchievements.
     * @param {UserAchievementCreateManyArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAchievementCreateManyArgs>(args?: SelectSubset<T, UserAchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserAchievements and returns the data saved in the database.
     * @param {UserAchievementCreateManyAndReturnArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserAchievements and only return the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserAchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, UserAchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserAchievement.
     * @param {UserAchievementDeleteArgs} args - Arguments to delete one UserAchievement.
     * @example
     * // Delete one UserAchievement
     * const UserAchievement = await prisma.userAchievement.delete({
     *   where: {
     *     // ... filter to delete one UserAchievement
     *   }
     * })
     * 
     */
    delete<T extends UserAchievementDeleteArgs>(args: SelectSubset<T, UserAchievementDeleteArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserAchievement.
     * @param {UserAchievementUpdateArgs} args - Arguments to update one UserAchievement.
     * @example
     * // Update one UserAchievement
     * const userAchievement = await prisma.userAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAchievementUpdateArgs>(args: SelectSubset<T, UserAchievementUpdateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserAchievements.
     * @param {UserAchievementDeleteManyArgs} args - Arguments to filter UserAchievements to delete.
     * @example
     * // Delete a few UserAchievements
     * const { count } = await prisma.userAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAchievementDeleteManyArgs>(args?: SelectSubset<T, UserAchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAchievements
     * const userAchievement = await prisma.userAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAchievementUpdateManyArgs>(args: SelectSubset<T, UserAchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAchievements and returns the data updated in the database.
     * @param {UserAchievementUpdateManyAndReturnArgs} args - Arguments to update many UserAchievements.
     * @example
     * // Update many UserAchievements
     * const userAchievement = await prisma.userAchievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserAchievements and only return the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserAchievementUpdateManyAndReturnArgs>(args: SelectSubset<T, UserAchievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserAchievement.
     * @param {UserAchievementUpsertArgs} args - Arguments to update or create a UserAchievement.
     * @example
     * // Update or create a UserAchievement
     * const userAchievement = await prisma.userAchievement.upsert({
     *   create: {
     *     // ... data to create a UserAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAchievement we want to update
     *   }
     * })
     */
    upsert<T extends UserAchievementUpsertArgs>(args: SelectSubset<T, UserAchievementUpsertArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementCountArgs} args - Arguments to filter UserAchievements to count.
     * @example
     * // Count the number of UserAchievements
     * const count = await prisma.userAchievement.count({
     *   where: {
     *     // ... the filter for the UserAchievements we want to count
     *   }
     * })
    **/
    count<T extends UserAchievementCountArgs>(
      args?: Subset<T, UserAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAchievementAggregateArgs>(args: Subset<T, UserAchievementAggregateArgs>): Prisma.PrismaPromise<GetUserAchievementAggregateType<T>>

    /**
     * Group by UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAchievementGroupByArgs['orderBy'] }
        : { orderBy?: UserAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAchievement model
   */
  readonly fields: UserAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    achievement<T extends AchievementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AchievementDefaultArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAchievement model
   */
  interface UserAchievementFieldRefs {
    readonly id: FieldRef<"UserAchievement", 'String'>
    readonly userId: FieldRef<"UserAchievement", 'String'>
    readonly achievementId: FieldRef<"UserAchievement", 'String'>
    readonly unlockedAt: FieldRef<"UserAchievement", 'DateTime'>
    readonly progress: FieldRef<"UserAchievement", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserAchievement findUnique
   */
  export type UserAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findUniqueOrThrow
   */
  export type UserAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findFirst
   */
  export type UserAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findFirstOrThrow
   */
  export type UserAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findMany
   */
  export type UserAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievements to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement create
   */
  export type UserAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAchievement.
     */
    data: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
  }

  /**
   * UserAchievement createMany
   */
  export type UserAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAchievement createManyAndReturn
   */
  export type UserAchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAchievement update
   */
  export type UserAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAchievement.
     */
    data: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
    /**
     * Choose, which UserAchievement to update.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement updateMany
   */
  export type UserAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAchievements.
     */
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyInput>
    /**
     * Filter which UserAchievements to update
     */
    where?: UserAchievementWhereInput
    /**
     * Limit how many UserAchievements to update.
     */
    limit?: number
  }

  /**
   * UserAchievement updateManyAndReturn
   */
  export type UserAchievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * The data used to update UserAchievements.
     */
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyInput>
    /**
     * Filter which UserAchievements to update
     */
    where?: UserAchievementWhereInput
    /**
     * Limit how many UserAchievements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserAchievement upsert
   */
  export type UserAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAchievement to update in case it exists.
     */
    where: UserAchievementWhereUniqueInput
    /**
     * In case the UserAchievement found by the `where` argument doesn't exist, create a new UserAchievement with this data.
     */
    create: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
    /**
     * In case the UserAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
  }

  /**
   * UserAchievement delete
   */
  export type UserAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter which UserAchievement to delete.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement deleteMany
   */
  export type UserAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievements to delete
     */
    where?: UserAchievementWhereInput
    /**
     * Limit how many UserAchievements to delete.
     */
    limit?: number
  }

  /**
   * UserAchievement without action
   */
  export type UserAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserAchievement
     */
    omit?: UserAchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    read: boolean | null
    actionUrl: string | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    read: boolean | null
    actionUrl: string | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    message: number
    type: number
    read: number
    actionUrl: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    read?: true
    actionUrl?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    read?: true
    actionUrl?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    message?: true
    type?: true
    read?: true
    actionUrl?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    title: string
    message: string
    type: $Enums.NotificationType
    read: boolean
    actionUrl: string | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    read?: boolean
    actionUrl?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    read?: boolean
    actionUrl?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    read?: boolean
    actionUrl?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    read?: boolean
    actionUrl?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "message" | "type" | "read" | "actionUrl" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      message: string
      type: $Enums.NotificationType
      read: boolean
      actionUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly actionUrl: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model TwitterAnalytics
   */

  export type AggregateTwitterAnalytics = {
    _count: TwitterAnalyticsCountAggregateOutputType | null
    _avg: TwitterAnalyticsAvgAggregateOutputType | null
    _sum: TwitterAnalyticsSumAggregateOutputType | null
    _min: TwitterAnalyticsMinAggregateOutputType | null
    _max: TwitterAnalyticsMaxAggregateOutputType | null
  }

  export type TwitterAnalyticsAvgAggregateOutputType = {
    likes: number | null
    retweets: number | null
    comments: number | null
    impressions: number | null
    engagement_rate: number | null
  }

  export type TwitterAnalyticsSumAggregateOutputType = {
    likes: number | null
    retweets: number | null
    comments: number | null
    impressions: number | null
    engagement_rate: number | null
  }

  export type TwitterAnalyticsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tweetId: string | null
    likes: number | null
    retweets: number | null
    comments: number | null
    impressions: number | null
    engagement_rate: number | null
    calculatedAt: Date | null
  }

  export type TwitterAnalyticsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tweetId: string | null
    likes: number | null
    retweets: number | null
    comments: number | null
    impressions: number | null
    engagement_rate: number | null
    calculatedAt: Date | null
  }

  export type TwitterAnalyticsCountAggregateOutputType = {
    id: number
    userId: number
    tweetId: number
    likes: number
    retweets: number
    comments: number
    impressions: number
    engagement_rate: number
    calculatedAt: number
    _all: number
  }


  export type TwitterAnalyticsAvgAggregateInputType = {
    likes?: true
    retweets?: true
    comments?: true
    impressions?: true
    engagement_rate?: true
  }

  export type TwitterAnalyticsSumAggregateInputType = {
    likes?: true
    retweets?: true
    comments?: true
    impressions?: true
    engagement_rate?: true
  }

  export type TwitterAnalyticsMinAggregateInputType = {
    id?: true
    userId?: true
    tweetId?: true
    likes?: true
    retweets?: true
    comments?: true
    impressions?: true
    engagement_rate?: true
    calculatedAt?: true
  }

  export type TwitterAnalyticsMaxAggregateInputType = {
    id?: true
    userId?: true
    tweetId?: true
    likes?: true
    retweets?: true
    comments?: true
    impressions?: true
    engagement_rate?: true
    calculatedAt?: true
  }

  export type TwitterAnalyticsCountAggregateInputType = {
    id?: true
    userId?: true
    tweetId?: true
    likes?: true
    retweets?: true
    comments?: true
    impressions?: true
    engagement_rate?: true
    calculatedAt?: true
    _all?: true
  }

  export type TwitterAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwitterAnalytics to aggregate.
     */
    where?: TwitterAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterAnalytics to fetch.
     */
    orderBy?: TwitterAnalyticsOrderByWithRelationInput | TwitterAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwitterAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitterAnalytics
    **/
    _count?: true | TwitterAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwitterAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwitterAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwitterAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwitterAnalyticsMaxAggregateInputType
  }

  export type GetTwitterAnalyticsAggregateType<T extends TwitterAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateTwitterAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitterAnalytics[P]>
      : GetScalarType<T[P], AggregateTwitterAnalytics[P]>
  }




  export type TwitterAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwitterAnalyticsWhereInput
    orderBy?: TwitterAnalyticsOrderByWithAggregationInput | TwitterAnalyticsOrderByWithAggregationInput[]
    by: TwitterAnalyticsScalarFieldEnum[] | TwitterAnalyticsScalarFieldEnum
    having?: TwitterAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwitterAnalyticsCountAggregateInputType | true
    _avg?: TwitterAnalyticsAvgAggregateInputType
    _sum?: TwitterAnalyticsSumAggregateInputType
    _min?: TwitterAnalyticsMinAggregateInputType
    _max?: TwitterAnalyticsMaxAggregateInputType
  }

  export type TwitterAnalyticsGroupByOutputType = {
    id: string
    userId: string | null
    tweetId: string
    likes: number
    retweets: number
    comments: number
    impressions: number
    engagement_rate: number
    calculatedAt: Date
    _count: TwitterAnalyticsCountAggregateOutputType | null
    _avg: TwitterAnalyticsAvgAggregateOutputType | null
    _sum: TwitterAnalyticsSumAggregateOutputType | null
    _min: TwitterAnalyticsMinAggregateOutputType | null
    _max: TwitterAnalyticsMaxAggregateOutputType | null
  }

  type GetTwitterAnalyticsGroupByPayload<T extends TwitterAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TwitterAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwitterAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwitterAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], TwitterAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type TwitterAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tweetId?: boolean
    likes?: boolean
    retweets?: boolean
    comments?: boolean
    impressions?: boolean
    engagement_rate?: boolean
    calculatedAt?: boolean
  }, ExtArgs["result"]["twitterAnalytics"]>

  export type TwitterAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tweetId?: boolean
    likes?: boolean
    retweets?: boolean
    comments?: boolean
    impressions?: boolean
    engagement_rate?: boolean
    calculatedAt?: boolean
  }, ExtArgs["result"]["twitterAnalytics"]>

  export type TwitterAnalyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tweetId?: boolean
    likes?: boolean
    retweets?: boolean
    comments?: boolean
    impressions?: boolean
    engagement_rate?: boolean
    calculatedAt?: boolean
  }, ExtArgs["result"]["twitterAnalytics"]>

  export type TwitterAnalyticsSelectScalar = {
    id?: boolean
    userId?: boolean
    tweetId?: boolean
    likes?: boolean
    retweets?: boolean
    comments?: boolean
    impressions?: boolean
    engagement_rate?: boolean
    calculatedAt?: boolean
  }

  export type TwitterAnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "tweetId" | "likes" | "retweets" | "comments" | "impressions" | "engagement_rate" | "calculatedAt", ExtArgs["result"]["twitterAnalytics"]>

  export type $TwitterAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TwitterAnalytics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      tweetId: string
      likes: number
      retweets: number
      comments: number
      impressions: number
      engagement_rate: number
      calculatedAt: Date
    }, ExtArgs["result"]["twitterAnalytics"]>
    composites: {}
  }

  type TwitterAnalyticsGetPayload<S extends boolean | null | undefined | TwitterAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$TwitterAnalyticsPayload, S>

  type TwitterAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TwitterAnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TwitterAnalyticsCountAggregateInputType | true
    }

  export interface TwitterAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TwitterAnalytics'], meta: { name: 'TwitterAnalytics' } }
    /**
     * Find zero or one TwitterAnalytics that matches the filter.
     * @param {TwitterAnalyticsFindUniqueArgs} args - Arguments to find a TwitterAnalytics
     * @example
     * // Get one TwitterAnalytics
     * const twitterAnalytics = await prisma.twitterAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TwitterAnalyticsFindUniqueArgs>(args: SelectSubset<T, TwitterAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__TwitterAnalyticsClient<$Result.GetResult<Prisma.$TwitterAnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TwitterAnalytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TwitterAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a TwitterAnalytics
     * @example
     * // Get one TwitterAnalytics
     * const twitterAnalytics = await prisma.twitterAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TwitterAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, TwitterAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TwitterAnalyticsClient<$Result.GetResult<Prisma.$TwitterAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TwitterAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterAnalyticsFindFirstArgs} args - Arguments to find a TwitterAnalytics
     * @example
     * // Get one TwitterAnalytics
     * const twitterAnalytics = await prisma.twitterAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TwitterAnalyticsFindFirstArgs>(args?: SelectSubset<T, TwitterAnalyticsFindFirstArgs<ExtArgs>>): Prisma__TwitterAnalyticsClient<$Result.GetResult<Prisma.$TwitterAnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TwitterAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterAnalyticsFindFirstOrThrowArgs} args - Arguments to find a TwitterAnalytics
     * @example
     * // Get one TwitterAnalytics
     * const twitterAnalytics = await prisma.twitterAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TwitterAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, TwitterAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TwitterAnalyticsClient<$Result.GetResult<Prisma.$TwitterAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TwitterAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitterAnalytics
     * const twitterAnalytics = await prisma.twitterAnalytics.findMany()
     * 
     * // Get first 10 TwitterAnalytics
     * const twitterAnalytics = await prisma.twitterAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitterAnalyticsWithIdOnly = await prisma.twitterAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TwitterAnalyticsFindManyArgs>(args?: SelectSubset<T, TwitterAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwitterAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TwitterAnalytics.
     * @param {TwitterAnalyticsCreateArgs} args - Arguments to create a TwitterAnalytics.
     * @example
     * // Create one TwitterAnalytics
     * const TwitterAnalytics = await prisma.twitterAnalytics.create({
     *   data: {
     *     // ... data to create a TwitterAnalytics
     *   }
     * })
     * 
     */
    create<T extends TwitterAnalyticsCreateArgs>(args: SelectSubset<T, TwitterAnalyticsCreateArgs<ExtArgs>>): Prisma__TwitterAnalyticsClient<$Result.GetResult<Prisma.$TwitterAnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TwitterAnalytics.
     * @param {TwitterAnalyticsCreateManyArgs} args - Arguments to create many TwitterAnalytics.
     * @example
     * // Create many TwitterAnalytics
     * const twitterAnalytics = await prisma.twitterAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TwitterAnalyticsCreateManyArgs>(args?: SelectSubset<T, TwitterAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TwitterAnalytics and returns the data saved in the database.
     * @param {TwitterAnalyticsCreateManyAndReturnArgs} args - Arguments to create many TwitterAnalytics.
     * @example
     * // Create many TwitterAnalytics
     * const twitterAnalytics = await prisma.twitterAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TwitterAnalytics and only return the `id`
     * const twitterAnalyticsWithIdOnly = await prisma.twitterAnalytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TwitterAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, TwitterAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwitterAnalyticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TwitterAnalytics.
     * @param {TwitterAnalyticsDeleteArgs} args - Arguments to delete one TwitterAnalytics.
     * @example
     * // Delete one TwitterAnalytics
     * const TwitterAnalytics = await prisma.twitterAnalytics.delete({
     *   where: {
     *     // ... filter to delete one TwitterAnalytics
     *   }
     * })
     * 
     */
    delete<T extends TwitterAnalyticsDeleteArgs>(args: SelectSubset<T, TwitterAnalyticsDeleteArgs<ExtArgs>>): Prisma__TwitterAnalyticsClient<$Result.GetResult<Prisma.$TwitterAnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TwitterAnalytics.
     * @param {TwitterAnalyticsUpdateArgs} args - Arguments to update one TwitterAnalytics.
     * @example
     * // Update one TwitterAnalytics
     * const twitterAnalytics = await prisma.twitterAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TwitterAnalyticsUpdateArgs>(args: SelectSubset<T, TwitterAnalyticsUpdateArgs<ExtArgs>>): Prisma__TwitterAnalyticsClient<$Result.GetResult<Prisma.$TwitterAnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TwitterAnalytics.
     * @param {TwitterAnalyticsDeleteManyArgs} args - Arguments to filter TwitterAnalytics to delete.
     * @example
     * // Delete a few TwitterAnalytics
     * const { count } = await prisma.twitterAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TwitterAnalyticsDeleteManyArgs>(args?: SelectSubset<T, TwitterAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitterAnalytics
     * const twitterAnalytics = await prisma.twitterAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TwitterAnalyticsUpdateManyArgs>(args: SelectSubset<T, TwitterAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterAnalytics and returns the data updated in the database.
     * @param {TwitterAnalyticsUpdateManyAndReturnArgs} args - Arguments to update many TwitterAnalytics.
     * @example
     * // Update many TwitterAnalytics
     * const twitterAnalytics = await prisma.twitterAnalytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TwitterAnalytics and only return the `id`
     * const twitterAnalyticsWithIdOnly = await prisma.twitterAnalytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TwitterAnalyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, TwitterAnalyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwitterAnalyticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TwitterAnalytics.
     * @param {TwitterAnalyticsUpsertArgs} args - Arguments to update or create a TwitterAnalytics.
     * @example
     * // Update or create a TwitterAnalytics
     * const twitterAnalytics = await prisma.twitterAnalytics.upsert({
     *   create: {
     *     // ... data to create a TwitterAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitterAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends TwitterAnalyticsUpsertArgs>(args: SelectSubset<T, TwitterAnalyticsUpsertArgs<ExtArgs>>): Prisma__TwitterAnalyticsClient<$Result.GetResult<Prisma.$TwitterAnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TwitterAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterAnalyticsCountArgs} args - Arguments to filter TwitterAnalytics to count.
     * @example
     * // Count the number of TwitterAnalytics
     * const count = await prisma.twitterAnalytics.count({
     *   where: {
     *     // ... the filter for the TwitterAnalytics we want to count
     *   }
     * })
    **/
    count<T extends TwitterAnalyticsCountArgs>(
      args?: Subset<T, TwitterAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitterAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitterAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitterAnalyticsAggregateArgs>(args: Subset<T, TwitterAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetTwitterAnalyticsAggregateType<T>>

    /**
     * Group by TwitterAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwitterAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwitterAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: TwitterAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwitterAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwitterAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TwitterAnalytics model
   */
  readonly fields: TwitterAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitterAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TwitterAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TwitterAnalytics model
   */
  interface TwitterAnalyticsFieldRefs {
    readonly id: FieldRef<"TwitterAnalytics", 'String'>
    readonly userId: FieldRef<"TwitterAnalytics", 'String'>
    readonly tweetId: FieldRef<"TwitterAnalytics", 'String'>
    readonly likes: FieldRef<"TwitterAnalytics", 'Int'>
    readonly retweets: FieldRef<"TwitterAnalytics", 'Int'>
    readonly comments: FieldRef<"TwitterAnalytics", 'Int'>
    readonly impressions: FieldRef<"TwitterAnalytics", 'Int'>
    readonly engagement_rate: FieldRef<"TwitterAnalytics", 'Float'>
    readonly calculatedAt: FieldRef<"TwitterAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TwitterAnalytics findUnique
   */
  export type TwitterAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterAnalytics
     */
    select?: TwitterAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterAnalytics
     */
    omit?: TwitterAnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which TwitterAnalytics to fetch.
     */
    where: TwitterAnalyticsWhereUniqueInput
  }

  /**
   * TwitterAnalytics findUniqueOrThrow
   */
  export type TwitterAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterAnalytics
     */
    select?: TwitterAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterAnalytics
     */
    omit?: TwitterAnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which TwitterAnalytics to fetch.
     */
    where: TwitterAnalyticsWhereUniqueInput
  }

  /**
   * TwitterAnalytics findFirst
   */
  export type TwitterAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterAnalytics
     */
    select?: TwitterAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterAnalytics
     */
    omit?: TwitterAnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which TwitterAnalytics to fetch.
     */
    where?: TwitterAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterAnalytics to fetch.
     */
    orderBy?: TwitterAnalyticsOrderByWithRelationInput | TwitterAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterAnalytics.
     */
    cursor?: TwitterAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterAnalytics.
     */
    distinct?: TwitterAnalyticsScalarFieldEnum | TwitterAnalyticsScalarFieldEnum[]
  }

  /**
   * TwitterAnalytics findFirstOrThrow
   */
  export type TwitterAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterAnalytics
     */
    select?: TwitterAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterAnalytics
     */
    omit?: TwitterAnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which TwitterAnalytics to fetch.
     */
    where?: TwitterAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterAnalytics to fetch.
     */
    orderBy?: TwitterAnalyticsOrderByWithRelationInput | TwitterAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterAnalytics.
     */
    cursor?: TwitterAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterAnalytics.
     */
    distinct?: TwitterAnalyticsScalarFieldEnum | TwitterAnalyticsScalarFieldEnum[]
  }

  /**
   * TwitterAnalytics findMany
   */
  export type TwitterAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterAnalytics
     */
    select?: TwitterAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterAnalytics
     */
    omit?: TwitterAnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which TwitterAnalytics to fetch.
     */
    where?: TwitterAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterAnalytics to fetch.
     */
    orderBy?: TwitterAnalyticsOrderByWithRelationInput | TwitterAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitterAnalytics.
     */
    cursor?: TwitterAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterAnalytics.
     */
    skip?: number
    distinct?: TwitterAnalyticsScalarFieldEnum | TwitterAnalyticsScalarFieldEnum[]
  }

  /**
   * TwitterAnalytics create
   */
  export type TwitterAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterAnalytics
     */
    select?: TwitterAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterAnalytics
     */
    omit?: TwitterAnalyticsOmit<ExtArgs> | null
    /**
     * The data needed to create a TwitterAnalytics.
     */
    data: XOR<TwitterAnalyticsCreateInput, TwitterAnalyticsUncheckedCreateInput>
  }

  /**
   * TwitterAnalytics createMany
   */
  export type TwitterAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TwitterAnalytics.
     */
    data: TwitterAnalyticsCreateManyInput | TwitterAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TwitterAnalytics createManyAndReturn
   */
  export type TwitterAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterAnalytics
     */
    select?: TwitterAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterAnalytics
     */
    omit?: TwitterAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to create many TwitterAnalytics.
     */
    data: TwitterAnalyticsCreateManyInput | TwitterAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TwitterAnalytics update
   */
  export type TwitterAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterAnalytics
     */
    select?: TwitterAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterAnalytics
     */
    omit?: TwitterAnalyticsOmit<ExtArgs> | null
    /**
     * The data needed to update a TwitterAnalytics.
     */
    data: XOR<TwitterAnalyticsUpdateInput, TwitterAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which TwitterAnalytics to update.
     */
    where: TwitterAnalyticsWhereUniqueInput
  }

  /**
   * TwitterAnalytics updateMany
   */
  export type TwitterAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TwitterAnalytics.
     */
    data: XOR<TwitterAnalyticsUpdateManyMutationInput, TwitterAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which TwitterAnalytics to update
     */
    where?: TwitterAnalyticsWhereInput
    /**
     * Limit how many TwitterAnalytics to update.
     */
    limit?: number
  }

  /**
   * TwitterAnalytics updateManyAndReturn
   */
  export type TwitterAnalyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterAnalytics
     */
    select?: TwitterAnalyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterAnalytics
     */
    omit?: TwitterAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to update TwitterAnalytics.
     */
    data: XOR<TwitterAnalyticsUpdateManyMutationInput, TwitterAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which TwitterAnalytics to update
     */
    where?: TwitterAnalyticsWhereInput
    /**
     * Limit how many TwitterAnalytics to update.
     */
    limit?: number
  }

  /**
   * TwitterAnalytics upsert
   */
  export type TwitterAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterAnalytics
     */
    select?: TwitterAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterAnalytics
     */
    omit?: TwitterAnalyticsOmit<ExtArgs> | null
    /**
     * The filter to search for the TwitterAnalytics to update in case it exists.
     */
    where: TwitterAnalyticsWhereUniqueInput
    /**
     * In case the TwitterAnalytics found by the `where` argument doesn't exist, create a new TwitterAnalytics with this data.
     */
    create: XOR<TwitterAnalyticsCreateInput, TwitterAnalyticsUncheckedCreateInput>
    /**
     * In case the TwitterAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwitterAnalyticsUpdateInput, TwitterAnalyticsUncheckedUpdateInput>
  }

  /**
   * TwitterAnalytics delete
   */
  export type TwitterAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterAnalytics
     */
    select?: TwitterAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterAnalytics
     */
    omit?: TwitterAnalyticsOmit<ExtArgs> | null
    /**
     * Filter which TwitterAnalytics to delete.
     */
    where: TwitterAnalyticsWhereUniqueInput
  }

  /**
   * TwitterAnalytics deleteMany
   */
  export type TwitterAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwitterAnalytics to delete
     */
    where?: TwitterAnalyticsWhereInput
    /**
     * Limit how many TwitterAnalytics to delete.
     */
    limit?: number
  }

  /**
   * TwitterAnalytics without action
   */
  export type TwitterAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterAnalytics
     */
    select?: TwitterAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterAnalytics
     */
    omit?: TwitterAnalyticsOmit<ExtArgs> | null
  }


  /**
   * Model TwitterEngagement
   */

  export type AggregateTwitterEngagement = {
    _count: TwitterEngagementCountAggregateOutputType | null
    _avg: TwitterEngagementAvgAggregateOutputType | null
    _sum: TwitterEngagementSumAggregateOutputType | null
    _min: TwitterEngagementMinAggregateOutputType | null
    _max: TwitterEngagementMaxAggregateOutputType | null
  }

  export type TwitterEngagementAvgAggregateOutputType = {
    points: number | null
  }

  export type TwitterEngagementSumAggregateOutputType = {
    points: number | null
  }

  export type TwitterEngagementMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tweetId: string | null
    engagementType: $Enums.EngagementType | null
    points: number | null
    verified: boolean | null
    createdAt: Date | null
  }

  export type TwitterEngagementMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tweetId: string | null
    engagementType: $Enums.EngagementType | null
    points: number | null
    verified: boolean | null
    createdAt: Date | null
  }

  export type TwitterEngagementCountAggregateOutputType = {
    id: number
    userId: number
    tweetId: number
    engagementType: number
    points: number
    verified: number
    createdAt: number
    _all: number
  }


  export type TwitterEngagementAvgAggregateInputType = {
    points?: true
  }

  export type TwitterEngagementSumAggregateInputType = {
    points?: true
  }

  export type TwitterEngagementMinAggregateInputType = {
    id?: true
    userId?: true
    tweetId?: true
    engagementType?: true
    points?: true
    verified?: true
    createdAt?: true
  }

  export type TwitterEngagementMaxAggregateInputType = {
    id?: true
    userId?: true
    tweetId?: true
    engagementType?: true
    points?: true
    verified?: true
    createdAt?: true
  }

  export type TwitterEngagementCountAggregateInputType = {
    id?: true
    userId?: true
    tweetId?: true
    engagementType?: true
    points?: true
    verified?: true
    createdAt?: true
    _all?: true
  }

  export type TwitterEngagementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwitterEngagement to aggregate.
     */
    where?: TwitterEngagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterEngagements to fetch.
     */
    orderBy?: TwitterEngagementOrderByWithRelationInput | TwitterEngagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TwitterEngagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterEngagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterEngagements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TwitterEngagements
    **/
    _count?: true | TwitterEngagementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TwitterEngagementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TwitterEngagementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TwitterEngagementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TwitterEngagementMaxAggregateInputType
  }

  export type GetTwitterEngagementAggregateType<T extends TwitterEngagementAggregateArgs> = {
        [P in keyof T & keyof AggregateTwitterEngagement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTwitterEngagement[P]>
      : GetScalarType<T[P], AggregateTwitterEngagement[P]>
  }




  export type TwitterEngagementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TwitterEngagementWhereInput
    orderBy?: TwitterEngagementOrderByWithAggregationInput | TwitterEngagementOrderByWithAggregationInput[]
    by: TwitterEngagementScalarFieldEnum[] | TwitterEngagementScalarFieldEnum
    having?: TwitterEngagementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TwitterEngagementCountAggregateInputType | true
    _avg?: TwitterEngagementAvgAggregateInputType
    _sum?: TwitterEngagementSumAggregateInputType
    _min?: TwitterEngagementMinAggregateInputType
    _max?: TwitterEngagementMaxAggregateInputType
  }

  export type TwitterEngagementGroupByOutputType = {
    id: string
    userId: string
    tweetId: string
    engagementType: $Enums.EngagementType
    points: number
    verified: boolean
    createdAt: Date
    _count: TwitterEngagementCountAggregateOutputType | null
    _avg: TwitterEngagementAvgAggregateOutputType | null
    _sum: TwitterEngagementSumAggregateOutputType | null
    _min: TwitterEngagementMinAggregateOutputType | null
    _max: TwitterEngagementMaxAggregateOutputType | null
  }

  type GetTwitterEngagementGroupByPayload<T extends TwitterEngagementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TwitterEngagementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TwitterEngagementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TwitterEngagementGroupByOutputType[P]>
            : GetScalarType<T[P], TwitterEngagementGroupByOutputType[P]>
        }
      >
    >


  export type TwitterEngagementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tweetId?: boolean
    engagementType?: boolean
    points?: boolean
    verified?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["twitterEngagement"]>

  export type TwitterEngagementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tweetId?: boolean
    engagementType?: boolean
    points?: boolean
    verified?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["twitterEngagement"]>

  export type TwitterEngagementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tweetId?: boolean
    engagementType?: boolean
    points?: boolean
    verified?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["twitterEngagement"]>

  export type TwitterEngagementSelectScalar = {
    id?: boolean
    userId?: boolean
    tweetId?: boolean
    engagementType?: boolean
    points?: boolean
    verified?: boolean
    createdAt?: boolean
  }

  export type TwitterEngagementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "tweetId" | "engagementType" | "points" | "verified" | "createdAt", ExtArgs["result"]["twitterEngagement"]>
  export type TwitterEngagementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TwitterEngagementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TwitterEngagementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TwitterEngagementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TwitterEngagement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tweetId: string
      engagementType: $Enums.EngagementType
      points: number
      verified: boolean
      createdAt: Date
    }, ExtArgs["result"]["twitterEngagement"]>
    composites: {}
  }

  type TwitterEngagementGetPayload<S extends boolean | null | undefined | TwitterEngagementDefaultArgs> = $Result.GetResult<Prisma.$TwitterEngagementPayload, S>

  type TwitterEngagementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TwitterEngagementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TwitterEngagementCountAggregateInputType | true
    }

  export interface TwitterEngagementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TwitterEngagement'], meta: { name: 'TwitterEngagement' } }
    /**
     * Find zero or one TwitterEngagement that matches the filter.
     * @param {TwitterEngagementFindUniqueArgs} args - Arguments to find a TwitterEngagement
     * @example
     * // Get one TwitterEngagement
     * const twitterEngagement = await prisma.twitterEngagement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TwitterEngagementFindUniqueArgs>(args: SelectSubset<T, TwitterEngagementFindUniqueArgs<ExtArgs>>): Prisma__TwitterEngagementClient<$Result.GetResult<Prisma.$TwitterEngagementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TwitterEngagement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TwitterEngagementFindUniqueOrThrowArgs} args - Arguments to find a TwitterEngagement
     * @example
     * // Get one TwitterEngagement
     * const twitterEngagement = await prisma.twitterEngagement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TwitterEngagementFindUniqueOrThrowArgs>(args: SelectSubset<T, TwitterEngagementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TwitterEngagementClient<$Result.GetResult<Prisma.$TwitterEngagementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TwitterEngagement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterEngagementFindFirstArgs} args - Arguments to find a TwitterEngagement
     * @example
     * // Get one TwitterEngagement
     * const twitterEngagement = await prisma.twitterEngagement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TwitterEngagementFindFirstArgs>(args?: SelectSubset<T, TwitterEngagementFindFirstArgs<ExtArgs>>): Prisma__TwitterEngagementClient<$Result.GetResult<Prisma.$TwitterEngagementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TwitterEngagement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterEngagementFindFirstOrThrowArgs} args - Arguments to find a TwitterEngagement
     * @example
     * // Get one TwitterEngagement
     * const twitterEngagement = await prisma.twitterEngagement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TwitterEngagementFindFirstOrThrowArgs>(args?: SelectSubset<T, TwitterEngagementFindFirstOrThrowArgs<ExtArgs>>): Prisma__TwitterEngagementClient<$Result.GetResult<Prisma.$TwitterEngagementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TwitterEngagements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterEngagementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TwitterEngagements
     * const twitterEngagements = await prisma.twitterEngagement.findMany()
     * 
     * // Get first 10 TwitterEngagements
     * const twitterEngagements = await prisma.twitterEngagement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const twitterEngagementWithIdOnly = await prisma.twitterEngagement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TwitterEngagementFindManyArgs>(args?: SelectSubset<T, TwitterEngagementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwitterEngagementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TwitterEngagement.
     * @param {TwitterEngagementCreateArgs} args - Arguments to create a TwitterEngagement.
     * @example
     * // Create one TwitterEngagement
     * const TwitterEngagement = await prisma.twitterEngagement.create({
     *   data: {
     *     // ... data to create a TwitterEngagement
     *   }
     * })
     * 
     */
    create<T extends TwitterEngagementCreateArgs>(args: SelectSubset<T, TwitterEngagementCreateArgs<ExtArgs>>): Prisma__TwitterEngagementClient<$Result.GetResult<Prisma.$TwitterEngagementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TwitterEngagements.
     * @param {TwitterEngagementCreateManyArgs} args - Arguments to create many TwitterEngagements.
     * @example
     * // Create many TwitterEngagements
     * const twitterEngagement = await prisma.twitterEngagement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TwitterEngagementCreateManyArgs>(args?: SelectSubset<T, TwitterEngagementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TwitterEngagements and returns the data saved in the database.
     * @param {TwitterEngagementCreateManyAndReturnArgs} args - Arguments to create many TwitterEngagements.
     * @example
     * // Create many TwitterEngagements
     * const twitterEngagement = await prisma.twitterEngagement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TwitterEngagements and only return the `id`
     * const twitterEngagementWithIdOnly = await prisma.twitterEngagement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TwitterEngagementCreateManyAndReturnArgs>(args?: SelectSubset<T, TwitterEngagementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwitterEngagementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TwitterEngagement.
     * @param {TwitterEngagementDeleteArgs} args - Arguments to delete one TwitterEngagement.
     * @example
     * // Delete one TwitterEngagement
     * const TwitterEngagement = await prisma.twitterEngagement.delete({
     *   where: {
     *     // ... filter to delete one TwitterEngagement
     *   }
     * })
     * 
     */
    delete<T extends TwitterEngagementDeleteArgs>(args: SelectSubset<T, TwitterEngagementDeleteArgs<ExtArgs>>): Prisma__TwitterEngagementClient<$Result.GetResult<Prisma.$TwitterEngagementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TwitterEngagement.
     * @param {TwitterEngagementUpdateArgs} args - Arguments to update one TwitterEngagement.
     * @example
     * // Update one TwitterEngagement
     * const twitterEngagement = await prisma.twitterEngagement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TwitterEngagementUpdateArgs>(args: SelectSubset<T, TwitterEngagementUpdateArgs<ExtArgs>>): Prisma__TwitterEngagementClient<$Result.GetResult<Prisma.$TwitterEngagementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TwitterEngagements.
     * @param {TwitterEngagementDeleteManyArgs} args - Arguments to filter TwitterEngagements to delete.
     * @example
     * // Delete a few TwitterEngagements
     * const { count } = await prisma.twitterEngagement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TwitterEngagementDeleteManyArgs>(args?: SelectSubset<T, TwitterEngagementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterEngagements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterEngagementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TwitterEngagements
     * const twitterEngagement = await prisma.twitterEngagement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TwitterEngagementUpdateManyArgs>(args: SelectSubset<T, TwitterEngagementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TwitterEngagements and returns the data updated in the database.
     * @param {TwitterEngagementUpdateManyAndReturnArgs} args - Arguments to update many TwitterEngagements.
     * @example
     * // Update many TwitterEngagements
     * const twitterEngagement = await prisma.twitterEngagement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TwitterEngagements and only return the `id`
     * const twitterEngagementWithIdOnly = await prisma.twitterEngagement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TwitterEngagementUpdateManyAndReturnArgs>(args: SelectSubset<T, TwitterEngagementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TwitterEngagementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TwitterEngagement.
     * @param {TwitterEngagementUpsertArgs} args - Arguments to update or create a TwitterEngagement.
     * @example
     * // Update or create a TwitterEngagement
     * const twitterEngagement = await prisma.twitterEngagement.upsert({
     *   create: {
     *     // ... data to create a TwitterEngagement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TwitterEngagement we want to update
     *   }
     * })
     */
    upsert<T extends TwitterEngagementUpsertArgs>(args: SelectSubset<T, TwitterEngagementUpsertArgs<ExtArgs>>): Prisma__TwitterEngagementClient<$Result.GetResult<Prisma.$TwitterEngagementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TwitterEngagements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterEngagementCountArgs} args - Arguments to filter TwitterEngagements to count.
     * @example
     * // Count the number of TwitterEngagements
     * const count = await prisma.twitterEngagement.count({
     *   where: {
     *     // ... the filter for the TwitterEngagements we want to count
     *   }
     * })
    **/
    count<T extends TwitterEngagementCountArgs>(
      args?: Subset<T, TwitterEngagementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TwitterEngagementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TwitterEngagement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterEngagementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TwitterEngagementAggregateArgs>(args: Subset<T, TwitterEngagementAggregateArgs>): Prisma.PrismaPromise<GetTwitterEngagementAggregateType<T>>

    /**
     * Group by TwitterEngagement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TwitterEngagementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TwitterEngagementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TwitterEngagementGroupByArgs['orderBy'] }
        : { orderBy?: TwitterEngagementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TwitterEngagementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTwitterEngagementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TwitterEngagement model
   */
  readonly fields: TwitterEngagementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TwitterEngagement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TwitterEngagementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TwitterEngagement model
   */
  interface TwitterEngagementFieldRefs {
    readonly id: FieldRef<"TwitterEngagement", 'String'>
    readonly userId: FieldRef<"TwitterEngagement", 'String'>
    readonly tweetId: FieldRef<"TwitterEngagement", 'String'>
    readonly engagementType: FieldRef<"TwitterEngagement", 'EngagementType'>
    readonly points: FieldRef<"TwitterEngagement", 'Int'>
    readonly verified: FieldRef<"TwitterEngagement", 'Boolean'>
    readonly createdAt: FieldRef<"TwitterEngagement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TwitterEngagement findUnique
   */
  export type TwitterEngagementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterEngagement
     */
    select?: TwitterEngagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterEngagement
     */
    omit?: TwitterEngagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwitterEngagementInclude<ExtArgs> | null
    /**
     * Filter, which TwitterEngagement to fetch.
     */
    where: TwitterEngagementWhereUniqueInput
  }

  /**
   * TwitterEngagement findUniqueOrThrow
   */
  export type TwitterEngagementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterEngagement
     */
    select?: TwitterEngagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterEngagement
     */
    omit?: TwitterEngagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwitterEngagementInclude<ExtArgs> | null
    /**
     * Filter, which TwitterEngagement to fetch.
     */
    where: TwitterEngagementWhereUniqueInput
  }

  /**
   * TwitterEngagement findFirst
   */
  export type TwitterEngagementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterEngagement
     */
    select?: TwitterEngagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterEngagement
     */
    omit?: TwitterEngagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwitterEngagementInclude<ExtArgs> | null
    /**
     * Filter, which TwitterEngagement to fetch.
     */
    where?: TwitterEngagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterEngagements to fetch.
     */
    orderBy?: TwitterEngagementOrderByWithRelationInput | TwitterEngagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterEngagements.
     */
    cursor?: TwitterEngagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterEngagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterEngagements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterEngagements.
     */
    distinct?: TwitterEngagementScalarFieldEnum | TwitterEngagementScalarFieldEnum[]
  }

  /**
   * TwitterEngagement findFirstOrThrow
   */
  export type TwitterEngagementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterEngagement
     */
    select?: TwitterEngagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterEngagement
     */
    omit?: TwitterEngagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwitterEngagementInclude<ExtArgs> | null
    /**
     * Filter, which TwitterEngagement to fetch.
     */
    where?: TwitterEngagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterEngagements to fetch.
     */
    orderBy?: TwitterEngagementOrderByWithRelationInput | TwitterEngagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TwitterEngagements.
     */
    cursor?: TwitterEngagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterEngagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterEngagements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TwitterEngagements.
     */
    distinct?: TwitterEngagementScalarFieldEnum | TwitterEngagementScalarFieldEnum[]
  }

  /**
   * TwitterEngagement findMany
   */
  export type TwitterEngagementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterEngagement
     */
    select?: TwitterEngagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterEngagement
     */
    omit?: TwitterEngagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwitterEngagementInclude<ExtArgs> | null
    /**
     * Filter, which TwitterEngagements to fetch.
     */
    where?: TwitterEngagementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TwitterEngagements to fetch.
     */
    orderBy?: TwitterEngagementOrderByWithRelationInput | TwitterEngagementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TwitterEngagements.
     */
    cursor?: TwitterEngagementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TwitterEngagements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TwitterEngagements.
     */
    skip?: number
    distinct?: TwitterEngagementScalarFieldEnum | TwitterEngagementScalarFieldEnum[]
  }

  /**
   * TwitterEngagement create
   */
  export type TwitterEngagementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterEngagement
     */
    select?: TwitterEngagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterEngagement
     */
    omit?: TwitterEngagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwitterEngagementInclude<ExtArgs> | null
    /**
     * The data needed to create a TwitterEngagement.
     */
    data: XOR<TwitterEngagementCreateInput, TwitterEngagementUncheckedCreateInput>
  }

  /**
   * TwitterEngagement createMany
   */
  export type TwitterEngagementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TwitterEngagements.
     */
    data: TwitterEngagementCreateManyInput | TwitterEngagementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TwitterEngagement createManyAndReturn
   */
  export type TwitterEngagementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterEngagement
     */
    select?: TwitterEngagementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterEngagement
     */
    omit?: TwitterEngagementOmit<ExtArgs> | null
    /**
     * The data used to create many TwitterEngagements.
     */
    data: TwitterEngagementCreateManyInput | TwitterEngagementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwitterEngagementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TwitterEngagement update
   */
  export type TwitterEngagementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterEngagement
     */
    select?: TwitterEngagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterEngagement
     */
    omit?: TwitterEngagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwitterEngagementInclude<ExtArgs> | null
    /**
     * The data needed to update a TwitterEngagement.
     */
    data: XOR<TwitterEngagementUpdateInput, TwitterEngagementUncheckedUpdateInput>
    /**
     * Choose, which TwitterEngagement to update.
     */
    where: TwitterEngagementWhereUniqueInput
  }

  /**
   * TwitterEngagement updateMany
   */
  export type TwitterEngagementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TwitterEngagements.
     */
    data: XOR<TwitterEngagementUpdateManyMutationInput, TwitterEngagementUncheckedUpdateManyInput>
    /**
     * Filter which TwitterEngagements to update
     */
    where?: TwitterEngagementWhereInput
    /**
     * Limit how many TwitterEngagements to update.
     */
    limit?: number
  }

  /**
   * TwitterEngagement updateManyAndReturn
   */
  export type TwitterEngagementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterEngagement
     */
    select?: TwitterEngagementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterEngagement
     */
    omit?: TwitterEngagementOmit<ExtArgs> | null
    /**
     * The data used to update TwitterEngagements.
     */
    data: XOR<TwitterEngagementUpdateManyMutationInput, TwitterEngagementUncheckedUpdateManyInput>
    /**
     * Filter which TwitterEngagements to update
     */
    where?: TwitterEngagementWhereInput
    /**
     * Limit how many TwitterEngagements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwitterEngagementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TwitterEngagement upsert
   */
  export type TwitterEngagementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterEngagement
     */
    select?: TwitterEngagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterEngagement
     */
    omit?: TwitterEngagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwitterEngagementInclude<ExtArgs> | null
    /**
     * The filter to search for the TwitterEngagement to update in case it exists.
     */
    where: TwitterEngagementWhereUniqueInput
    /**
     * In case the TwitterEngagement found by the `where` argument doesn't exist, create a new TwitterEngagement with this data.
     */
    create: XOR<TwitterEngagementCreateInput, TwitterEngagementUncheckedCreateInput>
    /**
     * In case the TwitterEngagement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TwitterEngagementUpdateInput, TwitterEngagementUncheckedUpdateInput>
  }

  /**
   * TwitterEngagement delete
   */
  export type TwitterEngagementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterEngagement
     */
    select?: TwitterEngagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterEngagement
     */
    omit?: TwitterEngagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwitterEngagementInclude<ExtArgs> | null
    /**
     * Filter which TwitterEngagement to delete.
     */
    where: TwitterEngagementWhereUniqueInput
  }

  /**
   * TwitterEngagement deleteMany
   */
  export type TwitterEngagementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TwitterEngagements to delete
     */
    where?: TwitterEngagementWhereInput
    /**
     * Limit how many TwitterEngagements to delete.
     */
    limit?: number
  }

  /**
   * TwitterEngagement without action
   */
  export type TwitterEngagementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TwitterEngagement
     */
    select?: TwitterEngagementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TwitterEngagement
     */
    omit?: TwitterEngagementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TwitterEngagementInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    points: number | null
  }

  export type TaskSumAggregateOutputType = {
    points: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.TaskType | null
    points: number | null
    isActive: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.TaskType | null
    points: number | null
    isActive: boolean | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    points: number
    requirements: number
    isActive: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    points?: true
  }

  export type TaskSumAggregateInputType = {
    points?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    points?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    points?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    points?: true
    requirements?: true
    isActive?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    name: string
    description: string
    type: $Enums.TaskType
    points: number
    requirements: JsonValue
    isActive: boolean
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    points?: boolean
    requirements?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    completions?: boolean | Task$completionsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    points?: boolean
    requirements?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    points?: boolean
    requirements?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    points?: boolean
    requirements?: boolean
    isActive?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "points" | "requirements" | "isActive" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    completions?: boolean | Task$completionsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      completions: Prisma.$TaskCompletionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      type: $Enums.TaskType
      points: number
      requirements: Prisma.JsonValue
      isActive: boolean
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    completions<T extends Task$completionsArgs<ExtArgs> = {}>(args?: Subset<T, Task$completionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCompletionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly name: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly type: FieldRef<"Task", 'TaskType'>
    readonly points: FieldRef<"Task", 'Int'>
    readonly requirements: FieldRef<"Task", 'Json'>
    readonly isActive: FieldRef<"Task", 'Boolean'>
    readonly expiresAt: FieldRef<"Task", 'DateTime'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.completions
   */
  export type Task$completionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletion
     */
    select?: TaskCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletion
     */
    omit?: TaskCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionInclude<ExtArgs> | null
    where?: TaskCompletionWhereInput
    orderBy?: TaskCompletionOrderByWithRelationInput | TaskCompletionOrderByWithRelationInput[]
    cursor?: TaskCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskCompletionScalarFieldEnum | TaskCompletionScalarFieldEnum[]
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model AdminSession
   */

  export type AggregateAdminSession = {
    _count: AdminSessionCountAggregateOutputType | null
    _min: AdminSessionMinAggregateOutputType | null
    _max: AdminSessionMaxAggregateOutputType | null
  }

  export type AdminSessionMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    lastActivity: Date | null
    createdAt: Date | null
  }

  export type AdminSessionMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    ipAddress: string | null
    userAgent: string | null
    expiresAt: Date | null
    lastActivity: Date | null
    createdAt: Date | null
  }

  export type AdminSessionCountAggregateOutputType = {
    id: number
    adminId: number
    ipAddress: number
    userAgent: number
    permissions: number
    expiresAt: number
    lastActivity: number
    createdAt: number
    _all: number
  }


  export type AdminSessionMinAggregateInputType = {
    id?: true
    adminId?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    lastActivity?: true
    createdAt?: true
  }

  export type AdminSessionMaxAggregateInputType = {
    id?: true
    adminId?: true
    ipAddress?: true
    userAgent?: true
    expiresAt?: true
    lastActivity?: true
    createdAt?: true
  }

  export type AdminSessionCountAggregateInputType = {
    id?: true
    adminId?: true
    ipAddress?: true
    userAgent?: true
    permissions?: true
    expiresAt?: true
    lastActivity?: true
    createdAt?: true
    _all?: true
  }

  export type AdminSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminSession to aggregate.
     */
    where?: AdminSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSessions to fetch.
     */
    orderBy?: AdminSessionOrderByWithRelationInput | AdminSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminSessions
    **/
    _count?: true | AdminSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminSessionMaxAggregateInputType
  }

  export type GetAdminSessionAggregateType<T extends AdminSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminSession[P]>
      : GetScalarType<T[P], AggregateAdminSession[P]>
  }




  export type AdminSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminSessionWhereInput
    orderBy?: AdminSessionOrderByWithAggregationInput | AdminSessionOrderByWithAggregationInput[]
    by: AdminSessionScalarFieldEnum[] | AdminSessionScalarFieldEnum
    having?: AdminSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminSessionCountAggregateInputType | true
    _min?: AdminSessionMinAggregateInputType
    _max?: AdminSessionMaxAggregateInputType
  }

  export type AdminSessionGroupByOutputType = {
    id: string
    adminId: string
    ipAddress: string
    userAgent: string
    permissions: JsonValue
    expiresAt: Date
    lastActivity: Date
    createdAt: Date
    _count: AdminSessionCountAggregateOutputType | null
    _min: AdminSessionMinAggregateOutputType | null
    _max: AdminSessionMaxAggregateOutputType | null
  }

  type GetAdminSessionGroupByPayload<T extends AdminSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminSessionGroupByOutputType[P]>
            : GetScalarType<T[P], AdminSessionGroupByOutputType[P]>
        }
      >
    >


  export type AdminSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    permissions?: boolean
    expiresAt?: boolean
    lastActivity?: boolean
    createdAt?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminSession"]>

  export type AdminSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    permissions?: boolean
    expiresAt?: boolean
    lastActivity?: boolean
    createdAt?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminSession"]>

  export type AdminSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    permissions?: boolean
    expiresAt?: boolean
    lastActivity?: boolean
    createdAt?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminSession"]>

  export type AdminSessionSelectScalar = {
    id?: boolean
    adminId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    permissions?: boolean
    expiresAt?: boolean
    lastActivity?: boolean
    createdAt?: boolean
  }

  export type AdminSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "ipAddress" | "userAgent" | "permissions" | "expiresAt" | "lastActivity" | "createdAt", ExtArgs["result"]["adminSession"]>
  export type AdminSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminSession"
    objects: {
      admin: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      ipAddress: string
      userAgent: string
      permissions: Prisma.JsonValue
      expiresAt: Date
      lastActivity: Date
      createdAt: Date
    }, ExtArgs["result"]["adminSession"]>
    composites: {}
  }

  type AdminSessionGetPayload<S extends boolean | null | undefined | AdminSessionDefaultArgs> = $Result.GetResult<Prisma.$AdminSessionPayload, S>

  type AdminSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminSessionCountAggregateInputType | true
    }

  export interface AdminSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminSession'], meta: { name: 'AdminSession' } }
    /**
     * Find zero or one AdminSession that matches the filter.
     * @param {AdminSessionFindUniqueArgs} args - Arguments to find a AdminSession
     * @example
     * // Get one AdminSession
     * const adminSession = await prisma.adminSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminSessionFindUniqueArgs>(args: SelectSubset<T, AdminSessionFindUniqueArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminSessionFindUniqueOrThrowArgs} args - Arguments to find a AdminSession
     * @example
     * // Get one AdminSession
     * const adminSession = await prisma.adminSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionFindFirstArgs} args - Arguments to find a AdminSession
     * @example
     * // Get one AdminSession
     * const adminSession = await prisma.adminSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminSessionFindFirstArgs>(args?: SelectSubset<T, AdminSessionFindFirstArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionFindFirstOrThrowArgs} args - Arguments to find a AdminSession
     * @example
     * // Get one AdminSession
     * const adminSession = await prisma.adminSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminSessions
     * const adminSessions = await prisma.adminSession.findMany()
     * 
     * // Get first 10 AdminSessions
     * const adminSessions = await prisma.adminSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminSessionWithIdOnly = await prisma.adminSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminSessionFindManyArgs>(args?: SelectSubset<T, AdminSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminSession.
     * @param {AdminSessionCreateArgs} args - Arguments to create a AdminSession.
     * @example
     * // Create one AdminSession
     * const AdminSession = await prisma.adminSession.create({
     *   data: {
     *     // ... data to create a AdminSession
     *   }
     * })
     * 
     */
    create<T extends AdminSessionCreateArgs>(args: SelectSubset<T, AdminSessionCreateArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminSessions.
     * @param {AdminSessionCreateManyArgs} args - Arguments to create many AdminSessions.
     * @example
     * // Create many AdminSessions
     * const adminSession = await prisma.adminSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminSessionCreateManyArgs>(args?: SelectSubset<T, AdminSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminSessions and returns the data saved in the database.
     * @param {AdminSessionCreateManyAndReturnArgs} args - Arguments to create many AdminSessions.
     * @example
     * // Create many AdminSessions
     * const adminSession = await prisma.adminSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminSessions and only return the `id`
     * const adminSessionWithIdOnly = await prisma.adminSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminSession.
     * @param {AdminSessionDeleteArgs} args - Arguments to delete one AdminSession.
     * @example
     * // Delete one AdminSession
     * const AdminSession = await prisma.adminSession.delete({
     *   where: {
     *     // ... filter to delete one AdminSession
     *   }
     * })
     * 
     */
    delete<T extends AdminSessionDeleteArgs>(args: SelectSubset<T, AdminSessionDeleteArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminSession.
     * @param {AdminSessionUpdateArgs} args - Arguments to update one AdminSession.
     * @example
     * // Update one AdminSession
     * const adminSession = await prisma.adminSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminSessionUpdateArgs>(args: SelectSubset<T, AdminSessionUpdateArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminSessions.
     * @param {AdminSessionDeleteManyArgs} args - Arguments to filter AdminSessions to delete.
     * @example
     * // Delete a few AdminSessions
     * const { count } = await prisma.adminSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminSessionDeleteManyArgs>(args?: SelectSubset<T, AdminSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminSessions
     * const adminSession = await prisma.adminSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminSessionUpdateManyArgs>(args: SelectSubset<T, AdminSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminSessions and returns the data updated in the database.
     * @param {AdminSessionUpdateManyAndReturnArgs} args - Arguments to update many AdminSessions.
     * @example
     * // Update many AdminSessions
     * const adminSession = await prisma.adminSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminSessions and only return the `id`
     * const adminSessionWithIdOnly = await prisma.adminSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminSession.
     * @param {AdminSessionUpsertArgs} args - Arguments to update or create a AdminSession.
     * @example
     * // Update or create a AdminSession
     * const adminSession = await prisma.adminSession.upsert({
     *   create: {
     *     // ... data to create a AdminSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminSession we want to update
     *   }
     * })
     */
    upsert<T extends AdminSessionUpsertArgs>(args: SelectSubset<T, AdminSessionUpsertArgs<ExtArgs>>): Prisma__AdminSessionClient<$Result.GetResult<Prisma.$AdminSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionCountArgs} args - Arguments to filter AdminSessions to count.
     * @example
     * // Count the number of AdminSessions
     * const count = await prisma.adminSession.count({
     *   where: {
     *     // ... the filter for the AdminSessions we want to count
     *   }
     * })
    **/
    count<T extends AdminSessionCountArgs>(
      args?: Subset<T, AdminSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminSessionAggregateArgs>(args: Subset<T, AdminSessionAggregateArgs>): Prisma.PrismaPromise<GetAdminSessionAggregateType<T>>

    /**
     * Group by AdminSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminSessionGroupByArgs['orderBy'] }
        : { orderBy?: AdminSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminSession model
   */
  readonly fields: AdminSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminSession model
   */
  interface AdminSessionFieldRefs {
    readonly id: FieldRef<"AdminSession", 'String'>
    readonly adminId: FieldRef<"AdminSession", 'String'>
    readonly ipAddress: FieldRef<"AdminSession", 'String'>
    readonly userAgent: FieldRef<"AdminSession", 'String'>
    readonly permissions: FieldRef<"AdminSession", 'Json'>
    readonly expiresAt: FieldRef<"AdminSession", 'DateTime'>
    readonly lastActivity: FieldRef<"AdminSession", 'DateTime'>
    readonly createdAt: FieldRef<"AdminSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminSession findUnique
   */
  export type AdminSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * Filter, which AdminSession to fetch.
     */
    where: AdminSessionWhereUniqueInput
  }

  /**
   * AdminSession findUniqueOrThrow
   */
  export type AdminSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * Filter, which AdminSession to fetch.
     */
    where: AdminSessionWhereUniqueInput
  }

  /**
   * AdminSession findFirst
   */
  export type AdminSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * Filter, which AdminSession to fetch.
     */
    where?: AdminSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSessions to fetch.
     */
    orderBy?: AdminSessionOrderByWithRelationInput | AdminSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminSessions.
     */
    cursor?: AdminSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminSessions.
     */
    distinct?: AdminSessionScalarFieldEnum | AdminSessionScalarFieldEnum[]
  }

  /**
   * AdminSession findFirstOrThrow
   */
  export type AdminSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * Filter, which AdminSession to fetch.
     */
    where?: AdminSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSessions to fetch.
     */
    orderBy?: AdminSessionOrderByWithRelationInput | AdminSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminSessions.
     */
    cursor?: AdminSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminSessions.
     */
    distinct?: AdminSessionScalarFieldEnum | AdminSessionScalarFieldEnum[]
  }

  /**
   * AdminSession findMany
   */
  export type AdminSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * Filter, which AdminSessions to fetch.
     */
    where?: AdminSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminSessions to fetch.
     */
    orderBy?: AdminSessionOrderByWithRelationInput | AdminSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminSessions.
     */
    cursor?: AdminSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminSessions.
     */
    skip?: number
    distinct?: AdminSessionScalarFieldEnum | AdminSessionScalarFieldEnum[]
  }

  /**
   * AdminSession create
   */
  export type AdminSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminSession.
     */
    data: XOR<AdminSessionCreateInput, AdminSessionUncheckedCreateInput>
  }

  /**
   * AdminSession createMany
   */
  export type AdminSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminSessions.
     */
    data: AdminSessionCreateManyInput | AdminSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminSession createManyAndReturn
   */
  export type AdminSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * The data used to create many AdminSessions.
     */
    data: AdminSessionCreateManyInput | AdminSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminSession update
   */
  export type AdminSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminSession.
     */
    data: XOR<AdminSessionUpdateInput, AdminSessionUncheckedUpdateInput>
    /**
     * Choose, which AdminSession to update.
     */
    where: AdminSessionWhereUniqueInput
  }

  /**
   * AdminSession updateMany
   */
  export type AdminSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminSessions.
     */
    data: XOR<AdminSessionUpdateManyMutationInput, AdminSessionUncheckedUpdateManyInput>
    /**
     * Filter which AdminSessions to update
     */
    where?: AdminSessionWhereInput
    /**
     * Limit how many AdminSessions to update.
     */
    limit?: number
  }

  /**
   * AdminSession updateManyAndReturn
   */
  export type AdminSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * The data used to update AdminSessions.
     */
    data: XOR<AdminSessionUpdateManyMutationInput, AdminSessionUncheckedUpdateManyInput>
    /**
     * Filter which AdminSessions to update
     */
    where?: AdminSessionWhereInput
    /**
     * Limit how many AdminSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminSession upsert
   */
  export type AdminSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminSession to update in case it exists.
     */
    where: AdminSessionWhereUniqueInput
    /**
     * In case the AdminSession found by the `where` argument doesn't exist, create a new AdminSession with this data.
     */
    create: XOR<AdminSessionCreateInput, AdminSessionUncheckedCreateInput>
    /**
     * In case the AdminSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminSessionUpdateInput, AdminSessionUncheckedUpdateInput>
  }

  /**
   * AdminSession delete
   */
  export type AdminSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
    /**
     * Filter which AdminSession to delete.
     */
    where: AdminSessionWhereUniqueInput
  }

  /**
   * AdminSession deleteMany
   */
  export type AdminSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminSessions to delete
     */
    where?: AdminSessionWhereInput
    /**
     * Limit how many AdminSessions to delete.
     */
    limit?: number
  }

  /**
   * AdminSession without action
   */
  export type AdminSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminSession
     */
    select?: AdminSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminSession
     */
    omit?: AdminSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminSessionInclude<ExtArgs> | null
  }


  /**
   * Model AdminAuditLog
   */

  export type AggregateAdminAuditLog = {
    _count: AdminAuditLogCountAggregateOutputType | null
    _min: AdminAuditLogMinAggregateOutputType | null
    _max: AdminAuditLogMaxAggregateOutputType | null
  }

  export type AdminAuditLogMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    action: string | null
    timestamp: Date | null
    ipAddress: string | null
  }

  export type AdminAuditLogMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    action: string | null
    timestamp: Date | null
    ipAddress: string | null
  }

  export type AdminAuditLogCountAggregateOutputType = {
    id: number
    adminId: number
    action: number
    metadata: number
    timestamp: number
    ipAddress: number
    _all: number
  }


  export type AdminAuditLogMinAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    timestamp?: true
    ipAddress?: true
  }

  export type AdminAuditLogMaxAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    timestamp?: true
    ipAddress?: true
  }

  export type AdminAuditLogCountAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    metadata?: true
    timestamp?: true
    ipAddress?: true
    _all?: true
  }

  export type AdminAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAuditLog to aggregate.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminAuditLogs
    **/
    _count?: true | AdminAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminAuditLogMaxAggregateInputType
  }

  export type GetAdminAuditLogAggregateType<T extends AdminAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminAuditLog[P]>
      : GetScalarType<T[P], AggregateAdminAuditLog[P]>
  }




  export type AdminAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuditLogWhereInput
    orderBy?: AdminAuditLogOrderByWithAggregationInput | AdminAuditLogOrderByWithAggregationInput[]
    by: AdminAuditLogScalarFieldEnum[] | AdminAuditLogScalarFieldEnum
    having?: AdminAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminAuditLogCountAggregateInputType | true
    _min?: AdminAuditLogMinAggregateInputType
    _max?: AdminAuditLogMaxAggregateInputType
  }

  export type AdminAuditLogGroupByOutputType = {
    id: string
    adminId: string
    action: string
    metadata: JsonValue
    timestamp: Date
    ipAddress: string
    _count: AdminAuditLogCountAggregateOutputType | null
    _min: AdminAuditLogMinAggregateOutputType | null
    _max: AdminAuditLogMaxAggregateOutputType | null
  }

  type GetAdminAuditLogGroupByPayload<T extends AdminAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AdminAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AdminAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    metadata?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuditLog"]>

  export type AdminAuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    metadata?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuditLog"]>

  export type AdminAuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    metadata?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuditLog"]>

  export type AdminAuditLogSelectScalar = {
    id?: boolean
    adminId?: boolean
    action?: boolean
    metadata?: boolean
    timestamp?: boolean
    ipAddress?: boolean
  }

  export type AdminAuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "action" | "metadata" | "timestamp" | "ipAddress", ExtArgs["result"]["adminAuditLog"]>
  export type AdminAuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminAuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminAuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminAuditLog"
    objects: {
      admin: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      action: string
      metadata: Prisma.JsonValue
      timestamp: Date
      ipAddress: string
    }, ExtArgs["result"]["adminAuditLog"]>
    composites: {}
  }

  type AdminAuditLogGetPayload<S extends boolean | null | undefined | AdminAuditLogDefaultArgs> = $Result.GetResult<Prisma.$AdminAuditLogPayload, S>

  type AdminAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminAuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminAuditLogCountAggregateInputType | true
    }

  export interface AdminAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminAuditLog'], meta: { name: 'AdminAuditLog' } }
    /**
     * Find zero or one AdminAuditLog that matches the filter.
     * @param {AdminAuditLogFindUniqueArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminAuditLogFindUniqueArgs>(args: SelectSubset<T, AdminAuditLogFindUniqueArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminAuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminAuditLogFindUniqueOrThrowArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminAuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminAuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogFindFirstArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminAuditLogFindFirstArgs>(args?: SelectSubset<T, AdminAuditLogFindFirstArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogFindFirstOrThrowArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminAuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminAuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminAuditLogs
     * const adminAuditLogs = await prisma.adminAuditLog.findMany()
     * 
     * // Get first 10 AdminAuditLogs
     * const adminAuditLogs = await prisma.adminAuditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminAuditLogWithIdOnly = await prisma.adminAuditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminAuditLogFindManyArgs>(args?: SelectSubset<T, AdminAuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminAuditLog.
     * @param {AdminAuditLogCreateArgs} args - Arguments to create a AdminAuditLog.
     * @example
     * // Create one AdminAuditLog
     * const AdminAuditLog = await prisma.adminAuditLog.create({
     *   data: {
     *     // ... data to create a AdminAuditLog
     *   }
     * })
     * 
     */
    create<T extends AdminAuditLogCreateArgs>(args: SelectSubset<T, AdminAuditLogCreateArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminAuditLogs.
     * @param {AdminAuditLogCreateManyArgs} args - Arguments to create many AdminAuditLogs.
     * @example
     * // Create many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminAuditLogCreateManyArgs>(args?: SelectSubset<T, AdminAuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminAuditLogs and returns the data saved in the database.
     * @param {AdminAuditLogCreateManyAndReturnArgs} args - Arguments to create many AdminAuditLogs.
     * @example
     * // Create many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminAuditLogs and only return the `id`
     * const adminAuditLogWithIdOnly = await prisma.adminAuditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminAuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminAuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminAuditLog.
     * @param {AdminAuditLogDeleteArgs} args - Arguments to delete one AdminAuditLog.
     * @example
     * // Delete one AdminAuditLog
     * const AdminAuditLog = await prisma.adminAuditLog.delete({
     *   where: {
     *     // ... filter to delete one AdminAuditLog
     *   }
     * })
     * 
     */
    delete<T extends AdminAuditLogDeleteArgs>(args: SelectSubset<T, AdminAuditLogDeleteArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminAuditLog.
     * @param {AdminAuditLogUpdateArgs} args - Arguments to update one AdminAuditLog.
     * @example
     * // Update one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminAuditLogUpdateArgs>(args: SelectSubset<T, AdminAuditLogUpdateArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminAuditLogs.
     * @param {AdminAuditLogDeleteManyArgs} args - Arguments to filter AdminAuditLogs to delete.
     * @example
     * // Delete a few AdminAuditLogs
     * const { count } = await prisma.adminAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminAuditLogDeleteManyArgs>(args?: SelectSubset<T, AdminAuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminAuditLogUpdateManyArgs>(args: SelectSubset<T, AdminAuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAuditLogs and returns the data updated in the database.
     * @param {AdminAuditLogUpdateManyAndReturnArgs} args - Arguments to update many AdminAuditLogs.
     * @example
     * // Update many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminAuditLogs and only return the `id`
     * const adminAuditLogWithIdOnly = await prisma.adminAuditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminAuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminAuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminAuditLog.
     * @param {AdminAuditLogUpsertArgs} args - Arguments to update or create a AdminAuditLog.
     * @example
     * // Update or create a AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.upsert({
     *   create: {
     *     // ... data to create a AdminAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AdminAuditLogUpsertArgs>(args: SelectSubset<T, AdminAuditLogUpsertArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogCountArgs} args - Arguments to filter AdminAuditLogs to count.
     * @example
     * // Count the number of AdminAuditLogs
     * const count = await prisma.adminAuditLog.count({
     *   where: {
     *     // ... the filter for the AdminAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AdminAuditLogCountArgs>(
      args?: Subset<T, AdminAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAuditLogAggregateArgs>(args: Subset<T, AdminAuditLogAggregateArgs>): Prisma.PrismaPromise<GetAdminAuditLogAggregateType<T>>

    /**
     * Group by AdminAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AdminAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminAuditLog model
   */
  readonly fields: AdminAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminAuditLog model
   */
  interface AdminAuditLogFieldRefs {
    readonly id: FieldRef<"AdminAuditLog", 'String'>
    readonly adminId: FieldRef<"AdminAuditLog", 'String'>
    readonly action: FieldRef<"AdminAuditLog", 'String'>
    readonly metadata: FieldRef<"AdminAuditLog", 'Json'>
    readonly timestamp: FieldRef<"AdminAuditLog", 'DateTime'>
    readonly ipAddress: FieldRef<"AdminAuditLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AdminAuditLog findUnique
   */
  export type AdminAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog findUniqueOrThrow
   */
  export type AdminAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog findFirst
   */
  export type AdminAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAuditLogs.
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAuditLogs.
     */
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * AdminAuditLog findFirstOrThrow
   */
  export type AdminAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAuditLogs.
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAuditLogs.
     */
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * AdminAuditLog findMany
   */
  export type AdminAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLogs to fetch.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminAuditLogs.
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * AdminAuditLog create
   */
  export type AdminAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminAuditLog.
     */
    data: XOR<AdminAuditLogCreateInput, AdminAuditLogUncheckedCreateInput>
  }

  /**
   * AdminAuditLog createMany
   */
  export type AdminAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminAuditLogs.
     */
    data: AdminAuditLogCreateManyInput | AdminAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminAuditLog createManyAndReturn
   */
  export type AdminAuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AdminAuditLogs.
     */
    data: AdminAuditLogCreateManyInput | AdminAuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAuditLog update
   */
  export type AdminAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminAuditLog.
     */
    data: XOR<AdminAuditLogUpdateInput, AdminAuditLogUncheckedUpdateInput>
    /**
     * Choose, which AdminAuditLog to update.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog updateMany
   */
  export type AdminAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminAuditLogs.
     */
    data: XOR<AdminAuditLogUpdateManyMutationInput, AdminAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AdminAuditLogs to update
     */
    where?: AdminAuditLogWhereInput
    /**
     * Limit how many AdminAuditLogs to update.
     */
    limit?: number
  }

  /**
   * AdminAuditLog updateManyAndReturn
   */
  export type AdminAuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AdminAuditLogs.
     */
    data: XOR<AdminAuditLogUpdateManyMutationInput, AdminAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AdminAuditLogs to update
     */
    where?: AdminAuditLogWhereInput
    /**
     * Limit how many AdminAuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAuditLog upsert
   */
  export type AdminAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminAuditLog to update in case it exists.
     */
    where: AdminAuditLogWhereUniqueInput
    /**
     * In case the AdminAuditLog found by the `where` argument doesn't exist, create a new AdminAuditLog with this data.
     */
    create: XOR<AdminAuditLogCreateInput, AdminAuditLogUncheckedCreateInput>
    /**
     * In case the AdminAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminAuditLogUpdateInput, AdminAuditLogUncheckedUpdateInput>
  }

  /**
   * AdminAuditLog delete
   */
  export type AdminAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter which AdminAuditLog to delete.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog deleteMany
   */
  export type AdminAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAuditLogs to delete
     */
    where?: AdminAuditLogWhereInput
    /**
     * Limit how many AdminAuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AdminAuditLog without action
   */
  export type AdminAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminAuditLog
     */
    omit?: AdminAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
  }


  /**
   * Model FraudAlert
   */

  export type AggregateFraudAlert = {
    _count: FraudAlertCountAggregateOutputType | null
    _avg: FraudAlertAvgAggregateOutputType | null
    _sum: FraudAlertSumAggregateOutputType | null
    _min: FraudAlertMinAggregateOutputType | null
    _max: FraudAlertMaxAggregateOutputType | null
  }

  export type FraudAlertAvgAggregateOutputType = {
    riskScore: number | null
  }

  export type FraudAlertSumAggregateOutputType = {
    riskScore: number | null
  }

  export type FraudAlertMinAggregateOutputType = {
    id: string | null
    type: string | null
    severity: string | null
    userId: string | null
    description: string | null
    riskScore: number | null
    status: string | null
    createdAt: Date | null
    investigatedBy: string | null
    resolvedAt: Date | null
  }

  export type FraudAlertMaxAggregateOutputType = {
    id: string | null
    type: string | null
    severity: string | null
    userId: string | null
    description: string | null
    riskScore: number | null
    status: string | null
    createdAt: Date | null
    investigatedBy: string | null
    resolvedAt: Date | null
  }

  export type FraudAlertCountAggregateOutputType = {
    id: number
    type: number
    severity: number
    userId: number
    description: number
    evidence: number
    riskScore: number
    status: number
    createdAt: number
    investigatedBy: number
    resolvedAt: number
    _all: number
  }


  export type FraudAlertAvgAggregateInputType = {
    riskScore?: true
  }

  export type FraudAlertSumAggregateInputType = {
    riskScore?: true
  }

  export type FraudAlertMinAggregateInputType = {
    id?: true
    type?: true
    severity?: true
    userId?: true
    description?: true
    riskScore?: true
    status?: true
    createdAt?: true
    investigatedBy?: true
    resolvedAt?: true
  }

  export type FraudAlertMaxAggregateInputType = {
    id?: true
    type?: true
    severity?: true
    userId?: true
    description?: true
    riskScore?: true
    status?: true
    createdAt?: true
    investigatedBy?: true
    resolvedAt?: true
  }

  export type FraudAlertCountAggregateInputType = {
    id?: true
    type?: true
    severity?: true
    userId?: true
    description?: true
    evidence?: true
    riskScore?: true
    status?: true
    createdAt?: true
    investigatedBy?: true
    resolvedAt?: true
    _all?: true
  }

  export type FraudAlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FraudAlert to aggregate.
     */
    where?: FraudAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FraudAlerts to fetch.
     */
    orderBy?: FraudAlertOrderByWithRelationInput | FraudAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FraudAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FraudAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FraudAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FraudAlerts
    **/
    _count?: true | FraudAlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FraudAlertAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FraudAlertSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FraudAlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FraudAlertMaxAggregateInputType
  }

  export type GetFraudAlertAggregateType<T extends FraudAlertAggregateArgs> = {
        [P in keyof T & keyof AggregateFraudAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFraudAlert[P]>
      : GetScalarType<T[P], AggregateFraudAlert[P]>
  }




  export type FraudAlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FraudAlertWhereInput
    orderBy?: FraudAlertOrderByWithAggregationInput | FraudAlertOrderByWithAggregationInput[]
    by: FraudAlertScalarFieldEnum[] | FraudAlertScalarFieldEnum
    having?: FraudAlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FraudAlertCountAggregateInputType | true
    _avg?: FraudAlertAvgAggregateInputType
    _sum?: FraudAlertSumAggregateInputType
    _min?: FraudAlertMinAggregateInputType
    _max?: FraudAlertMaxAggregateInputType
  }

  export type FraudAlertGroupByOutputType = {
    id: string
    type: string
    severity: string
    userId: string
    description: string
    evidence: JsonValue
    riskScore: number
    status: string
    createdAt: Date
    investigatedBy: string | null
    resolvedAt: Date | null
    _count: FraudAlertCountAggregateOutputType | null
    _avg: FraudAlertAvgAggregateOutputType | null
    _sum: FraudAlertSumAggregateOutputType | null
    _min: FraudAlertMinAggregateOutputType | null
    _max: FraudAlertMaxAggregateOutputType | null
  }

  type GetFraudAlertGroupByPayload<T extends FraudAlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FraudAlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FraudAlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FraudAlertGroupByOutputType[P]>
            : GetScalarType<T[P], FraudAlertGroupByOutputType[P]>
        }
      >
    >


  export type FraudAlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    severity?: boolean
    userId?: boolean
    description?: boolean
    evidence?: boolean
    riskScore?: boolean
    status?: boolean
    createdAt?: boolean
    investigatedBy?: boolean
    resolvedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fraudAlert"]>

  export type FraudAlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    severity?: boolean
    userId?: boolean
    description?: boolean
    evidence?: boolean
    riskScore?: boolean
    status?: boolean
    createdAt?: boolean
    investigatedBy?: boolean
    resolvedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fraudAlert"]>

  export type FraudAlertSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    severity?: boolean
    userId?: boolean
    description?: boolean
    evidence?: boolean
    riskScore?: boolean
    status?: boolean
    createdAt?: boolean
    investigatedBy?: boolean
    resolvedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fraudAlert"]>

  export type FraudAlertSelectScalar = {
    id?: boolean
    type?: boolean
    severity?: boolean
    userId?: boolean
    description?: boolean
    evidence?: boolean
    riskScore?: boolean
    status?: boolean
    createdAt?: boolean
    investigatedBy?: boolean
    resolvedAt?: boolean
  }

  export type FraudAlertOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "severity" | "userId" | "description" | "evidence" | "riskScore" | "status" | "createdAt" | "investigatedBy" | "resolvedAt", ExtArgs["result"]["fraudAlert"]>
  export type FraudAlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FraudAlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FraudAlertIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FraudAlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FraudAlert"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      severity: string
      userId: string
      description: string
      evidence: Prisma.JsonValue
      riskScore: number
      status: string
      createdAt: Date
      investigatedBy: string | null
      resolvedAt: Date | null
    }, ExtArgs["result"]["fraudAlert"]>
    composites: {}
  }

  type FraudAlertGetPayload<S extends boolean | null | undefined | FraudAlertDefaultArgs> = $Result.GetResult<Prisma.$FraudAlertPayload, S>

  type FraudAlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FraudAlertFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FraudAlertCountAggregateInputType | true
    }

  export interface FraudAlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FraudAlert'], meta: { name: 'FraudAlert' } }
    /**
     * Find zero or one FraudAlert that matches the filter.
     * @param {FraudAlertFindUniqueArgs} args - Arguments to find a FraudAlert
     * @example
     * // Get one FraudAlert
     * const fraudAlert = await prisma.fraudAlert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FraudAlertFindUniqueArgs>(args: SelectSubset<T, FraudAlertFindUniqueArgs<ExtArgs>>): Prisma__FraudAlertClient<$Result.GetResult<Prisma.$FraudAlertPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FraudAlert that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FraudAlertFindUniqueOrThrowArgs} args - Arguments to find a FraudAlert
     * @example
     * // Get one FraudAlert
     * const fraudAlert = await prisma.fraudAlert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FraudAlertFindUniqueOrThrowArgs>(args: SelectSubset<T, FraudAlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FraudAlertClient<$Result.GetResult<Prisma.$FraudAlertPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FraudAlert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FraudAlertFindFirstArgs} args - Arguments to find a FraudAlert
     * @example
     * // Get one FraudAlert
     * const fraudAlert = await prisma.fraudAlert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FraudAlertFindFirstArgs>(args?: SelectSubset<T, FraudAlertFindFirstArgs<ExtArgs>>): Prisma__FraudAlertClient<$Result.GetResult<Prisma.$FraudAlertPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FraudAlert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FraudAlertFindFirstOrThrowArgs} args - Arguments to find a FraudAlert
     * @example
     * // Get one FraudAlert
     * const fraudAlert = await prisma.fraudAlert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FraudAlertFindFirstOrThrowArgs>(args?: SelectSubset<T, FraudAlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__FraudAlertClient<$Result.GetResult<Prisma.$FraudAlertPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FraudAlerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FraudAlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FraudAlerts
     * const fraudAlerts = await prisma.fraudAlert.findMany()
     * 
     * // Get first 10 FraudAlerts
     * const fraudAlerts = await prisma.fraudAlert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fraudAlertWithIdOnly = await prisma.fraudAlert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FraudAlertFindManyArgs>(args?: SelectSubset<T, FraudAlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FraudAlertPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FraudAlert.
     * @param {FraudAlertCreateArgs} args - Arguments to create a FraudAlert.
     * @example
     * // Create one FraudAlert
     * const FraudAlert = await prisma.fraudAlert.create({
     *   data: {
     *     // ... data to create a FraudAlert
     *   }
     * })
     * 
     */
    create<T extends FraudAlertCreateArgs>(args: SelectSubset<T, FraudAlertCreateArgs<ExtArgs>>): Prisma__FraudAlertClient<$Result.GetResult<Prisma.$FraudAlertPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FraudAlerts.
     * @param {FraudAlertCreateManyArgs} args - Arguments to create many FraudAlerts.
     * @example
     * // Create many FraudAlerts
     * const fraudAlert = await prisma.fraudAlert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FraudAlertCreateManyArgs>(args?: SelectSubset<T, FraudAlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FraudAlerts and returns the data saved in the database.
     * @param {FraudAlertCreateManyAndReturnArgs} args - Arguments to create many FraudAlerts.
     * @example
     * // Create many FraudAlerts
     * const fraudAlert = await prisma.fraudAlert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FraudAlerts and only return the `id`
     * const fraudAlertWithIdOnly = await prisma.fraudAlert.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FraudAlertCreateManyAndReturnArgs>(args?: SelectSubset<T, FraudAlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FraudAlertPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FraudAlert.
     * @param {FraudAlertDeleteArgs} args - Arguments to delete one FraudAlert.
     * @example
     * // Delete one FraudAlert
     * const FraudAlert = await prisma.fraudAlert.delete({
     *   where: {
     *     // ... filter to delete one FraudAlert
     *   }
     * })
     * 
     */
    delete<T extends FraudAlertDeleteArgs>(args: SelectSubset<T, FraudAlertDeleteArgs<ExtArgs>>): Prisma__FraudAlertClient<$Result.GetResult<Prisma.$FraudAlertPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FraudAlert.
     * @param {FraudAlertUpdateArgs} args - Arguments to update one FraudAlert.
     * @example
     * // Update one FraudAlert
     * const fraudAlert = await prisma.fraudAlert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FraudAlertUpdateArgs>(args: SelectSubset<T, FraudAlertUpdateArgs<ExtArgs>>): Prisma__FraudAlertClient<$Result.GetResult<Prisma.$FraudAlertPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FraudAlerts.
     * @param {FraudAlertDeleteManyArgs} args - Arguments to filter FraudAlerts to delete.
     * @example
     * // Delete a few FraudAlerts
     * const { count } = await prisma.fraudAlert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FraudAlertDeleteManyArgs>(args?: SelectSubset<T, FraudAlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FraudAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FraudAlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FraudAlerts
     * const fraudAlert = await prisma.fraudAlert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FraudAlertUpdateManyArgs>(args: SelectSubset<T, FraudAlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FraudAlerts and returns the data updated in the database.
     * @param {FraudAlertUpdateManyAndReturnArgs} args - Arguments to update many FraudAlerts.
     * @example
     * // Update many FraudAlerts
     * const fraudAlert = await prisma.fraudAlert.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FraudAlerts and only return the `id`
     * const fraudAlertWithIdOnly = await prisma.fraudAlert.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FraudAlertUpdateManyAndReturnArgs>(args: SelectSubset<T, FraudAlertUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FraudAlertPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FraudAlert.
     * @param {FraudAlertUpsertArgs} args - Arguments to update or create a FraudAlert.
     * @example
     * // Update or create a FraudAlert
     * const fraudAlert = await prisma.fraudAlert.upsert({
     *   create: {
     *     // ... data to create a FraudAlert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FraudAlert we want to update
     *   }
     * })
     */
    upsert<T extends FraudAlertUpsertArgs>(args: SelectSubset<T, FraudAlertUpsertArgs<ExtArgs>>): Prisma__FraudAlertClient<$Result.GetResult<Prisma.$FraudAlertPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FraudAlerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FraudAlertCountArgs} args - Arguments to filter FraudAlerts to count.
     * @example
     * // Count the number of FraudAlerts
     * const count = await prisma.fraudAlert.count({
     *   where: {
     *     // ... the filter for the FraudAlerts we want to count
     *   }
     * })
    **/
    count<T extends FraudAlertCountArgs>(
      args?: Subset<T, FraudAlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FraudAlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FraudAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FraudAlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FraudAlertAggregateArgs>(args: Subset<T, FraudAlertAggregateArgs>): Prisma.PrismaPromise<GetFraudAlertAggregateType<T>>

    /**
     * Group by FraudAlert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FraudAlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FraudAlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FraudAlertGroupByArgs['orderBy'] }
        : { orderBy?: FraudAlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FraudAlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFraudAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FraudAlert model
   */
  readonly fields: FraudAlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FraudAlert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FraudAlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FraudAlert model
   */
  interface FraudAlertFieldRefs {
    readonly id: FieldRef<"FraudAlert", 'String'>
    readonly type: FieldRef<"FraudAlert", 'String'>
    readonly severity: FieldRef<"FraudAlert", 'String'>
    readonly userId: FieldRef<"FraudAlert", 'String'>
    readonly description: FieldRef<"FraudAlert", 'String'>
    readonly evidence: FieldRef<"FraudAlert", 'Json'>
    readonly riskScore: FieldRef<"FraudAlert", 'Int'>
    readonly status: FieldRef<"FraudAlert", 'String'>
    readonly createdAt: FieldRef<"FraudAlert", 'DateTime'>
    readonly investigatedBy: FieldRef<"FraudAlert", 'String'>
    readonly resolvedAt: FieldRef<"FraudAlert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FraudAlert findUnique
   */
  export type FraudAlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudAlert
     */
    select?: FraudAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudAlert
     */
    omit?: FraudAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudAlertInclude<ExtArgs> | null
    /**
     * Filter, which FraudAlert to fetch.
     */
    where: FraudAlertWhereUniqueInput
  }

  /**
   * FraudAlert findUniqueOrThrow
   */
  export type FraudAlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudAlert
     */
    select?: FraudAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudAlert
     */
    omit?: FraudAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudAlertInclude<ExtArgs> | null
    /**
     * Filter, which FraudAlert to fetch.
     */
    where: FraudAlertWhereUniqueInput
  }

  /**
   * FraudAlert findFirst
   */
  export type FraudAlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudAlert
     */
    select?: FraudAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudAlert
     */
    omit?: FraudAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudAlertInclude<ExtArgs> | null
    /**
     * Filter, which FraudAlert to fetch.
     */
    where?: FraudAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FraudAlerts to fetch.
     */
    orderBy?: FraudAlertOrderByWithRelationInput | FraudAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FraudAlerts.
     */
    cursor?: FraudAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FraudAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FraudAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FraudAlerts.
     */
    distinct?: FraudAlertScalarFieldEnum | FraudAlertScalarFieldEnum[]
  }

  /**
   * FraudAlert findFirstOrThrow
   */
  export type FraudAlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudAlert
     */
    select?: FraudAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudAlert
     */
    omit?: FraudAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudAlertInclude<ExtArgs> | null
    /**
     * Filter, which FraudAlert to fetch.
     */
    where?: FraudAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FraudAlerts to fetch.
     */
    orderBy?: FraudAlertOrderByWithRelationInput | FraudAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FraudAlerts.
     */
    cursor?: FraudAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FraudAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FraudAlerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FraudAlerts.
     */
    distinct?: FraudAlertScalarFieldEnum | FraudAlertScalarFieldEnum[]
  }

  /**
   * FraudAlert findMany
   */
  export type FraudAlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudAlert
     */
    select?: FraudAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudAlert
     */
    omit?: FraudAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudAlertInclude<ExtArgs> | null
    /**
     * Filter, which FraudAlerts to fetch.
     */
    where?: FraudAlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FraudAlerts to fetch.
     */
    orderBy?: FraudAlertOrderByWithRelationInput | FraudAlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FraudAlerts.
     */
    cursor?: FraudAlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FraudAlerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FraudAlerts.
     */
    skip?: number
    distinct?: FraudAlertScalarFieldEnum | FraudAlertScalarFieldEnum[]
  }

  /**
   * FraudAlert create
   */
  export type FraudAlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudAlert
     */
    select?: FraudAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudAlert
     */
    omit?: FraudAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudAlertInclude<ExtArgs> | null
    /**
     * The data needed to create a FraudAlert.
     */
    data: XOR<FraudAlertCreateInput, FraudAlertUncheckedCreateInput>
  }

  /**
   * FraudAlert createMany
   */
  export type FraudAlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FraudAlerts.
     */
    data: FraudAlertCreateManyInput | FraudAlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FraudAlert createManyAndReturn
   */
  export type FraudAlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudAlert
     */
    select?: FraudAlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FraudAlert
     */
    omit?: FraudAlertOmit<ExtArgs> | null
    /**
     * The data used to create many FraudAlerts.
     */
    data: FraudAlertCreateManyInput | FraudAlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudAlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FraudAlert update
   */
  export type FraudAlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudAlert
     */
    select?: FraudAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudAlert
     */
    omit?: FraudAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudAlertInclude<ExtArgs> | null
    /**
     * The data needed to update a FraudAlert.
     */
    data: XOR<FraudAlertUpdateInput, FraudAlertUncheckedUpdateInput>
    /**
     * Choose, which FraudAlert to update.
     */
    where: FraudAlertWhereUniqueInput
  }

  /**
   * FraudAlert updateMany
   */
  export type FraudAlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FraudAlerts.
     */
    data: XOR<FraudAlertUpdateManyMutationInput, FraudAlertUncheckedUpdateManyInput>
    /**
     * Filter which FraudAlerts to update
     */
    where?: FraudAlertWhereInput
    /**
     * Limit how many FraudAlerts to update.
     */
    limit?: number
  }

  /**
   * FraudAlert updateManyAndReturn
   */
  export type FraudAlertUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudAlert
     */
    select?: FraudAlertSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FraudAlert
     */
    omit?: FraudAlertOmit<ExtArgs> | null
    /**
     * The data used to update FraudAlerts.
     */
    data: XOR<FraudAlertUpdateManyMutationInput, FraudAlertUncheckedUpdateManyInput>
    /**
     * Filter which FraudAlerts to update
     */
    where?: FraudAlertWhereInput
    /**
     * Limit how many FraudAlerts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudAlertIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FraudAlert upsert
   */
  export type FraudAlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudAlert
     */
    select?: FraudAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudAlert
     */
    omit?: FraudAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudAlertInclude<ExtArgs> | null
    /**
     * The filter to search for the FraudAlert to update in case it exists.
     */
    where: FraudAlertWhereUniqueInput
    /**
     * In case the FraudAlert found by the `where` argument doesn't exist, create a new FraudAlert with this data.
     */
    create: XOR<FraudAlertCreateInput, FraudAlertUncheckedCreateInput>
    /**
     * In case the FraudAlert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FraudAlertUpdateInput, FraudAlertUncheckedUpdateInput>
  }

  /**
   * FraudAlert delete
   */
  export type FraudAlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudAlert
     */
    select?: FraudAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudAlert
     */
    omit?: FraudAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudAlertInclude<ExtArgs> | null
    /**
     * Filter which FraudAlert to delete.
     */
    where: FraudAlertWhereUniqueInput
  }

  /**
   * FraudAlert deleteMany
   */
  export type FraudAlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FraudAlerts to delete
     */
    where?: FraudAlertWhereInput
    /**
     * Limit how many FraudAlerts to delete.
     */
    limit?: number
  }

  /**
   * FraudAlert without action
   */
  export type FraudAlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FraudAlert
     */
    select?: FraudAlertSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FraudAlert
     */
    omit?: FraudAlertOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FraudAlertInclude<ExtArgs> | null
  }


  /**
   * Model CampaignConfig
   */

  export type AggregateCampaignConfig = {
    _count: CampaignConfigCountAggregateOutputType | null
    _avg: CampaignConfigAvgAggregateOutputType | null
    _sum: CampaignConfigSumAggregateOutputType | null
    _min: CampaignConfigMinAggregateOutputType | null
    _max: CampaignConfigMaxAggregateOutputType | null
  }

  export type CampaignConfigAvgAggregateOutputType = {
    totalAllocation: number | null
  }

  export type CampaignConfigSumAggregateOutputType = {
    totalAllocation: bigint | null
  }

  export type CampaignConfigMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    tokenMint: string | null
    totalAllocation: bigint | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignConfigMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    tokenMint: string | null
    totalAllocation: bigint | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CampaignConfigCountAggregateOutputType = {
    id: number
    name: number
    description: number
    tokenMint: number
    totalAllocation: number
    startDate: number
    endDate: number
    eligibilityCriteria: number
    distributionRules: number
    isActive: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CampaignConfigAvgAggregateInputType = {
    totalAllocation?: true
  }

  export type CampaignConfigSumAggregateInputType = {
    totalAllocation?: true
  }

  export type CampaignConfigMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tokenMint?: true
    totalAllocation?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignConfigMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tokenMint?: true
    totalAllocation?: true
    startDate?: true
    endDate?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CampaignConfigCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tokenMint?: true
    totalAllocation?: true
    startDate?: true
    endDate?: true
    eligibilityCriteria?: true
    distributionRules?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CampaignConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignConfig to aggregate.
     */
    where?: CampaignConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignConfigs to fetch.
     */
    orderBy?: CampaignConfigOrderByWithRelationInput | CampaignConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CampaignConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CampaignConfigs
    **/
    _count?: true | CampaignConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CampaignConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CampaignConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CampaignConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CampaignConfigMaxAggregateInputType
  }

  export type GetCampaignConfigAggregateType<T extends CampaignConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateCampaignConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCampaignConfig[P]>
      : GetScalarType<T[P], AggregateCampaignConfig[P]>
  }




  export type CampaignConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CampaignConfigWhereInput
    orderBy?: CampaignConfigOrderByWithAggregationInput | CampaignConfigOrderByWithAggregationInput[]
    by: CampaignConfigScalarFieldEnum[] | CampaignConfigScalarFieldEnum
    having?: CampaignConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CampaignConfigCountAggregateInputType | true
    _avg?: CampaignConfigAvgAggregateInputType
    _sum?: CampaignConfigSumAggregateInputType
    _min?: CampaignConfigMinAggregateInputType
    _max?: CampaignConfigMaxAggregateInputType
  }

  export type CampaignConfigGroupByOutputType = {
    id: string
    name: string
    description: string | null
    tokenMint: string
    totalAllocation: bigint
    startDate: Date
    endDate: Date
    eligibilityCriteria: JsonValue
    distributionRules: JsonValue
    isActive: boolean
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: CampaignConfigCountAggregateOutputType | null
    _avg: CampaignConfigAvgAggregateOutputType | null
    _sum: CampaignConfigSumAggregateOutputType | null
    _min: CampaignConfigMinAggregateOutputType | null
    _max: CampaignConfigMaxAggregateOutputType | null
  }

  type GetCampaignConfigGroupByPayload<T extends CampaignConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CampaignConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CampaignConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CampaignConfigGroupByOutputType[P]>
            : GetScalarType<T[P], CampaignConfigGroupByOutputType[P]>
        }
      >
    >


  export type CampaignConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tokenMint?: boolean
    totalAllocation?: boolean
    startDate?: boolean
    endDate?: boolean
    eligibilityCriteria?: boolean
    distributionRules?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignConfig"]>

  export type CampaignConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tokenMint?: boolean
    totalAllocation?: boolean
    startDate?: boolean
    endDate?: boolean
    eligibilityCriteria?: boolean
    distributionRules?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignConfig"]>

  export type CampaignConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tokenMint?: boolean
    totalAllocation?: boolean
    startDate?: boolean
    endDate?: boolean
    eligibilityCriteria?: boolean
    distributionRules?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["campaignConfig"]>

  export type CampaignConfigSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    tokenMint?: boolean
    totalAllocation?: boolean
    startDate?: boolean
    endDate?: boolean
    eligibilityCriteria?: boolean
    distributionRules?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CampaignConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "tokenMint" | "totalAllocation" | "startDate" | "endDate" | "eligibilityCriteria" | "distributionRules" | "isActive" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["campaignConfig"]>
  export type CampaignConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CampaignConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CampaignConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CampaignConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CampaignConfig"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      tokenMint: string
      totalAllocation: bigint
      startDate: Date
      endDate: Date
      eligibilityCriteria: Prisma.JsonValue
      distributionRules: Prisma.JsonValue
      isActive: boolean
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["campaignConfig"]>
    composites: {}
  }

  type CampaignConfigGetPayload<S extends boolean | null | undefined | CampaignConfigDefaultArgs> = $Result.GetResult<Prisma.$CampaignConfigPayload, S>

  type CampaignConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CampaignConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CampaignConfigCountAggregateInputType | true
    }

  export interface CampaignConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CampaignConfig'], meta: { name: 'CampaignConfig' } }
    /**
     * Find zero or one CampaignConfig that matches the filter.
     * @param {CampaignConfigFindUniqueArgs} args - Arguments to find a CampaignConfig
     * @example
     * // Get one CampaignConfig
     * const campaignConfig = await prisma.campaignConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CampaignConfigFindUniqueArgs>(args: SelectSubset<T, CampaignConfigFindUniqueArgs<ExtArgs>>): Prisma__CampaignConfigClient<$Result.GetResult<Prisma.$CampaignConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CampaignConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CampaignConfigFindUniqueOrThrowArgs} args - Arguments to find a CampaignConfig
     * @example
     * // Get one CampaignConfig
     * const campaignConfig = await prisma.campaignConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CampaignConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, CampaignConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CampaignConfigClient<$Result.GetResult<Prisma.$CampaignConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignConfigFindFirstArgs} args - Arguments to find a CampaignConfig
     * @example
     * // Get one CampaignConfig
     * const campaignConfig = await prisma.campaignConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CampaignConfigFindFirstArgs>(args?: SelectSubset<T, CampaignConfigFindFirstArgs<ExtArgs>>): Prisma__CampaignConfigClient<$Result.GetResult<Prisma.$CampaignConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CampaignConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignConfigFindFirstOrThrowArgs} args - Arguments to find a CampaignConfig
     * @example
     * // Get one CampaignConfig
     * const campaignConfig = await prisma.campaignConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CampaignConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, CampaignConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__CampaignConfigClient<$Result.GetResult<Prisma.$CampaignConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CampaignConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CampaignConfigs
     * const campaignConfigs = await prisma.campaignConfig.findMany()
     * 
     * // Get first 10 CampaignConfigs
     * const campaignConfigs = await prisma.campaignConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const campaignConfigWithIdOnly = await prisma.campaignConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CampaignConfigFindManyArgs>(args?: SelectSubset<T, CampaignConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CampaignConfig.
     * @param {CampaignConfigCreateArgs} args - Arguments to create a CampaignConfig.
     * @example
     * // Create one CampaignConfig
     * const CampaignConfig = await prisma.campaignConfig.create({
     *   data: {
     *     // ... data to create a CampaignConfig
     *   }
     * })
     * 
     */
    create<T extends CampaignConfigCreateArgs>(args: SelectSubset<T, CampaignConfigCreateArgs<ExtArgs>>): Prisma__CampaignConfigClient<$Result.GetResult<Prisma.$CampaignConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CampaignConfigs.
     * @param {CampaignConfigCreateManyArgs} args - Arguments to create many CampaignConfigs.
     * @example
     * // Create many CampaignConfigs
     * const campaignConfig = await prisma.campaignConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CampaignConfigCreateManyArgs>(args?: SelectSubset<T, CampaignConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CampaignConfigs and returns the data saved in the database.
     * @param {CampaignConfigCreateManyAndReturnArgs} args - Arguments to create many CampaignConfigs.
     * @example
     * // Create many CampaignConfigs
     * const campaignConfig = await prisma.campaignConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CampaignConfigs and only return the `id`
     * const campaignConfigWithIdOnly = await prisma.campaignConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CampaignConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, CampaignConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CampaignConfig.
     * @param {CampaignConfigDeleteArgs} args - Arguments to delete one CampaignConfig.
     * @example
     * // Delete one CampaignConfig
     * const CampaignConfig = await prisma.campaignConfig.delete({
     *   where: {
     *     // ... filter to delete one CampaignConfig
     *   }
     * })
     * 
     */
    delete<T extends CampaignConfigDeleteArgs>(args: SelectSubset<T, CampaignConfigDeleteArgs<ExtArgs>>): Prisma__CampaignConfigClient<$Result.GetResult<Prisma.$CampaignConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CampaignConfig.
     * @param {CampaignConfigUpdateArgs} args - Arguments to update one CampaignConfig.
     * @example
     * // Update one CampaignConfig
     * const campaignConfig = await prisma.campaignConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CampaignConfigUpdateArgs>(args: SelectSubset<T, CampaignConfigUpdateArgs<ExtArgs>>): Prisma__CampaignConfigClient<$Result.GetResult<Prisma.$CampaignConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CampaignConfigs.
     * @param {CampaignConfigDeleteManyArgs} args - Arguments to filter CampaignConfigs to delete.
     * @example
     * // Delete a few CampaignConfigs
     * const { count } = await prisma.campaignConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CampaignConfigDeleteManyArgs>(args?: SelectSubset<T, CampaignConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CampaignConfigs
     * const campaignConfig = await prisma.campaignConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CampaignConfigUpdateManyArgs>(args: SelectSubset<T, CampaignConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CampaignConfigs and returns the data updated in the database.
     * @param {CampaignConfigUpdateManyAndReturnArgs} args - Arguments to update many CampaignConfigs.
     * @example
     * // Update many CampaignConfigs
     * const campaignConfig = await prisma.campaignConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CampaignConfigs and only return the `id`
     * const campaignConfigWithIdOnly = await prisma.campaignConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CampaignConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, CampaignConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CampaignConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CampaignConfig.
     * @param {CampaignConfigUpsertArgs} args - Arguments to update or create a CampaignConfig.
     * @example
     * // Update or create a CampaignConfig
     * const campaignConfig = await prisma.campaignConfig.upsert({
     *   create: {
     *     // ... data to create a CampaignConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CampaignConfig we want to update
     *   }
     * })
     */
    upsert<T extends CampaignConfigUpsertArgs>(args: SelectSubset<T, CampaignConfigUpsertArgs<ExtArgs>>): Prisma__CampaignConfigClient<$Result.GetResult<Prisma.$CampaignConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CampaignConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignConfigCountArgs} args - Arguments to filter CampaignConfigs to count.
     * @example
     * // Count the number of CampaignConfigs
     * const count = await prisma.campaignConfig.count({
     *   where: {
     *     // ... the filter for the CampaignConfigs we want to count
     *   }
     * })
    **/
    count<T extends CampaignConfigCountArgs>(
      args?: Subset<T, CampaignConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CampaignConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CampaignConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CampaignConfigAggregateArgs>(args: Subset<T, CampaignConfigAggregateArgs>): Prisma.PrismaPromise<GetCampaignConfigAggregateType<T>>

    /**
     * Group by CampaignConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CampaignConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CampaignConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CampaignConfigGroupByArgs['orderBy'] }
        : { orderBy?: CampaignConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CampaignConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCampaignConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CampaignConfig model
   */
  readonly fields: CampaignConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CampaignConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CampaignConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CampaignConfig model
   */
  interface CampaignConfigFieldRefs {
    readonly id: FieldRef<"CampaignConfig", 'String'>
    readonly name: FieldRef<"CampaignConfig", 'String'>
    readonly description: FieldRef<"CampaignConfig", 'String'>
    readonly tokenMint: FieldRef<"CampaignConfig", 'String'>
    readonly totalAllocation: FieldRef<"CampaignConfig", 'BigInt'>
    readonly startDate: FieldRef<"CampaignConfig", 'DateTime'>
    readonly endDate: FieldRef<"CampaignConfig", 'DateTime'>
    readonly eligibilityCriteria: FieldRef<"CampaignConfig", 'Json'>
    readonly distributionRules: FieldRef<"CampaignConfig", 'Json'>
    readonly isActive: FieldRef<"CampaignConfig", 'Boolean'>
    readonly createdBy: FieldRef<"CampaignConfig", 'String'>
    readonly createdAt: FieldRef<"CampaignConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"CampaignConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CampaignConfig findUnique
   */
  export type CampaignConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignConfig
     */
    select?: CampaignConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignConfig
     */
    omit?: CampaignConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignConfigInclude<ExtArgs> | null
    /**
     * Filter, which CampaignConfig to fetch.
     */
    where: CampaignConfigWhereUniqueInput
  }

  /**
   * CampaignConfig findUniqueOrThrow
   */
  export type CampaignConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignConfig
     */
    select?: CampaignConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignConfig
     */
    omit?: CampaignConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignConfigInclude<ExtArgs> | null
    /**
     * Filter, which CampaignConfig to fetch.
     */
    where: CampaignConfigWhereUniqueInput
  }

  /**
   * CampaignConfig findFirst
   */
  export type CampaignConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignConfig
     */
    select?: CampaignConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignConfig
     */
    omit?: CampaignConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignConfigInclude<ExtArgs> | null
    /**
     * Filter, which CampaignConfig to fetch.
     */
    where?: CampaignConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignConfigs to fetch.
     */
    orderBy?: CampaignConfigOrderByWithRelationInput | CampaignConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignConfigs.
     */
    cursor?: CampaignConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignConfigs.
     */
    distinct?: CampaignConfigScalarFieldEnum | CampaignConfigScalarFieldEnum[]
  }

  /**
   * CampaignConfig findFirstOrThrow
   */
  export type CampaignConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignConfig
     */
    select?: CampaignConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignConfig
     */
    omit?: CampaignConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignConfigInclude<ExtArgs> | null
    /**
     * Filter, which CampaignConfig to fetch.
     */
    where?: CampaignConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignConfigs to fetch.
     */
    orderBy?: CampaignConfigOrderByWithRelationInput | CampaignConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CampaignConfigs.
     */
    cursor?: CampaignConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CampaignConfigs.
     */
    distinct?: CampaignConfigScalarFieldEnum | CampaignConfigScalarFieldEnum[]
  }

  /**
   * CampaignConfig findMany
   */
  export type CampaignConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignConfig
     */
    select?: CampaignConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignConfig
     */
    omit?: CampaignConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignConfigInclude<ExtArgs> | null
    /**
     * Filter, which CampaignConfigs to fetch.
     */
    where?: CampaignConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CampaignConfigs to fetch.
     */
    orderBy?: CampaignConfigOrderByWithRelationInput | CampaignConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CampaignConfigs.
     */
    cursor?: CampaignConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CampaignConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CampaignConfigs.
     */
    skip?: number
    distinct?: CampaignConfigScalarFieldEnum | CampaignConfigScalarFieldEnum[]
  }

  /**
   * CampaignConfig create
   */
  export type CampaignConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignConfig
     */
    select?: CampaignConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignConfig
     */
    omit?: CampaignConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a CampaignConfig.
     */
    data: XOR<CampaignConfigCreateInput, CampaignConfigUncheckedCreateInput>
  }

  /**
   * CampaignConfig createMany
   */
  export type CampaignConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CampaignConfigs.
     */
    data: CampaignConfigCreateManyInput | CampaignConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CampaignConfig createManyAndReturn
   */
  export type CampaignConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignConfig
     */
    select?: CampaignConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignConfig
     */
    omit?: CampaignConfigOmit<ExtArgs> | null
    /**
     * The data used to create many CampaignConfigs.
     */
    data: CampaignConfigCreateManyInput | CampaignConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignConfig update
   */
  export type CampaignConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignConfig
     */
    select?: CampaignConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignConfig
     */
    omit?: CampaignConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a CampaignConfig.
     */
    data: XOR<CampaignConfigUpdateInput, CampaignConfigUncheckedUpdateInput>
    /**
     * Choose, which CampaignConfig to update.
     */
    where: CampaignConfigWhereUniqueInput
  }

  /**
   * CampaignConfig updateMany
   */
  export type CampaignConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CampaignConfigs.
     */
    data: XOR<CampaignConfigUpdateManyMutationInput, CampaignConfigUncheckedUpdateManyInput>
    /**
     * Filter which CampaignConfigs to update
     */
    where?: CampaignConfigWhereInput
    /**
     * Limit how many CampaignConfigs to update.
     */
    limit?: number
  }

  /**
   * CampaignConfig updateManyAndReturn
   */
  export type CampaignConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignConfig
     */
    select?: CampaignConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignConfig
     */
    omit?: CampaignConfigOmit<ExtArgs> | null
    /**
     * The data used to update CampaignConfigs.
     */
    data: XOR<CampaignConfigUpdateManyMutationInput, CampaignConfigUncheckedUpdateManyInput>
    /**
     * Filter which CampaignConfigs to update
     */
    where?: CampaignConfigWhereInput
    /**
     * Limit how many CampaignConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CampaignConfig upsert
   */
  export type CampaignConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignConfig
     */
    select?: CampaignConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignConfig
     */
    omit?: CampaignConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the CampaignConfig to update in case it exists.
     */
    where: CampaignConfigWhereUniqueInput
    /**
     * In case the CampaignConfig found by the `where` argument doesn't exist, create a new CampaignConfig with this data.
     */
    create: XOR<CampaignConfigCreateInput, CampaignConfigUncheckedCreateInput>
    /**
     * In case the CampaignConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CampaignConfigUpdateInput, CampaignConfigUncheckedUpdateInput>
  }

  /**
   * CampaignConfig delete
   */
  export type CampaignConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignConfig
     */
    select?: CampaignConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignConfig
     */
    omit?: CampaignConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignConfigInclude<ExtArgs> | null
    /**
     * Filter which CampaignConfig to delete.
     */
    where: CampaignConfigWhereUniqueInput
  }

  /**
   * CampaignConfig deleteMany
   */
  export type CampaignConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CampaignConfigs to delete
     */
    where?: CampaignConfigWhereInput
    /**
     * Limit how many CampaignConfigs to delete.
     */
    limit?: number
  }

  /**
   * CampaignConfig without action
   */
  export type CampaignConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CampaignConfig
     */
    select?: CampaignConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CampaignConfig
     */
    omit?: CampaignConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CampaignConfigInclude<ExtArgs> | null
  }


  /**
   * Model TaskCompletion
   */

  export type AggregateTaskCompletion = {
    _count: TaskCompletionCountAggregateOutputType | null
    _avg: TaskCompletionAvgAggregateOutputType | null
    _sum: TaskCompletionSumAggregateOutputType | null
    _min: TaskCompletionMinAggregateOutputType | null
    _max: TaskCompletionMaxAggregateOutputType | null
  }

  export type TaskCompletionAvgAggregateOutputType = {
    points: number | null
  }

  export type TaskCompletionSumAggregateOutputType = {
    points: number | null
  }

  export type TaskCompletionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    taskId: string | null
    completed: boolean | null
    points: number | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type TaskCompletionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    taskId: string | null
    completed: boolean | null
    points: number | null
    completedAt: Date | null
    createdAt: Date | null
  }

  export type TaskCompletionCountAggregateOutputType = {
    id: number
    userId: number
    taskId: number
    completed: number
    points: number
    metadata: number
    completedAt: number
    createdAt: number
    _all: number
  }


  export type TaskCompletionAvgAggregateInputType = {
    points?: true
  }

  export type TaskCompletionSumAggregateInputType = {
    points?: true
  }

  export type TaskCompletionMinAggregateInputType = {
    id?: true
    userId?: true
    taskId?: true
    completed?: true
    points?: true
    completedAt?: true
    createdAt?: true
  }

  export type TaskCompletionMaxAggregateInputType = {
    id?: true
    userId?: true
    taskId?: true
    completed?: true
    points?: true
    completedAt?: true
    createdAt?: true
  }

  export type TaskCompletionCountAggregateInputType = {
    id?: true
    userId?: true
    taskId?: true
    completed?: true
    points?: true
    metadata?: true
    completedAt?: true
    createdAt?: true
    _all?: true
  }

  export type TaskCompletionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskCompletion to aggregate.
     */
    where?: TaskCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCompletions to fetch.
     */
    orderBy?: TaskCompletionOrderByWithRelationInput | TaskCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskCompletions
    **/
    _count?: true | TaskCompletionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskCompletionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskCompletionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskCompletionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskCompletionMaxAggregateInputType
  }

  export type GetTaskCompletionAggregateType<T extends TaskCompletionAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskCompletion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskCompletion[P]>
      : GetScalarType<T[P], AggregateTaskCompletion[P]>
  }




  export type TaskCompletionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskCompletionWhereInput
    orderBy?: TaskCompletionOrderByWithAggregationInput | TaskCompletionOrderByWithAggregationInput[]
    by: TaskCompletionScalarFieldEnum[] | TaskCompletionScalarFieldEnum
    having?: TaskCompletionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCompletionCountAggregateInputType | true
    _avg?: TaskCompletionAvgAggregateInputType
    _sum?: TaskCompletionSumAggregateInputType
    _min?: TaskCompletionMinAggregateInputType
    _max?: TaskCompletionMaxAggregateInputType
  }

  export type TaskCompletionGroupByOutputType = {
    id: string
    userId: string
    taskId: string
    completed: boolean
    points: number
    metadata: JsonValue | null
    completedAt: Date | null
    createdAt: Date
    _count: TaskCompletionCountAggregateOutputType | null
    _avg: TaskCompletionAvgAggregateOutputType | null
    _sum: TaskCompletionSumAggregateOutputType | null
    _min: TaskCompletionMinAggregateOutputType | null
    _max: TaskCompletionMaxAggregateOutputType | null
  }

  type GetTaskCompletionGroupByPayload<T extends TaskCompletionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskCompletionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskCompletionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskCompletionGroupByOutputType[P]>
            : GetScalarType<T[P], TaskCompletionGroupByOutputType[P]>
        }
      >
    >


  export type TaskCompletionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    taskId?: boolean
    completed?: boolean
    points?: boolean
    metadata?: boolean
    completedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskCompletion"]>

  export type TaskCompletionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    taskId?: boolean
    completed?: boolean
    points?: boolean
    metadata?: boolean
    completedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskCompletion"]>

  export type TaskCompletionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    taskId?: boolean
    completed?: boolean
    points?: boolean
    metadata?: boolean
    completedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskCompletion"]>

  export type TaskCompletionSelectScalar = {
    id?: boolean
    userId?: boolean
    taskId?: boolean
    completed?: boolean
    points?: boolean
    metadata?: boolean
    completedAt?: boolean
    createdAt?: boolean
  }

  export type TaskCompletionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "taskId" | "completed" | "points" | "metadata" | "completedAt" | "createdAt", ExtArgs["result"]["taskCompletion"]>
  export type TaskCompletionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskCompletionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskCompletionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $TaskCompletionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskCompletion"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      taskId: string
      completed: boolean
      points: number
      metadata: Prisma.JsonValue | null
      completedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["taskCompletion"]>
    composites: {}
  }

  type TaskCompletionGetPayload<S extends boolean | null | undefined | TaskCompletionDefaultArgs> = $Result.GetResult<Prisma.$TaskCompletionPayload, S>

  type TaskCompletionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskCompletionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCompletionCountAggregateInputType | true
    }

  export interface TaskCompletionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskCompletion'], meta: { name: 'TaskCompletion' } }
    /**
     * Find zero or one TaskCompletion that matches the filter.
     * @param {TaskCompletionFindUniqueArgs} args - Arguments to find a TaskCompletion
     * @example
     * // Get one TaskCompletion
     * const taskCompletion = await prisma.taskCompletion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskCompletionFindUniqueArgs>(args: SelectSubset<T, TaskCompletionFindUniqueArgs<ExtArgs>>): Prisma__TaskCompletionClient<$Result.GetResult<Prisma.$TaskCompletionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskCompletion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskCompletionFindUniqueOrThrowArgs} args - Arguments to find a TaskCompletion
     * @example
     * // Get one TaskCompletion
     * const taskCompletion = await prisma.taskCompletion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskCompletionFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskCompletionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskCompletionClient<$Result.GetResult<Prisma.$TaskCompletionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskCompletion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCompletionFindFirstArgs} args - Arguments to find a TaskCompletion
     * @example
     * // Get one TaskCompletion
     * const taskCompletion = await prisma.taskCompletion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskCompletionFindFirstArgs>(args?: SelectSubset<T, TaskCompletionFindFirstArgs<ExtArgs>>): Prisma__TaskCompletionClient<$Result.GetResult<Prisma.$TaskCompletionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskCompletion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCompletionFindFirstOrThrowArgs} args - Arguments to find a TaskCompletion
     * @example
     * // Get one TaskCompletion
     * const taskCompletion = await prisma.taskCompletion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskCompletionFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskCompletionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskCompletionClient<$Result.GetResult<Prisma.$TaskCompletionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskCompletions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCompletionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskCompletions
     * const taskCompletions = await prisma.taskCompletion.findMany()
     * 
     * // Get first 10 TaskCompletions
     * const taskCompletions = await prisma.taskCompletion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskCompletionWithIdOnly = await prisma.taskCompletion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskCompletionFindManyArgs>(args?: SelectSubset<T, TaskCompletionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCompletionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskCompletion.
     * @param {TaskCompletionCreateArgs} args - Arguments to create a TaskCompletion.
     * @example
     * // Create one TaskCompletion
     * const TaskCompletion = await prisma.taskCompletion.create({
     *   data: {
     *     // ... data to create a TaskCompletion
     *   }
     * })
     * 
     */
    create<T extends TaskCompletionCreateArgs>(args: SelectSubset<T, TaskCompletionCreateArgs<ExtArgs>>): Prisma__TaskCompletionClient<$Result.GetResult<Prisma.$TaskCompletionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskCompletions.
     * @param {TaskCompletionCreateManyArgs} args - Arguments to create many TaskCompletions.
     * @example
     * // Create many TaskCompletions
     * const taskCompletion = await prisma.taskCompletion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCompletionCreateManyArgs>(args?: SelectSubset<T, TaskCompletionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskCompletions and returns the data saved in the database.
     * @param {TaskCompletionCreateManyAndReturnArgs} args - Arguments to create many TaskCompletions.
     * @example
     * // Create many TaskCompletions
     * const taskCompletion = await prisma.taskCompletion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskCompletions and only return the `id`
     * const taskCompletionWithIdOnly = await prisma.taskCompletion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCompletionCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCompletionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCompletionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskCompletion.
     * @param {TaskCompletionDeleteArgs} args - Arguments to delete one TaskCompletion.
     * @example
     * // Delete one TaskCompletion
     * const TaskCompletion = await prisma.taskCompletion.delete({
     *   where: {
     *     // ... filter to delete one TaskCompletion
     *   }
     * })
     * 
     */
    delete<T extends TaskCompletionDeleteArgs>(args: SelectSubset<T, TaskCompletionDeleteArgs<ExtArgs>>): Prisma__TaskCompletionClient<$Result.GetResult<Prisma.$TaskCompletionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskCompletion.
     * @param {TaskCompletionUpdateArgs} args - Arguments to update one TaskCompletion.
     * @example
     * // Update one TaskCompletion
     * const taskCompletion = await prisma.taskCompletion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskCompletionUpdateArgs>(args: SelectSubset<T, TaskCompletionUpdateArgs<ExtArgs>>): Prisma__TaskCompletionClient<$Result.GetResult<Prisma.$TaskCompletionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskCompletions.
     * @param {TaskCompletionDeleteManyArgs} args - Arguments to filter TaskCompletions to delete.
     * @example
     * // Delete a few TaskCompletions
     * const { count } = await prisma.taskCompletion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskCompletionDeleteManyArgs>(args?: SelectSubset<T, TaskCompletionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCompletionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskCompletions
     * const taskCompletion = await prisma.taskCompletion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskCompletionUpdateManyArgs>(args: SelectSubset<T, TaskCompletionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskCompletions and returns the data updated in the database.
     * @param {TaskCompletionUpdateManyAndReturnArgs} args - Arguments to update many TaskCompletions.
     * @example
     * // Update many TaskCompletions
     * const taskCompletion = await prisma.taskCompletion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskCompletions and only return the `id`
     * const taskCompletionWithIdOnly = await prisma.taskCompletion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskCompletionUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskCompletionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskCompletionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskCompletion.
     * @param {TaskCompletionUpsertArgs} args - Arguments to update or create a TaskCompletion.
     * @example
     * // Update or create a TaskCompletion
     * const taskCompletion = await prisma.taskCompletion.upsert({
     *   create: {
     *     // ... data to create a TaskCompletion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskCompletion we want to update
     *   }
     * })
     */
    upsert<T extends TaskCompletionUpsertArgs>(args: SelectSubset<T, TaskCompletionUpsertArgs<ExtArgs>>): Prisma__TaskCompletionClient<$Result.GetResult<Prisma.$TaskCompletionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCompletionCountArgs} args - Arguments to filter TaskCompletions to count.
     * @example
     * // Count the number of TaskCompletions
     * const count = await prisma.taskCompletion.count({
     *   where: {
     *     // ... the filter for the TaskCompletions we want to count
     *   }
     * })
    **/
    count<T extends TaskCompletionCountArgs>(
      args?: Subset<T, TaskCompletionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCompletionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCompletionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskCompletionAggregateArgs>(args: Subset<T, TaskCompletionAggregateArgs>): Prisma.PrismaPromise<GetTaskCompletionAggregateType<T>>

    /**
     * Group by TaskCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCompletionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskCompletionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskCompletionGroupByArgs['orderBy'] }
        : { orderBy?: TaskCompletionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskCompletionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskCompletionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskCompletion model
   */
  readonly fields: TaskCompletionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskCompletion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskCompletionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskCompletion model
   */
  interface TaskCompletionFieldRefs {
    readonly id: FieldRef<"TaskCompletion", 'String'>
    readonly userId: FieldRef<"TaskCompletion", 'String'>
    readonly taskId: FieldRef<"TaskCompletion", 'String'>
    readonly completed: FieldRef<"TaskCompletion", 'Boolean'>
    readonly points: FieldRef<"TaskCompletion", 'Int'>
    readonly metadata: FieldRef<"TaskCompletion", 'Json'>
    readonly completedAt: FieldRef<"TaskCompletion", 'DateTime'>
    readonly createdAt: FieldRef<"TaskCompletion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TaskCompletion findUnique
   */
  export type TaskCompletionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletion
     */
    select?: TaskCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletion
     */
    omit?: TaskCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionInclude<ExtArgs> | null
    /**
     * Filter, which TaskCompletion to fetch.
     */
    where: TaskCompletionWhereUniqueInput
  }

  /**
   * TaskCompletion findUniqueOrThrow
   */
  export type TaskCompletionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletion
     */
    select?: TaskCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletion
     */
    omit?: TaskCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionInclude<ExtArgs> | null
    /**
     * Filter, which TaskCompletion to fetch.
     */
    where: TaskCompletionWhereUniqueInput
  }

  /**
   * TaskCompletion findFirst
   */
  export type TaskCompletionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletion
     */
    select?: TaskCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletion
     */
    omit?: TaskCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionInclude<ExtArgs> | null
    /**
     * Filter, which TaskCompletion to fetch.
     */
    where?: TaskCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCompletions to fetch.
     */
    orderBy?: TaskCompletionOrderByWithRelationInput | TaskCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskCompletions.
     */
    cursor?: TaskCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskCompletions.
     */
    distinct?: TaskCompletionScalarFieldEnum | TaskCompletionScalarFieldEnum[]
  }

  /**
   * TaskCompletion findFirstOrThrow
   */
  export type TaskCompletionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletion
     */
    select?: TaskCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletion
     */
    omit?: TaskCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionInclude<ExtArgs> | null
    /**
     * Filter, which TaskCompletion to fetch.
     */
    where?: TaskCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCompletions to fetch.
     */
    orderBy?: TaskCompletionOrderByWithRelationInput | TaskCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskCompletions.
     */
    cursor?: TaskCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskCompletions.
     */
    distinct?: TaskCompletionScalarFieldEnum | TaskCompletionScalarFieldEnum[]
  }

  /**
   * TaskCompletion findMany
   */
  export type TaskCompletionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletion
     */
    select?: TaskCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletion
     */
    omit?: TaskCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionInclude<ExtArgs> | null
    /**
     * Filter, which TaskCompletions to fetch.
     */
    where?: TaskCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskCompletions to fetch.
     */
    orderBy?: TaskCompletionOrderByWithRelationInput | TaskCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskCompletions.
     */
    cursor?: TaskCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskCompletions.
     */
    skip?: number
    distinct?: TaskCompletionScalarFieldEnum | TaskCompletionScalarFieldEnum[]
  }

  /**
   * TaskCompletion create
   */
  export type TaskCompletionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletion
     */
    select?: TaskCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletion
     */
    omit?: TaskCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskCompletion.
     */
    data: XOR<TaskCompletionCreateInput, TaskCompletionUncheckedCreateInput>
  }

  /**
   * TaskCompletion createMany
   */
  export type TaskCompletionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskCompletions.
     */
    data: TaskCompletionCreateManyInput | TaskCompletionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaskCompletion createManyAndReturn
   */
  export type TaskCompletionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletion
     */
    select?: TaskCompletionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletion
     */
    omit?: TaskCompletionOmit<ExtArgs> | null
    /**
     * The data used to create many TaskCompletions.
     */
    data: TaskCompletionCreateManyInput | TaskCompletionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskCompletion update
   */
  export type TaskCompletionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletion
     */
    select?: TaskCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletion
     */
    omit?: TaskCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskCompletion.
     */
    data: XOR<TaskCompletionUpdateInput, TaskCompletionUncheckedUpdateInput>
    /**
     * Choose, which TaskCompletion to update.
     */
    where: TaskCompletionWhereUniqueInput
  }

  /**
   * TaskCompletion updateMany
   */
  export type TaskCompletionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskCompletions.
     */
    data: XOR<TaskCompletionUpdateManyMutationInput, TaskCompletionUncheckedUpdateManyInput>
    /**
     * Filter which TaskCompletions to update
     */
    where?: TaskCompletionWhereInput
    /**
     * Limit how many TaskCompletions to update.
     */
    limit?: number
  }

  /**
   * TaskCompletion updateManyAndReturn
   */
  export type TaskCompletionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletion
     */
    select?: TaskCompletionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletion
     */
    omit?: TaskCompletionOmit<ExtArgs> | null
    /**
     * The data used to update TaskCompletions.
     */
    data: XOR<TaskCompletionUpdateManyMutationInput, TaskCompletionUncheckedUpdateManyInput>
    /**
     * Filter which TaskCompletions to update
     */
    where?: TaskCompletionWhereInput
    /**
     * Limit how many TaskCompletions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskCompletion upsert
   */
  export type TaskCompletionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletion
     */
    select?: TaskCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletion
     */
    omit?: TaskCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskCompletion to update in case it exists.
     */
    where: TaskCompletionWhereUniqueInput
    /**
     * In case the TaskCompletion found by the `where` argument doesn't exist, create a new TaskCompletion with this data.
     */
    create: XOR<TaskCompletionCreateInput, TaskCompletionUncheckedCreateInput>
    /**
     * In case the TaskCompletion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskCompletionUpdateInput, TaskCompletionUncheckedUpdateInput>
  }

  /**
   * TaskCompletion delete
   */
  export type TaskCompletionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletion
     */
    select?: TaskCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletion
     */
    omit?: TaskCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionInclude<ExtArgs> | null
    /**
     * Filter which TaskCompletion to delete.
     */
    where: TaskCompletionWhereUniqueInput
  }

  /**
   * TaskCompletion deleteMany
   */
  export type TaskCompletionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskCompletions to delete
     */
    where?: TaskCompletionWhereInput
    /**
     * Limit how many TaskCompletions to delete.
     */
    limit?: number
  }

  /**
   * TaskCompletion without action
   */
  export type TaskCompletionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCompletion
     */
    select?: TaskCompletionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskCompletion
     */
    omit?: TaskCompletionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskCompletionInclude<ExtArgs> | null
  }


  /**
   * Model Claim
   */

  export type AggregateClaim = {
    _count: ClaimCountAggregateOutputType | null
    _avg: ClaimAvgAggregateOutputType | null
    _sum: ClaimSumAggregateOutputType | null
    _min: ClaimMinAggregateOutputType | null
    _max: ClaimMaxAggregateOutputType | null
  }

  export type ClaimAvgAggregateOutputType = {
    amount: number | null
    feesPaid: Decimal | null
  }

  export type ClaimSumAggregateOutputType = {
    amount: number | null
    feesPaid: Decimal | null
  }

  export type ClaimMinAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    transactionHash: string | null
    status: $Enums.ClaimStatus | null
    paymentMethod: $Enums.PaymentMethod | null
    processedAt: Date | null
    feesPaid: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    type: string | null
    userTier: string | null
  }

  export type ClaimMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    transactionHash: string | null
    status: $Enums.ClaimStatus | null
    paymentMethod: $Enums.PaymentMethod | null
    processedAt: Date | null
    feesPaid: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    type: string | null
    userTier: string | null
  }

  export type ClaimCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    transactionHash: number
    status: number
    paymentMethod: number
    metadata: number
    processedAt: number
    feesPaid: number
    createdAt: number
    updatedAt: number
    type: number
    nftPasses: number
    userTier: number
    _all: number
  }


  export type ClaimAvgAggregateInputType = {
    amount?: true
    feesPaid?: true
  }

  export type ClaimSumAggregateInputType = {
    amount?: true
    feesPaid?: true
  }

  export type ClaimMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    transactionHash?: true
    status?: true
    paymentMethod?: true
    processedAt?: true
    feesPaid?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    userTier?: true
  }

  export type ClaimMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    transactionHash?: true
    status?: true
    paymentMethod?: true
    processedAt?: true
    feesPaid?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    userTier?: true
  }

  export type ClaimCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    transactionHash?: true
    status?: true
    paymentMethod?: true
    metadata?: true
    processedAt?: true
    feesPaid?: true
    createdAt?: true
    updatedAt?: true
    type?: true
    nftPasses?: true
    userTier?: true
    _all?: true
  }

  export type ClaimAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Claim to aggregate.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Claims
    **/
    _count?: true | ClaimCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClaimAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClaimSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClaimMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClaimMaxAggregateInputType
  }

  export type GetClaimAggregateType<T extends ClaimAggregateArgs> = {
        [P in keyof T & keyof AggregateClaim]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClaim[P]>
      : GetScalarType<T[P], AggregateClaim[P]>
  }




  export type ClaimGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClaimWhereInput
    orderBy?: ClaimOrderByWithAggregationInput | ClaimOrderByWithAggregationInput[]
    by: ClaimScalarFieldEnum[] | ClaimScalarFieldEnum
    having?: ClaimScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClaimCountAggregateInputType | true
    _avg?: ClaimAvgAggregateInputType
    _sum?: ClaimSumAggregateInputType
    _min?: ClaimMinAggregateInputType
    _max?: ClaimMaxAggregateInputType
  }

  export type ClaimGroupByOutputType = {
    id: string
    userId: string
    amount: number
    transactionHash: string | null
    status: $Enums.ClaimStatus
    paymentMethod: $Enums.PaymentMethod
    metadata: JsonValue | null
    processedAt: Date | null
    feesPaid: Decimal
    createdAt: Date
    updatedAt: Date
    type: string | null
    nftPasses: JsonValue | null
    userTier: string | null
    _count: ClaimCountAggregateOutputType | null
    _avg: ClaimAvgAggregateOutputType | null
    _sum: ClaimSumAggregateOutputType | null
    _min: ClaimMinAggregateOutputType | null
    _max: ClaimMaxAggregateOutputType | null
  }

  type GetClaimGroupByPayload<T extends ClaimGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClaimGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClaimGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClaimGroupByOutputType[P]>
            : GetScalarType<T[P], ClaimGroupByOutputType[P]>
        }
      >
    >


  export type ClaimSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    transactionHash?: boolean
    status?: boolean
    paymentMethod?: boolean
    metadata?: boolean
    processedAt?: boolean
    feesPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    nftPasses?: boolean
    userTier?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["claim"]>

  export type ClaimSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    transactionHash?: boolean
    status?: boolean
    paymentMethod?: boolean
    metadata?: boolean
    processedAt?: boolean
    feesPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    nftPasses?: boolean
    userTier?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["claim"]>

  export type ClaimSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    transactionHash?: boolean
    status?: boolean
    paymentMethod?: boolean
    metadata?: boolean
    processedAt?: boolean
    feesPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    nftPasses?: boolean
    userTier?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["claim"]>

  export type ClaimSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    transactionHash?: boolean
    status?: boolean
    paymentMethod?: boolean
    metadata?: boolean
    processedAt?: boolean
    feesPaid?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    type?: boolean
    nftPasses?: boolean
    userTier?: boolean
  }

  export type ClaimOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "amount" | "transactionHash" | "status" | "paymentMethod" | "metadata" | "processedAt" | "feesPaid" | "createdAt" | "updatedAt" | "type" | "nftPasses" | "userTier", ExtArgs["result"]["claim"]>
  export type ClaimInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClaimIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ClaimIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ClaimPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Claim"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      amount: number
      transactionHash: string | null
      status: $Enums.ClaimStatus
      paymentMethod: $Enums.PaymentMethod
      metadata: Prisma.JsonValue | null
      processedAt: Date | null
      feesPaid: Prisma.Decimal
      createdAt: Date
      updatedAt: Date
      type: string | null
      nftPasses: Prisma.JsonValue | null
      userTier: string | null
    }, ExtArgs["result"]["claim"]>
    composites: {}
  }

  type ClaimGetPayload<S extends boolean | null | undefined | ClaimDefaultArgs> = $Result.GetResult<Prisma.$ClaimPayload, S>

  type ClaimCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClaimFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClaimCountAggregateInputType | true
    }

  export interface ClaimDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Claim'], meta: { name: 'Claim' } }
    /**
     * Find zero or one Claim that matches the filter.
     * @param {ClaimFindUniqueArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClaimFindUniqueArgs>(args: SelectSubset<T, ClaimFindUniqueArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Claim that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClaimFindUniqueOrThrowArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClaimFindUniqueOrThrowArgs>(args: SelectSubset<T, ClaimFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Claim that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindFirstArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClaimFindFirstArgs>(args?: SelectSubset<T, ClaimFindFirstArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Claim that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindFirstOrThrowArgs} args - Arguments to find a Claim
     * @example
     * // Get one Claim
     * const claim = await prisma.claim.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClaimFindFirstOrThrowArgs>(args?: SelectSubset<T, ClaimFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Claims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Claims
     * const claims = await prisma.claim.findMany()
     * 
     * // Get first 10 Claims
     * const claims = await prisma.claim.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const claimWithIdOnly = await prisma.claim.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClaimFindManyArgs>(args?: SelectSubset<T, ClaimFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Claim.
     * @param {ClaimCreateArgs} args - Arguments to create a Claim.
     * @example
     * // Create one Claim
     * const Claim = await prisma.claim.create({
     *   data: {
     *     // ... data to create a Claim
     *   }
     * })
     * 
     */
    create<T extends ClaimCreateArgs>(args: SelectSubset<T, ClaimCreateArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Claims.
     * @param {ClaimCreateManyArgs} args - Arguments to create many Claims.
     * @example
     * // Create many Claims
     * const claim = await prisma.claim.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClaimCreateManyArgs>(args?: SelectSubset<T, ClaimCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Claims and returns the data saved in the database.
     * @param {ClaimCreateManyAndReturnArgs} args - Arguments to create many Claims.
     * @example
     * // Create many Claims
     * const claim = await prisma.claim.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Claims and only return the `id`
     * const claimWithIdOnly = await prisma.claim.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClaimCreateManyAndReturnArgs>(args?: SelectSubset<T, ClaimCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Claim.
     * @param {ClaimDeleteArgs} args - Arguments to delete one Claim.
     * @example
     * // Delete one Claim
     * const Claim = await prisma.claim.delete({
     *   where: {
     *     // ... filter to delete one Claim
     *   }
     * })
     * 
     */
    delete<T extends ClaimDeleteArgs>(args: SelectSubset<T, ClaimDeleteArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Claim.
     * @param {ClaimUpdateArgs} args - Arguments to update one Claim.
     * @example
     * // Update one Claim
     * const claim = await prisma.claim.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClaimUpdateArgs>(args: SelectSubset<T, ClaimUpdateArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Claims.
     * @param {ClaimDeleteManyArgs} args - Arguments to filter Claims to delete.
     * @example
     * // Delete a few Claims
     * const { count } = await prisma.claim.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClaimDeleteManyArgs>(args?: SelectSubset<T, ClaimDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Claims
     * const claim = await prisma.claim.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClaimUpdateManyArgs>(args: SelectSubset<T, ClaimUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Claims and returns the data updated in the database.
     * @param {ClaimUpdateManyAndReturnArgs} args - Arguments to update many Claims.
     * @example
     * // Update many Claims
     * const claim = await prisma.claim.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Claims and only return the `id`
     * const claimWithIdOnly = await prisma.claim.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClaimUpdateManyAndReturnArgs>(args: SelectSubset<T, ClaimUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Claim.
     * @param {ClaimUpsertArgs} args - Arguments to update or create a Claim.
     * @example
     * // Update or create a Claim
     * const claim = await prisma.claim.upsert({
     *   create: {
     *     // ... data to create a Claim
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Claim we want to update
     *   }
     * })
     */
    upsert<T extends ClaimUpsertArgs>(args: SelectSubset<T, ClaimUpsertArgs<ExtArgs>>): Prisma__ClaimClient<$Result.GetResult<Prisma.$ClaimPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimCountArgs} args - Arguments to filter Claims to count.
     * @example
     * // Count the number of Claims
     * const count = await prisma.claim.count({
     *   where: {
     *     // ... the filter for the Claims we want to count
     *   }
     * })
    **/
    count<T extends ClaimCountArgs>(
      args?: Subset<T, ClaimCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClaimCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Claim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClaimAggregateArgs>(args: Subset<T, ClaimAggregateArgs>): Prisma.PrismaPromise<GetClaimAggregateType<T>>

    /**
     * Group by Claim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClaimGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClaimGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClaimGroupByArgs['orderBy'] }
        : { orderBy?: ClaimGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClaimGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClaimGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Claim model
   */
  readonly fields: ClaimFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Claim.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClaimClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Claim model
   */
  interface ClaimFieldRefs {
    readonly id: FieldRef<"Claim", 'String'>
    readonly userId: FieldRef<"Claim", 'String'>
    readonly amount: FieldRef<"Claim", 'Float'>
    readonly transactionHash: FieldRef<"Claim", 'String'>
    readonly status: FieldRef<"Claim", 'ClaimStatus'>
    readonly paymentMethod: FieldRef<"Claim", 'PaymentMethod'>
    readonly metadata: FieldRef<"Claim", 'Json'>
    readonly processedAt: FieldRef<"Claim", 'DateTime'>
    readonly feesPaid: FieldRef<"Claim", 'Decimal'>
    readonly createdAt: FieldRef<"Claim", 'DateTime'>
    readonly updatedAt: FieldRef<"Claim", 'DateTime'>
    readonly type: FieldRef<"Claim", 'String'>
    readonly nftPasses: FieldRef<"Claim", 'Json'>
    readonly userTier: FieldRef<"Claim", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Claim findUnique
   */
  export type ClaimFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim findUniqueOrThrow
   */
  export type ClaimFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim findFirst
   */
  export type ClaimFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Claims.
     */
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Claim findFirstOrThrow
   */
  export type ClaimFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claim to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Claims.
     */
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Claim findMany
   */
  export type ClaimFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter, which Claims to fetch.
     */
    where?: ClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Claims to fetch.
     */
    orderBy?: ClaimOrderByWithRelationInput | ClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Claims.
     */
    cursor?: ClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Claims.
     */
    skip?: number
    distinct?: ClaimScalarFieldEnum | ClaimScalarFieldEnum[]
  }

  /**
   * Claim create
   */
  export type ClaimCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * The data needed to create a Claim.
     */
    data: XOR<ClaimCreateInput, ClaimUncheckedCreateInput>
  }

  /**
   * Claim createMany
   */
  export type ClaimCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Claims.
     */
    data: ClaimCreateManyInput | ClaimCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Claim createManyAndReturn
   */
  export type ClaimCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * The data used to create many Claims.
     */
    data: ClaimCreateManyInput | ClaimCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Claim update
   */
  export type ClaimUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * The data needed to update a Claim.
     */
    data: XOR<ClaimUpdateInput, ClaimUncheckedUpdateInput>
    /**
     * Choose, which Claim to update.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim updateMany
   */
  export type ClaimUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Claims.
     */
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyInput>
    /**
     * Filter which Claims to update
     */
    where?: ClaimWhereInput
    /**
     * Limit how many Claims to update.
     */
    limit?: number
  }

  /**
   * Claim updateManyAndReturn
   */
  export type ClaimUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * The data used to update Claims.
     */
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyInput>
    /**
     * Filter which Claims to update
     */
    where?: ClaimWhereInput
    /**
     * Limit how many Claims to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Claim upsert
   */
  export type ClaimUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * The filter to search for the Claim to update in case it exists.
     */
    where: ClaimWhereUniqueInput
    /**
     * In case the Claim found by the `where` argument doesn't exist, create a new Claim with this data.
     */
    create: XOR<ClaimCreateInput, ClaimUncheckedCreateInput>
    /**
     * In case the Claim was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClaimUpdateInput, ClaimUncheckedUpdateInput>
  }

  /**
   * Claim delete
   */
  export type ClaimDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
    /**
     * Filter which Claim to delete.
     */
    where: ClaimWhereUniqueInput
  }

  /**
   * Claim deleteMany
   */
  export type ClaimDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Claims to delete
     */
    where?: ClaimWhereInput
    /**
     * Limit how many Claims to delete.
     */
    limit?: number
  }

  /**
   * Claim without action
   */
  export type ClaimDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Claim
     */
    select?: ClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Claim
     */
    omit?: ClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClaimInclude<ExtArgs> | null
  }


  /**
   * Model PointHistory
   */

  export type AggregatePointHistory = {
    _count: PointHistoryCountAggregateOutputType | null
    _avg: PointHistoryAvgAggregateOutputType | null
    _sum: PointHistorySumAggregateOutputType | null
    _min: PointHistoryMinAggregateOutputType | null
    _max: PointHistoryMaxAggregateOutputType | null
  }

  export type PointHistoryAvgAggregateOutputType = {
    points: number | null
  }

  export type PointHistorySumAggregateOutputType = {
    points: number | null
  }

  export type PointHistoryMinAggregateOutputType = {
    id: string | null
    userId: string | null
    points: number | null
    action: string | null
    description: string | null
    createdAt: Date | null
  }

  export type PointHistoryMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    points: number | null
    action: string | null
    description: string | null
    createdAt: Date | null
  }

  export type PointHistoryCountAggregateOutputType = {
    id: number
    userId: number
    points: number
    action: number
    description: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type PointHistoryAvgAggregateInputType = {
    points?: true
  }

  export type PointHistorySumAggregateInputType = {
    points?: true
  }

  export type PointHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    points?: true
    action?: true
    description?: true
    createdAt?: true
  }

  export type PointHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    points?: true
    action?: true
    description?: true
    createdAt?: true
  }

  export type PointHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    points?: true
    action?: true
    description?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type PointHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointHistory to aggregate.
     */
    where?: PointHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointHistories to fetch.
     */
    orderBy?: PointHistoryOrderByWithRelationInput | PointHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PointHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PointHistories
    **/
    _count?: true | PointHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PointHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PointHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PointHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PointHistoryMaxAggregateInputType
  }

  export type GetPointHistoryAggregateType<T extends PointHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePointHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePointHistory[P]>
      : GetScalarType<T[P], AggregatePointHistory[P]>
  }




  export type PointHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PointHistoryWhereInput
    orderBy?: PointHistoryOrderByWithAggregationInput | PointHistoryOrderByWithAggregationInput[]
    by: PointHistoryScalarFieldEnum[] | PointHistoryScalarFieldEnum
    having?: PointHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PointHistoryCountAggregateInputType | true
    _avg?: PointHistoryAvgAggregateInputType
    _sum?: PointHistorySumAggregateInputType
    _min?: PointHistoryMinAggregateInputType
    _max?: PointHistoryMaxAggregateInputType
  }

  export type PointHistoryGroupByOutputType = {
    id: string
    userId: string
    points: number
    action: string
    description: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: PointHistoryCountAggregateOutputType | null
    _avg: PointHistoryAvgAggregateOutputType | null
    _sum: PointHistorySumAggregateOutputType | null
    _min: PointHistoryMinAggregateOutputType | null
    _max: PointHistoryMaxAggregateOutputType | null
  }

  type GetPointHistoryGroupByPayload<T extends PointHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PointHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PointHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PointHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PointHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PointHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    points?: boolean
    action?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointHistory"]>

  export type PointHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    points?: boolean
    action?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointHistory"]>

  export type PointHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    points?: boolean
    action?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pointHistory"]>

  export type PointHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    points?: boolean
    action?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type PointHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "points" | "action" | "description" | "metadata" | "createdAt", ExtArgs["result"]["pointHistory"]>
  export type PointHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PointHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PointHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PointHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PointHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      points: number
      action: string
      description: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["pointHistory"]>
    composites: {}
  }

  type PointHistoryGetPayload<S extends boolean | null | undefined | PointHistoryDefaultArgs> = $Result.GetResult<Prisma.$PointHistoryPayload, S>

  type PointHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PointHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PointHistoryCountAggregateInputType | true
    }

  export interface PointHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PointHistory'], meta: { name: 'PointHistory' } }
    /**
     * Find zero or one PointHistory that matches the filter.
     * @param {PointHistoryFindUniqueArgs} args - Arguments to find a PointHistory
     * @example
     * // Get one PointHistory
     * const pointHistory = await prisma.pointHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PointHistoryFindUniqueArgs>(args: SelectSubset<T, PointHistoryFindUniqueArgs<ExtArgs>>): Prisma__PointHistoryClient<$Result.GetResult<Prisma.$PointHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PointHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PointHistoryFindUniqueOrThrowArgs} args - Arguments to find a PointHistory
     * @example
     * // Get one PointHistory
     * const pointHistory = await prisma.pointHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PointHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PointHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PointHistoryClient<$Result.GetResult<Prisma.$PointHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PointHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointHistoryFindFirstArgs} args - Arguments to find a PointHistory
     * @example
     * // Get one PointHistory
     * const pointHistory = await prisma.pointHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PointHistoryFindFirstArgs>(args?: SelectSubset<T, PointHistoryFindFirstArgs<ExtArgs>>): Prisma__PointHistoryClient<$Result.GetResult<Prisma.$PointHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PointHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointHistoryFindFirstOrThrowArgs} args - Arguments to find a PointHistory
     * @example
     * // Get one PointHistory
     * const pointHistory = await prisma.pointHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PointHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PointHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PointHistoryClient<$Result.GetResult<Prisma.$PointHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PointHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PointHistories
     * const pointHistories = await prisma.pointHistory.findMany()
     * 
     * // Get first 10 PointHistories
     * const pointHistories = await prisma.pointHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pointHistoryWithIdOnly = await prisma.pointHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PointHistoryFindManyArgs>(args?: SelectSubset<T, PointHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PointHistory.
     * @param {PointHistoryCreateArgs} args - Arguments to create a PointHistory.
     * @example
     * // Create one PointHistory
     * const PointHistory = await prisma.pointHistory.create({
     *   data: {
     *     // ... data to create a PointHistory
     *   }
     * })
     * 
     */
    create<T extends PointHistoryCreateArgs>(args: SelectSubset<T, PointHistoryCreateArgs<ExtArgs>>): Prisma__PointHistoryClient<$Result.GetResult<Prisma.$PointHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PointHistories.
     * @param {PointHistoryCreateManyArgs} args - Arguments to create many PointHistories.
     * @example
     * // Create many PointHistories
     * const pointHistory = await prisma.pointHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PointHistoryCreateManyArgs>(args?: SelectSubset<T, PointHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PointHistories and returns the data saved in the database.
     * @param {PointHistoryCreateManyAndReturnArgs} args - Arguments to create many PointHistories.
     * @example
     * // Create many PointHistories
     * const pointHistory = await prisma.pointHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PointHistories and only return the `id`
     * const pointHistoryWithIdOnly = await prisma.pointHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PointHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, PointHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PointHistory.
     * @param {PointHistoryDeleteArgs} args - Arguments to delete one PointHistory.
     * @example
     * // Delete one PointHistory
     * const PointHistory = await prisma.pointHistory.delete({
     *   where: {
     *     // ... filter to delete one PointHistory
     *   }
     * })
     * 
     */
    delete<T extends PointHistoryDeleteArgs>(args: SelectSubset<T, PointHistoryDeleteArgs<ExtArgs>>): Prisma__PointHistoryClient<$Result.GetResult<Prisma.$PointHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PointHistory.
     * @param {PointHistoryUpdateArgs} args - Arguments to update one PointHistory.
     * @example
     * // Update one PointHistory
     * const pointHistory = await prisma.pointHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PointHistoryUpdateArgs>(args: SelectSubset<T, PointHistoryUpdateArgs<ExtArgs>>): Prisma__PointHistoryClient<$Result.GetResult<Prisma.$PointHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PointHistories.
     * @param {PointHistoryDeleteManyArgs} args - Arguments to filter PointHistories to delete.
     * @example
     * // Delete a few PointHistories
     * const { count } = await prisma.pointHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PointHistoryDeleteManyArgs>(args?: SelectSubset<T, PointHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PointHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PointHistories
     * const pointHistory = await prisma.pointHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PointHistoryUpdateManyArgs>(args: SelectSubset<T, PointHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PointHistories and returns the data updated in the database.
     * @param {PointHistoryUpdateManyAndReturnArgs} args - Arguments to update many PointHistories.
     * @example
     * // Update many PointHistories
     * const pointHistory = await prisma.pointHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PointHistories and only return the `id`
     * const pointHistoryWithIdOnly = await prisma.pointHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PointHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, PointHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PointHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PointHistory.
     * @param {PointHistoryUpsertArgs} args - Arguments to update or create a PointHistory.
     * @example
     * // Update or create a PointHistory
     * const pointHistory = await prisma.pointHistory.upsert({
     *   create: {
     *     // ... data to create a PointHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PointHistory we want to update
     *   }
     * })
     */
    upsert<T extends PointHistoryUpsertArgs>(args: SelectSubset<T, PointHistoryUpsertArgs<ExtArgs>>): Prisma__PointHistoryClient<$Result.GetResult<Prisma.$PointHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PointHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointHistoryCountArgs} args - Arguments to filter PointHistories to count.
     * @example
     * // Count the number of PointHistories
     * const count = await prisma.pointHistory.count({
     *   where: {
     *     // ... the filter for the PointHistories we want to count
     *   }
     * })
    **/
    count<T extends PointHistoryCountArgs>(
      args?: Subset<T, PointHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PointHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PointHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PointHistoryAggregateArgs>(args: Subset<T, PointHistoryAggregateArgs>): Prisma.PrismaPromise<GetPointHistoryAggregateType<T>>

    /**
     * Group by PointHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PointHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PointHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PointHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PointHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PointHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPointHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PointHistory model
   */
  readonly fields: PointHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PointHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PointHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PointHistory model
   */
  interface PointHistoryFieldRefs {
    readonly id: FieldRef<"PointHistory", 'String'>
    readonly userId: FieldRef<"PointHistory", 'String'>
    readonly points: FieldRef<"PointHistory", 'Int'>
    readonly action: FieldRef<"PointHistory", 'String'>
    readonly description: FieldRef<"PointHistory", 'String'>
    readonly metadata: FieldRef<"PointHistory", 'Json'>
    readonly createdAt: FieldRef<"PointHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PointHistory findUnique
   */
  export type PointHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PointHistory to fetch.
     */
    where: PointHistoryWhereUniqueInput
  }

  /**
   * PointHistory findUniqueOrThrow
   */
  export type PointHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PointHistory to fetch.
     */
    where: PointHistoryWhereUniqueInput
  }

  /**
   * PointHistory findFirst
   */
  export type PointHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PointHistory to fetch.
     */
    where?: PointHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointHistories to fetch.
     */
    orderBy?: PointHistoryOrderByWithRelationInput | PointHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointHistories.
     */
    cursor?: PointHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointHistories.
     */
    distinct?: PointHistoryScalarFieldEnum | PointHistoryScalarFieldEnum[]
  }

  /**
   * PointHistory findFirstOrThrow
   */
  export type PointHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PointHistory to fetch.
     */
    where?: PointHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointHistories to fetch.
     */
    orderBy?: PointHistoryOrderByWithRelationInput | PointHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PointHistories.
     */
    cursor?: PointHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PointHistories.
     */
    distinct?: PointHistoryScalarFieldEnum | PointHistoryScalarFieldEnum[]
  }

  /**
   * PointHistory findMany
   */
  export type PointHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PointHistories to fetch.
     */
    where?: PointHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PointHistories to fetch.
     */
    orderBy?: PointHistoryOrderByWithRelationInput | PointHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PointHistories.
     */
    cursor?: PointHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PointHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PointHistories.
     */
    skip?: number
    distinct?: PointHistoryScalarFieldEnum | PointHistoryScalarFieldEnum[]
  }

  /**
   * PointHistory create
   */
  export type PointHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PointHistory.
     */
    data: XOR<PointHistoryCreateInput, PointHistoryUncheckedCreateInput>
  }

  /**
   * PointHistory createMany
   */
  export type PointHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PointHistories.
     */
    data: PointHistoryCreateManyInput | PointHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PointHistory createManyAndReturn
   */
  export type PointHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many PointHistories.
     */
    data: PointHistoryCreateManyInput | PointHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PointHistory update
   */
  export type PointHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PointHistory.
     */
    data: XOR<PointHistoryUpdateInput, PointHistoryUncheckedUpdateInput>
    /**
     * Choose, which PointHistory to update.
     */
    where: PointHistoryWhereUniqueInput
  }

  /**
   * PointHistory updateMany
   */
  export type PointHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PointHistories.
     */
    data: XOR<PointHistoryUpdateManyMutationInput, PointHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PointHistories to update
     */
    where?: PointHistoryWhereInput
    /**
     * Limit how many PointHistories to update.
     */
    limit?: number
  }

  /**
   * PointHistory updateManyAndReturn
   */
  export type PointHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * The data used to update PointHistories.
     */
    data: XOR<PointHistoryUpdateManyMutationInput, PointHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PointHistories to update
     */
    where?: PointHistoryWhereInput
    /**
     * Limit how many PointHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PointHistory upsert
   */
  export type PointHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PointHistory to update in case it exists.
     */
    where: PointHistoryWhereUniqueInput
    /**
     * In case the PointHistory found by the `where` argument doesn't exist, create a new PointHistory with this data.
     */
    create: XOR<PointHistoryCreateInput, PointHistoryUncheckedCreateInput>
    /**
     * In case the PointHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PointHistoryUpdateInput, PointHistoryUncheckedUpdateInput>
  }

  /**
   * PointHistory delete
   */
  export type PointHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryInclude<ExtArgs> | null
    /**
     * Filter which PointHistory to delete.
     */
    where: PointHistoryWhereUniqueInput
  }

  /**
   * PointHistory deleteMany
   */
  export type PointHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PointHistories to delete
     */
    where?: PointHistoryWhereInput
    /**
     * Limit how many PointHistories to delete.
     */
    limit?: number
  }

  /**
   * PointHistory without action
   */
  export type PointHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PointHistory
     */
    select?: PointHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PointHistory
     */
    omit?: PointHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PointHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Referral
   */

  export type AggregateReferral = {
    _count: ReferralCountAggregateOutputType | null
    _avg: ReferralAvgAggregateOutputType | null
    _sum: ReferralSumAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  export type ReferralAvgAggregateOutputType = {
    points: number | null
  }

  export type ReferralSumAggregateOutputType = {
    points: number | null
  }

  export type ReferralMinAggregateOutputType = {
    id: string | null
    referrerId: string | null
    referredId: string | null
    points: number | null
    completed: boolean | null
    createdAt: Date | null
    isActive: boolean | null
  }

  export type ReferralMaxAggregateOutputType = {
    id: string | null
    referrerId: string | null
    referredId: string | null
    points: number | null
    completed: boolean | null
    createdAt: Date | null
    isActive: boolean | null
  }

  export type ReferralCountAggregateOutputType = {
    id: number
    referrerId: number
    referredId: number
    points: number
    completed: number
    createdAt: number
    isActive: number
    _all: number
  }


  export type ReferralAvgAggregateInputType = {
    points?: true
  }

  export type ReferralSumAggregateInputType = {
    points?: true
  }

  export type ReferralMinAggregateInputType = {
    id?: true
    referrerId?: true
    referredId?: true
    points?: true
    completed?: true
    createdAt?: true
    isActive?: true
  }

  export type ReferralMaxAggregateInputType = {
    id?: true
    referrerId?: true
    referredId?: true
    points?: true
    completed?: true
    createdAt?: true
    isActive?: true
  }

  export type ReferralCountAggregateInputType = {
    id?: true
    referrerId?: true
    referredId?: true
    points?: true
    completed?: true
    createdAt?: true
    isActive?: true
    _all?: true
  }

  export type ReferralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referral to aggregate.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Referrals
    **/
    _count?: true | ReferralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferralAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferralSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralMaxAggregateInputType
  }

  export type GetReferralAggregateType<T extends ReferralAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral[P]>
      : GetScalarType<T[P], AggregateReferral[P]>
  }




  export type ReferralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithAggregationInput | ReferralOrderByWithAggregationInput[]
    by: ReferralScalarFieldEnum[] | ReferralScalarFieldEnum
    having?: ReferralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralCountAggregateInputType | true
    _avg?: ReferralAvgAggregateInputType
    _sum?: ReferralSumAggregateInputType
    _min?: ReferralMinAggregateInputType
    _max?: ReferralMaxAggregateInputType
  }

  export type ReferralGroupByOutputType = {
    id: string
    referrerId: string
    referredId: string
    points: number
    completed: boolean
    createdAt: Date
    isActive: boolean
    _count: ReferralCountAggregateOutputType | null
    _avg: ReferralAvgAggregateOutputType | null
    _sum: ReferralSumAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  type GetReferralGroupByPayload<T extends ReferralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralGroupByOutputType[P]>
        }
      >
    >


  export type ReferralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    referredId?: boolean
    points?: boolean
    completed?: boolean
    createdAt?: boolean
    isActive?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referred?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    referredId?: boolean
    points?: boolean
    completed?: boolean
    createdAt?: boolean
    isActive?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referred?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    referrerId?: boolean
    referredId?: boolean
    points?: boolean
    completed?: boolean
    createdAt?: boolean
    isActive?: boolean
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referred?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectScalar = {
    id?: boolean
    referrerId?: boolean
    referredId?: boolean
    points?: boolean
    completed?: boolean
    createdAt?: boolean
    isActive?: boolean
  }

  export type ReferralOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "referrerId" | "referredId" | "points" | "completed" | "createdAt" | "isActive", ExtArgs["result"]["referral"]>
  export type ReferralInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referred?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReferralIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referred?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReferralIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    referrer?: boolean | UserDefaultArgs<ExtArgs>
    referred?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReferralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Referral"
    objects: {
      referrer: Prisma.$UserPayload<ExtArgs>
      referred: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      referrerId: string
      referredId: string
      points: number
      completed: boolean
      createdAt: Date
      isActive: boolean
    }, ExtArgs["result"]["referral"]>
    composites: {}
  }

  type ReferralGetPayload<S extends boolean | null | undefined | ReferralDefaultArgs> = $Result.GetResult<Prisma.$ReferralPayload, S>

  type ReferralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReferralFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferralCountAggregateInputType | true
    }

  export interface ReferralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Referral'], meta: { name: 'Referral' } }
    /**
     * Find zero or one Referral that matches the filter.
     * @param {ReferralFindUniqueArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralFindUniqueArgs>(args: SelectSubset<T, ReferralFindUniqueArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Referral that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReferralFindUniqueOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralFindFirstArgs>(args?: SelectSubset<T, ReferralFindFirstArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Referrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referrals
     * const referrals = await prisma.referral.findMany()
     * 
     * // Get first 10 Referrals
     * const referrals = await prisma.referral.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralWithIdOnly = await prisma.referral.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralFindManyArgs>(args?: SelectSubset<T, ReferralFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Referral.
     * @param {ReferralCreateArgs} args - Arguments to create a Referral.
     * @example
     * // Create one Referral
     * const Referral = await prisma.referral.create({
     *   data: {
     *     // ... data to create a Referral
     *   }
     * })
     * 
     */
    create<T extends ReferralCreateArgs>(args: SelectSubset<T, ReferralCreateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Referrals.
     * @param {ReferralCreateManyArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralCreateManyArgs>(args?: SelectSubset<T, ReferralCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Referrals and returns the data saved in the database.
     * @param {ReferralCreateManyAndReturnArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Referrals and only return the `id`
     * const referralWithIdOnly = await prisma.referral.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Referral.
     * @param {ReferralDeleteArgs} args - Arguments to delete one Referral.
     * @example
     * // Delete one Referral
     * const Referral = await prisma.referral.delete({
     *   where: {
     *     // ... filter to delete one Referral
     *   }
     * })
     * 
     */
    delete<T extends ReferralDeleteArgs>(args: SelectSubset<T, ReferralDeleteArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Referral.
     * @param {ReferralUpdateArgs} args - Arguments to update one Referral.
     * @example
     * // Update one Referral
     * const referral = await prisma.referral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralUpdateArgs>(args: SelectSubset<T, ReferralUpdateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Referrals.
     * @param {ReferralDeleteManyArgs} args - Arguments to filter Referrals to delete.
     * @example
     * // Delete a few Referrals
     * const { count } = await prisma.referral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralDeleteManyArgs>(args?: SelectSubset<T, ReferralDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralUpdateManyArgs>(args: SelectSubset<T, ReferralUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals and returns the data updated in the database.
     * @param {ReferralUpdateManyAndReturnArgs} args - Arguments to update many Referrals.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Referrals and only return the `id`
     * const referralWithIdOnly = await prisma.referral.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReferralUpdateManyAndReturnArgs>(args: SelectSubset<T, ReferralUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Referral.
     * @param {ReferralUpsertArgs} args - Arguments to update or create a Referral.
     * @example
     * // Update or create a Referral
     * const referral = await prisma.referral.upsert({
     *   create: {
     *     // ... data to create a Referral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral we want to update
     *   }
     * })
     */
    upsert<T extends ReferralUpsertArgs>(args: SelectSubset<T, ReferralUpsertArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCountArgs} args - Arguments to filter Referrals to count.
     * @example
     * // Count the number of Referrals
     * const count = await prisma.referral.count({
     *   where: {
     *     // ... the filter for the Referrals we want to count
     *   }
     * })
    **/
    count<T extends ReferralCountArgs>(
      args?: Subset<T, ReferralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralAggregateArgs>(args: Subset<T, ReferralAggregateArgs>): Prisma.PrismaPromise<GetReferralAggregateType<T>>

    /**
     * Group by Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralGroupByArgs['orderBy'] }
        : { orderBy?: ReferralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Referral model
   */
  readonly fields: ReferralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Referral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    referrer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    referred<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Referral model
   */
  interface ReferralFieldRefs {
    readonly id: FieldRef<"Referral", 'String'>
    readonly referrerId: FieldRef<"Referral", 'String'>
    readonly referredId: FieldRef<"Referral", 'String'>
    readonly points: FieldRef<"Referral", 'Int'>
    readonly completed: FieldRef<"Referral", 'Boolean'>
    readonly createdAt: FieldRef<"Referral", 'DateTime'>
    readonly isActive: FieldRef<"Referral", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Referral findUnique
   */
  export type ReferralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findUniqueOrThrow
   */
  export type ReferralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findFirst
   */
  export type ReferralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findFirstOrThrow
   */
  export type ReferralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findMany
   */
  export type ReferralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral create
   */
  export type ReferralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to create a Referral.
     */
    data: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
  }

  /**
   * Referral createMany
   */
  export type ReferralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Referral createManyAndReturn
   */
  export type ReferralCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referral update
   */
  export type ReferralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to update a Referral.
     */
    data: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
    /**
     * Choose, which Referral to update.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral updateMany
   */
  export type ReferralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to update.
     */
    limit?: number
  }

  /**
   * Referral updateManyAndReturn
   */
  export type ReferralUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referral upsert
   */
  export type ReferralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The filter to search for the Referral to update in case it exists.
     */
    where: ReferralWhereUniqueInput
    /**
     * In case the Referral found by the `where` argument doesn't exist, create a new Referral with this data.
     */
    create: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
    /**
     * In case the Referral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
  }

  /**
   * Referral delete
   */
  export type ReferralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter which Referral to delete.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral deleteMany
   */
  export type ReferralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referrals to delete
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to delete.
     */
    limit?: number
  }

  /**
   * Referral without action
   */
  export type ReferralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
  }


  /**
   * Model SystemConfig
   */

  export type AggregateSystemConfig = {
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  export type SystemConfigMinAggregateOutputType = {
    id: string | null
    key: string | null
    description: string | null
    updatedAt: Date | null
  }

  export type SystemConfigMaxAggregateOutputType = {
    id: string | null
    key: string | null
    description: string | null
    updatedAt: Date | null
  }

  export type SystemConfigCountAggregateOutputType = {
    id: number
    key: number
    value: number
    description: number
    updatedAt: number
    _all: number
  }


  export type SystemConfigMinAggregateInputType = {
    id?: true
    key?: true
    description?: true
    updatedAt?: true
  }

  export type SystemConfigMaxAggregateInputType = {
    id?: true
    key?: true
    description?: true
    updatedAt?: true
  }

  export type SystemConfigCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfig to aggregate.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemConfigs
    **/
    _count?: true | SystemConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemConfigMaxAggregateInputType
  }

  export type GetSystemConfigAggregateType<T extends SystemConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemConfig[P]>
      : GetScalarType<T[P], AggregateSystemConfig[P]>
  }




  export type SystemConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemConfigWhereInput
    orderBy?: SystemConfigOrderByWithAggregationInput | SystemConfigOrderByWithAggregationInput[]
    by: SystemConfigScalarFieldEnum[] | SystemConfigScalarFieldEnum
    having?: SystemConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemConfigCountAggregateInputType | true
    _min?: SystemConfigMinAggregateInputType
    _max?: SystemConfigMaxAggregateInputType
  }

  export type SystemConfigGroupByOutputType = {
    id: string
    key: string
    value: JsonValue
    description: string | null
    updatedAt: Date
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  type GetSystemConfigGroupByPayload<T extends SystemConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
        }
      >
    >


  export type SystemConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    updatedAt?: boolean
  }

  export type SystemConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "description" | "updatedAt", ExtArgs["result"]["systemConfig"]>

  export type $SystemConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: Prisma.JsonValue
      description: string | null
      updatedAt: Date
    }, ExtArgs["result"]["systemConfig"]>
    composites: {}
  }

  type SystemConfigGetPayload<S extends boolean | null | undefined | SystemConfigDefaultArgs> = $Result.GetResult<Prisma.$SystemConfigPayload, S>

  type SystemConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemConfigCountAggregateInputType | true
    }

  export interface SystemConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemConfig'], meta: { name: 'SystemConfig' } }
    /**
     * Find zero or one SystemConfig that matches the filter.
     * @param {SystemConfigFindUniqueArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemConfigFindUniqueArgs>(args: SelectSubset<T, SystemConfigFindUniqueArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemConfigFindUniqueOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemConfigFindFirstArgs>(args?: SelectSubset<T, SystemConfigFindFirstArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany()
     * 
     * // Get first 10 SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemConfigFindManyArgs>(args?: SelectSubset<T, SystemConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemConfig.
     * @param {SystemConfigCreateArgs} args - Arguments to create a SystemConfig.
     * @example
     * // Create one SystemConfig
     * const SystemConfig = await prisma.systemConfig.create({
     *   data: {
     *     // ... data to create a SystemConfig
     *   }
     * })
     * 
     */
    create<T extends SystemConfigCreateArgs>(args: SelectSubset<T, SystemConfigCreateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemConfigs.
     * @param {SystemConfigCreateManyArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemConfigCreateManyArgs>(args?: SelectSubset<T, SystemConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemConfigs and returns the data saved in the database.
     * @param {SystemConfigCreateManyAndReturnArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemConfig.
     * @param {SystemConfigDeleteArgs} args - Arguments to delete one SystemConfig.
     * @example
     * // Delete one SystemConfig
     * const SystemConfig = await prisma.systemConfig.delete({
     *   where: {
     *     // ... filter to delete one SystemConfig
     *   }
     * })
     * 
     */
    delete<T extends SystemConfigDeleteArgs>(args: SelectSubset<T, SystemConfigDeleteArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemConfig.
     * @param {SystemConfigUpdateArgs} args - Arguments to update one SystemConfig.
     * @example
     * // Update one SystemConfig
     * const systemConfig = await prisma.systemConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemConfigUpdateArgs>(args: SelectSubset<T, SystemConfigUpdateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemConfigs.
     * @param {SystemConfigDeleteManyArgs} args - Arguments to filter SystemConfigs to delete.
     * @example
     * // Delete a few SystemConfigs
     * const { count } = await prisma.systemConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemConfigDeleteManyArgs>(args?: SelectSubset<T, SystemConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemConfigUpdateManyArgs>(args: SelectSubset<T, SystemConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs and returns the data updated in the database.
     * @param {SystemConfigUpdateManyAndReturnArgs} args - Arguments to update many SystemConfigs.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemConfig.
     * @param {SystemConfigUpsertArgs} args - Arguments to update or create a SystemConfig.
     * @example
     * // Update or create a SystemConfig
     * const systemConfig = await prisma.systemConfig.upsert({
     *   create: {
     *     // ... data to create a SystemConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemConfig we want to update
     *   }
     * })
     */
    upsert<T extends SystemConfigUpsertArgs>(args: SelectSubset<T, SystemConfigUpsertArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigCountArgs} args - Arguments to filter SystemConfigs to count.
     * @example
     * // Count the number of SystemConfigs
     * const count = await prisma.systemConfig.count({
     *   where: {
     *     // ... the filter for the SystemConfigs we want to count
     *   }
     * })
    **/
    count<T extends SystemConfigCountArgs>(
      args?: Subset<T, SystemConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemConfigAggregateArgs>(args: Subset<T, SystemConfigAggregateArgs>): Prisma.PrismaPromise<GetSystemConfigAggregateType<T>>

    /**
     * Group by SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemConfigGroupByArgs['orderBy'] }
        : { orderBy?: SystemConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemConfig model
   */
  readonly fields: SystemConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemConfig model
   */
  interface SystemConfigFieldRefs {
    readonly id: FieldRef<"SystemConfig", 'String'>
    readonly key: FieldRef<"SystemConfig", 'String'>
    readonly value: FieldRef<"SystemConfig", 'Json'>
    readonly description: FieldRef<"SystemConfig", 'String'>
    readonly updatedAt: FieldRef<"SystemConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemConfig findUnique
   */
  export type SystemConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findUniqueOrThrow
   */
  export type SystemConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findFirst
   */
  export type SystemConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findFirstOrThrow
   */
  export type SystemConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findMany
   */
  export type SystemConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfigs to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig create
   */
  export type SystemConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemConfig.
     */
    data: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
  }

  /**
   * SystemConfig createMany
   */
  export type SystemConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig createManyAndReturn
   */
  export type SystemConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig update
   */
  export type SystemConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemConfig.
     */
    data: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
    /**
     * Choose, which SystemConfig to update.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig updateMany
   */
  export type SystemConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to update.
     */
    limit?: number
  }

  /**
   * SystemConfig updateManyAndReturn
   */
  export type SystemConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to update.
     */
    limit?: number
  }

  /**
   * SystemConfig upsert
   */
  export type SystemConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemConfig to update in case it exists.
     */
    where: SystemConfigWhereUniqueInput
    /**
     * In case the SystemConfig found by the `where` argument doesn't exist, create a new SystemConfig with this data.
     */
    create: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
    /**
     * In case the SystemConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
  }

  /**
   * SystemConfig delete
   */
  export type SystemConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter which SystemConfig to delete.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig deleteMany
   */
  export type SystemConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfigs to delete
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to delete.
     */
    limit?: number
  }

  /**
   * SystemConfig without action
   */
  export type SystemConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
  }


  /**
   * Model Analytics
   */

  export type AggregateAnalytics = {
    _count: AnalyticsCountAggregateOutputType | null
    _avg: AnalyticsAvgAggregateOutputType | null
    _sum: AnalyticsSumAggregateOutputType | null
    _min: AnalyticsMinAggregateOutputType | null
    _max: AnalyticsMaxAggregateOutputType | null
  }

  export type AnalyticsAvgAggregateOutputType = {
    totalUsers: number | null
    activeUsers: number | null
    totalClaims: number | null
    totalPoints: number | null
    totalEngagements: number | null
  }

  export type AnalyticsSumAggregateOutputType = {
    totalUsers: number | null
    activeUsers: number | null
    totalClaims: number | null
    totalPoints: number | null
    totalEngagements: number | null
  }

  export type AnalyticsMinAggregateOutputType = {
    id: string | null
    date: Date | null
    totalUsers: number | null
    activeUsers: number | null
    totalClaims: number | null
    totalPoints: number | null
    totalEngagements: number | null
    createdAt: Date | null
  }

  export type AnalyticsMaxAggregateOutputType = {
    id: string | null
    date: Date | null
    totalUsers: number | null
    activeUsers: number | null
    totalClaims: number | null
    totalPoints: number | null
    totalEngagements: number | null
    createdAt: Date | null
  }

  export type AnalyticsCountAggregateOutputType = {
    id: number
    date: number
    totalUsers: number
    activeUsers: number
    totalClaims: number
    totalPoints: number
    totalEngagements: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AnalyticsAvgAggregateInputType = {
    totalUsers?: true
    activeUsers?: true
    totalClaims?: true
    totalPoints?: true
    totalEngagements?: true
  }

  export type AnalyticsSumAggregateInputType = {
    totalUsers?: true
    activeUsers?: true
    totalClaims?: true
    totalPoints?: true
    totalEngagements?: true
  }

  export type AnalyticsMinAggregateInputType = {
    id?: true
    date?: true
    totalUsers?: true
    activeUsers?: true
    totalClaims?: true
    totalPoints?: true
    totalEngagements?: true
    createdAt?: true
  }

  export type AnalyticsMaxAggregateInputType = {
    id?: true
    date?: true
    totalUsers?: true
    activeUsers?: true
    totalClaims?: true
    totalPoints?: true
    totalEngagements?: true
    createdAt?: true
  }

  export type AnalyticsCountAggregateInputType = {
    id?: true
    date?: true
    totalUsers?: true
    activeUsers?: true
    totalClaims?: true
    totalPoints?: true
    totalEngagements?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Analytics to aggregate.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Analytics
    **/
    _count?: true | AnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsMaxAggregateInputType
  }

  export type GetAnalyticsAggregateType<T extends AnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalytics[P]>
      : GetScalarType<T[P], AggregateAnalytics[P]>
  }




  export type AnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsWhereInput
    orderBy?: AnalyticsOrderByWithAggregationInput | AnalyticsOrderByWithAggregationInput[]
    by: AnalyticsScalarFieldEnum[] | AnalyticsScalarFieldEnum
    having?: AnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsCountAggregateInputType | true
    _avg?: AnalyticsAvgAggregateInputType
    _sum?: AnalyticsSumAggregateInputType
    _min?: AnalyticsMinAggregateInputType
    _max?: AnalyticsMaxAggregateInputType
  }

  export type AnalyticsGroupByOutputType = {
    id: string
    date: Date
    totalUsers: number
    activeUsers: number
    totalClaims: number
    totalPoints: number
    totalEngagements: number
    metadata: JsonValue | null
    createdAt: Date
    _count: AnalyticsCountAggregateOutputType | null
    _avg: AnalyticsAvgAggregateOutputType | null
    _sum: AnalyticsSumAggregateOutputType | null
    _min: AnalyticsMinAggregateOutputType | null
    _max: AnalyticsMaxAggregateOutputType | null
  }

  type GetAnalyticsGroupByPayload<T extends AnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    totalUsers?: boolean
    activeUsers?: boolean
    totalClaims?: boolean
    totalPoints?: boolean
    totalEngagements?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["analytics"]>

  export type AnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    totalUsers?: boolean
    activeUsers?: boolean
    totalClaims?: boolean
    totalPoints?: boolean
    totalEngagements?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["analytics"]>

  export type AnalyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    totalUsers?: boolean
    activeUsers?: boolean
    totalClaims?: boolean
    totalPoints?: boolean
    totalEngagements?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["analytics"]>

  export type AnalyticsSelectScalar = {
    id?: boolean
    date?: boolean
    totalUsers?: boolean
    activeUsers?: boolean
    totalClaims?: boolean
    totalPoints?: boolean
    totalEngagements?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "totalUsers" | "activeUsers" | "totalClaims" | "totalPoints" | "totalEngagements" | "metadata" | "createdAt", ExtArgs["result"]["analytics"]>

  export type $AnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Analytics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      date: Date
      totalUsers: number
      activeUsers: number
      totalClaims: number
      totalPoints: number
      totalEngagements: number
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["analytics"]>
    composites: {}
  }

  type AnalyticsGetPayload<S extends boolean | null | undefined | AnalyticsDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsPayload, S>

  type AnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnalyticsCountAggregateInputType | true
    }

  export interface AnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Analytics'], meta: { name: 'Analytics' } }
    /**
     * Find zero or one Analytics that matches the filter.
     * @param {AnalyticsFindUniqueArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsFindUniqueArgs>(args: SelectSubset<T, AnalyticsFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Analytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnalyticsFindUniqueOrThrowArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Analytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFindFirstArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsFindFirstArgs>(args?: SelectSubset<T, AnalyticsFindFirstArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Analytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFindFirstOrThrowArgs} args - Arguments to find a Analytics
     * @example
     * // Get one Analytics
     * const analytics = await prisma.analytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Analytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Analytics
     * const analytics = await prisma.analytics.findMany()
     * 
     * // Get first 10 Analytics
     * const analytics = await prisma.analytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsWithIdOnly = await prisma.analytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsFindManyArgs>(args?: SelectSubset<T, AnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Analytics.
     * @param {AnalyticsCreateArgs} args - Arguments to create a Analytics.
     * @example
     * // Create one Analytics
     * const Analytics = await prisma.analytics.create({
     *   data: {
     *     // ... data to create a Analytics
     *   }
     * })
     * 
     */
    create<T extends AnalyticsCreateArgs>(args: SelectSubset<T, AnalyticsCreateArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Analytics.
     * @param {AnalyticsCreateManyArgs} args - Arguments to create many Analytics.
     * @example
     * // Create many Analytics
     * const analytics = await prisma.analytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsCreateManyArgs>(args?: SelectSubset<T, AnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Analytics and returns the data saved in the database.
     * @param {AnalyticsCreateManyAndReturnArgs} args - Arguments to create many Analytics.
     * @example
     * // Create many Analytics
     * const analytics = await prisma.analytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Analytics and only return the `id`
     * const analyticsWithIdOnly = await prisma.analytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Analytics.
     * @param {AnalyticsDeleteArgs} args - Arguments to delete one Analytics.
     * @example
     * // Delete one Analytics
     * const Analytics = await prisma.analytics.delete({
     *   where: {
     *     // ... filter to delete one Analytics
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsDeleteArgs>(args: SelectSubset<T, AnalyticsDeleteArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Analytics.
     * @param {AnalyticsUpdateArgs} args - Arguments to update one Analytics.
     * @example
     * // Update one Analytics
     * const analytics = await prisma.analytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsUpdateArgs>(args: SelectSubset<T, AnalyticsUpdateArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Analytics.
     * @param {AnalyticsDeleteManyArgs} args - Arguments to filter Analytics to delete.
     * @example
     * // Delete a few Analytics
     * const { count } = await prisma.analytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsDeleteManyArgs>(args?: SelectSubset<T, AnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Analytics
     * const analytics = await prisma.analytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsUpdateManyArgs>(args: SelectSubset<T, AnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Analytics and returns the data updated in the database.
     * @param {AnalyticsUpdateManyAndReturnArgs} args - Arguments to update many Analytics.
     * @example
     * // Update many Analytics
     * const analytics = await prisma.analytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Analytics and only return the `id`
     * const analyticsWithIdOnly = await prisma.analytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnalyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, AnalyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Analytics.
     * @param {AnalyticsUpsertArgs} args - Arguments to update or create a Analytics.
     * @example
     * // Update or create a Analytics
     * const analytics = await prisma.analytics.upsert({
     *   create: {
     *     // ... data to create a Analytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Analytics we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsUpsertArgs>(args: SelectSubset<T, AnalyticsUpsertArgs<ExtArgs>>): Prisma__AnalyticsClient<$Result.GetResult<Prisma.$AnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsCountArgs} args - Arguments to filter Analytics to count.
     * @example
     * // Count the number of Analytics
     * const count = await prisma.analytics.count({
     *   where: {
     *     // ... the filter for the Analytics we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsCountArgs>(
      args?: Subset<T, AnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsAggregateArgs>(args: Subset<T, AnalyticsAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsAggregateType<T>>

    /**
     * Group by Analytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Analytics model
   */
  readonly fields: AnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Analytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Analytics model
   */
  interface AnalyticsFieldRefs {
    readonly id: FieldRef<"Analytics", 'String'>
    readonly date: FieldRef<"Analytics", 'DateTime'>
    readonly totalUsers: FieldRef<"Analytics", 'Int'>
    readonly activeUsers: FieldRef<"Analytics", 'Int'>
    readonly totalClaims: FieldRef<"Analytics", 'Int'>
    readonly totalPoints: FieldRef<"Analytics", 'Int'>
    readonly totalEngagements: FieldRef<"Analytics", 'Int'>
    readonly metadata: FieldRef<"Analytics", 'Json'>
    readonly createdAt: FieldRef<"Analytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Analytics findUnique
   */
  export type AnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics findUniqueOrThrow
   */
  export type AnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics findFirst
   */
  export type AnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Analytics.
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Analytics.
     */
    distinct?: AnalyticsScalarFieldEnum | AnalyticsScalarFieldEnum[]
  }

  /**
   * Analytics findFirstOrThrow
   */
  export type AnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Analytics.
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Analytics.
     */
    distinct?: AnalyticsScalarFieldEnum | AnalyticsScalarFieldEnum[]
  }

  /**
   * Analytics findMany
   */
  export type AnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which Analytics to fetch.
     */
    where?: AnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Analytics to fetch.
     */
    orderBy?: AnalyticsOrderByWithRelationInput | AnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Analytics.
     */
    cursor?: AnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Analytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Analytics.
     */
    skip?: number
    distinct?: AnalyticsScalarFieldEnum | AnalyticsScalarFieldEnum[]
  }

  /**
   * Analytics create
   */
  export type AnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * The data needed to create a Analytics.
     */
    data?: XOR<AnalyticsCreateInput, AnalyticsUncheckedCreateInput>
  }

  /**
   * Analytics createMany
   */
  export type AnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Analytics.
     */
    data: AnalyticsCreateManyInput | AnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Analytics createManyAndReturn
   */
  export type AnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * The data used to create many Analytics.
     */
    data: AnalyticsCreateManyInput | AnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Analytics update
   */
  export type AnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * The data needed to update a Analytics.
     */
    data: XOR<AnalyticsUpdateInput, AnalyticsUncheckedUpdateInput>
    /**
     * Choose, which Analytics to update.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics updateMany
   */
  export type AnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Analytics.
     */
    data: XOR<AnalyticsUpdateManyMutationInput, AnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which Analytics to update
     */
    where?: AnalyticsWhereInput
    /**
     * Limit how many Analytics to update.
     */
    limit?: number
  }

  /**
   * Analytics updateManyAndReturn
   */
  export type AnalyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * The data used to update Analytics.
     */
    data: XOR<AnalyticsUpdateManyMutationInput, AnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which Analytics to update
     */
    where?: AnalyticsWhereInput
    /**
     * Limit how many Analytics to update.
     */
    limit?: number
  }

  /**
   * Analytics upsert
   */
  export type AnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * The filter to search for the Analytics to update in case it exists.
     */
    where: AnalyticsWhereUniqueInput
    /**
     * In case the Analytics found by the `where` argument doesn't exist, create a new Analytics with this data.
     */
    create: XOR<AnalyticsCreateInput, AnalyticsUncheckedCreateInput>
    /**
     * In case the Analytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsUpdateInput, AnalyticsUncheckedUpdateInput>
  }

  /**
   * Analytics delete
   */
  export type AnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
    /**
     * Filter which Analytics to delete.
     */
    where: AnalyticsWhereUniqueInput
  }

  /**
   * Analytics deleteMany
   */
  export type AnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Analytics to delete
     */
    where?: AnalyticsWhereInput
    /**
     * Limit how many Analytics to delete.
     */
    limit?: number
  }

  /**
   * Analytics without action
   */
  export type AnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Analytics
     */
    select?: AnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Analytics
     */
    omit?: AnalyticsOmit<ExtArgs> | null
  }


  /**
   * Model DailyEarning
   */

  export type AggregateDailyEarning = {
    _count: DailyEarningCountAggregateOutputType | null
    _avg: DailyEarningAvgAggregateOutputType | null
    _sum: DailyEarningSumAggregateOutputType | null
    _min: DailyEarningMinAggregateOutputType | null
    _max: DailyEarningMaxAggregateOutputType | null
  }

  export type DailyEarningAvgAggregateOutputType = {
    tokens: number | null
  }

  export type DailyEarningSumAggregateOutputType = {
    tokens: number | null
  }

  export type DailyEarningMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tokens: number | null
    type: string | null
    claimedAt: Date | null
  }

  export type DailyEarningMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tokens: number | null
    type: string | null
    claimedAt: Date | null
  }

  export type DailyEarningCountAggregateOutputType = {
    id: number
    userId: number
    tokens: number
    type: number
    claimedAt: number
    _all: number
  }


  export type DailyEarningAvgAggregateInputType = {
    tokens?: true
  }

  export type DailyEarningSumAggregateInputType = {
    tokens?: true
  }

  export type DailyEarningMinAggregateInputType = {
    id?: true
    userId?: true
    tokens?: true
    type?: true
    claimedAt?: true
  }

  export type DailyEarningMaxAggregateInputType = {
    id?: true
    userId?: true
    tokens?: true
    type?: true
    claimedAt?: true
  }

  export type DailyEarningCountAggregateInputType = {
    id?: true
    userId?: true
    tokens?: true
    type?: true
    claimedAt?: true
    _all?: true
  }

  export type DailyEarningAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyEarning to aggregate.
     */
    where?: DailyEarningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyEarnings to fetch.
     */
    orderBy?: DailyEarningOrderByWithRelationInput | DailyEarningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DailyEarningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyEarnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyEarnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DailyEarnings
    **/
    _count?: true | DailyEarningCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DailyEarningAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DailyEarningSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DailyEarningMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DailyEarningMaxAggregateInputType
  }

  export type GetDailyEarningAggregateType<T extends DailyEarningAggregateArgs> = {
        [P in keyof T & keyof AggregateDailyEarning]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDailyEarning[P]>
      : GetScalarType<T[P], AggregateDailyEarning[P]>
  }




  export type DailyEarningGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DailyEarningWhereInput
    orderBy?: DailyEarningOrderByWithAggregationInput | DailyEarningOrderByWithAggregationInput[]
    by: DailyEarningScalarFieldEnum[] | DailyEarningScalarFieldEnum
    having?: DailyEarningScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DailyEarningCountAggregateInputType | true
    _avg?: DailyEarningAvgAggregateInputType
    _sum?: DailyEarningSumAggregateInputType
    _min?: DailyEarningMinAggregateInputType
    _max?: DailyEarningMaxAggregateInputType
  }

  export type DailyEarningGroupByOutputType = {
    id: string
    userId: string
    tokens: number
    type: string
    claimedAt: Date
    _count: DailyEarningCountAggregateOutputType | null
    _avg: DailyEarningAvgAggregateOutputType | null
    _sum: DailyEarningSumAggregateOutputType | null
    _min: DailyEarningMinAggregateOutputType | null
    _max: DailyEarningMaxAggregateOutputType | null
  }

  type GetDailyEarningGroupByPayload<T extends DailyEarningGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DailyEarningGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DailyEarningGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DailyEarningGroupByOutputType[P]>
            : GetScalarType<T[P], DailyEarningGroupByOutputType[P]>
        }
      >
    >


  export type DailyEarningSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokens?: boolean
    type?: boolean
    claimedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyEarning"]>

  export type DailyEarningSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokens?: boolean
    type?: boolean
    claimedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyEarning"]>

  export type DailyEarningSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokens?: boolean
    type?: boolean
    claimedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dailyEarning"]>

  export type DailyEarningSelectScalar = {
    id?: boolean
    userId?: boolean
    tokens?: boolean
    type?: boolean
    claimedAt?: boolean
  }

  export type DailyEarningOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "tokens" | "type" | "claimedAt", ExtArgs["result"]["dailyEarning"]>
  export type DailyEarningInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DailyEarningIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DailyEarningIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DailyEarningPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DailyEarning"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tokens: number
      type: string
      claimedAt: Date
    }, ExtArgs["result"]["dailyEarning"]>
    composites: {}
  }

  type DailyEarningGetPayload<S extends boolean | null | undefined | DailyEarningDefaultArgs> = $Result.GetResult<Prisma.$DailyEarningPayload, S>

  type DailyEarningCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DailyEarningFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DailyEarningCountAggregateInputType | true
    }

  export interface DailyEarningDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DailyEarning'], meta: { name: 'DailyEarning' } }
    /**
     * Find zero or one DailyEarning that matches the filter.
     * @param {DailyEarningFindUniqueArgs} args - Arguments to find a DailyEarning
     * @example
     * // Get one DailyEarning
     * const dailyEarning = await prisma.dailyEarning.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DailyEarningFindUniqueArgs>(args: SelectSubset<T, DailyEarningFindUniqueArgs<ExtArgs>>): Prisma__DailyEarningClient<$Result.GetResult<Prisma.$DailyEarningPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DailyEarning that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DailyEarningFindUniqueOrThrowArgs} args - Arguments to find a DailyEarning
     * @example
     * // Get one DailyEarning
     * const dailyEarning = await prisma.dailyEarning.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DailyEarningFindUniqueOrThrowArgs>(args: SelectSubset<T, DailyEarningFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DailyEarningClient<$Result.GetResult<Prisma.$DailyEarningPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyEarning that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyEarningFindFirstArgs} args - Arguments to find a DailyEarning
     * @example
     * // Get one DailyEarning
     * const dailyEarning = await prisma.dailyEarning.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DailyEarningFindFirstArgs>(args?: SelectSubset<T, DailyEarningFindFirstArgs<ExtArgs>>): Prisma__DailyEarningClient<$Result.GetResult<Prisma.$DailyEarningPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DailyEarning that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyEarningFindFirstOrThrowArgs} args - Arguments to find a DailyEarning
     * @example
     * // Get one DailyEarning
     * const dailyEarning = await prisma.dailyEarning.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DailyEarningFindFirstOrThrowArgs>(args?: SelectSubset<T, DailyEarningFindFirstOrThrowArgs<ExtArgs>>): Prisma__DailyEarningClient<$Result.GetResult<Prisma.$DailyEarningPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DailyEarnings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyEarningFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DailyEarnings
     * const dailyEarnings = await prisma.dailyEarning.findMany()
     * 
     * // Get first 10 DailyEarnings
     * const dailyEarnings = await prisma.dailyEarning.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dailyEarningWithIdOnly = await prisma.dailyEarning.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DailyEarningFindManyArgs>(args?: SelectSubset<T, DailyEarningFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyEarningPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DailyEarning.
     * @param {DailyEarningCreateArgs} args - Arguments to create a DailyEarning.
     * @example
     * // Create one DailyEarning
     * const DailyEarning = await prisma.dailyEarning.create({
     *   data: {
     *     // ... data to create a DailyEarning
     *   }
     * })
     * 
     */
    create<T extends DailyEarningCreateArgs>(args: SelectSubset<T, DailyEarningCreateArgs<ExtArgs>>): Prisma__DailyEarningClient<$Result.GetResult<Prisma.$DailyEarningPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DailyEarnings.
     * @param {DailyEarningCreateManyArgs} args - Arguments to create many DailyEarnings.
     * @example
     * // Create many DailyEarnings
     * const dailyEarning = await prisma.dailyEarning.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DailyEarningCreateManyArgs>(args?: SelectSubset<T, DailyEarningCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DailyEarnings and returns the data saved in the database.
     * @param {DailyEarningCreateManyAndReturnArgs} args - Arguments to create many DailyEarnings.
     * @example
     * // Create many DailyEarnings
     * const dailyEarning = await prisma.dailyEarning.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DailyEarnings and only return the `id`
     * const dailyEarningWithIdOnly = await prisma.dailyEarning.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DailyEarningCreateManyAndReturnArgs>(args?: SelectSubset<T, DailyEarningCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyEarningPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DailyEarning.
     * @param {DailyEarningDeleteArgs} args - Arguments to delete one DailyEarning.
     * @example
     * // Delete one DailyEarning
     * const DailyEarning = await prisma.dailyEarning.delete({
     *   where: {
     *     // ... filter to delete one DailyEarning
     *   }
     * })
     * 
     */
    delete<T extends DailyEarningDeleteArgs>(args: SelectSubset<T, DailyEarningDeleteArgs<ExtArgs>>): Prisma__DailyEarningClient<$Result.GetResult<Prisma.$DailyEarningPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DailyEarning.
     * @param {DailyEarningUpdateArgs} args - Arguments to update one DailyEarning.
     * @example
     * // Update one DailyEarning
     * const dailyEarning = await prisma.dailyEarning.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DailyEarningUpdateArgs>(args: SelectSubset<T, DailyEarningUpdateArgs<ExtArgs>>): Prisma__DailyEarningClient<$Result.GetResult<Prisma.$DailyEarningPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DailyEarnings.
     * @param {DailyEarningDeleteManyArgs} args - Arguments to filter DailyEarnings to delete.
     * @example
     * // Delete a few DailyEarnings
     * const { count } = await prisma.dailyEarning.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DailyEarningDeleteManyArgs>(args?: SelectSubset<T, DailyEarningDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyEarnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyEarningUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DailyEarnings
     * const dailyEarning = await prisma.dailyEarning.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DailyEarningUpdateManyArgs>(args: SelectSubset<T, DailyEarningUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DailyEarnings and returns the data updated in the database.
     * @param {DailyEarningUpdateManyAndReturnArgs} args - Arguments to update many DailyEarnings.
     * @example
     * // Update many DailyEarnings
     * const dailyEarning = await prisma.dailyEarning.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DailyEarnings and only return the `id`
     * const dailyEarningWithIdOnly = await prisma.dailyEarning.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DailyEarningUpdateManyAndReturnArgs>(args: SelectSubset<T, DailyEarningUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DailyEarningPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DailyEarning.
     * @param {DailyEarningUpsertArgs} args - Arguments to update or create a DailyEarning.
     * @example
     * // Update or create a DailyEarning
     * const dailyEarning = await prisma.dailyEarning.upsert({
     *   create: {
     *     // ... data to create a DailyEarning
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DailyEarning we want to update
     *   }
     * })
     */
    upsert<T extends DailyEarningUpsertArgs>(args: SelectSubset<T, DailyEarningUpsertArgs<ExtArgs>>): Prisma__DailyEarningClient<$Result.GetResult<Prisma.$DailyEarningPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DailyEarnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyEarningCountArgs} args - Arguments to filter DailyEarnings to count.
     * @example
     * // Count the number of DailyEarnings
     * const count = await prisma.dailyEarning.count({
     *   where: {
     *     // ... the filter for the DailyEarnings we want to count
     *   }
     * })
    **/
    count<T extends DailyEarningCountArgs>(
      args?: Subset<T, DailyEarningCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DailyEarningCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DailyEarning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyEarningAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DailyEarningAggregateArgs>(args: Subset<T, DailyEarningAggregateArgs>): Prisma.PrismaPromise<GetDailyEarningAggregateType<T>>

    /**
     * Group by DailyEarning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DailyEarningGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DailyEarningGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DailyEarningGroupByArgs['orderBy'] }
        : { orderBy?: DailyEarningGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DailyEarningGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDailyEarningGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DailyEarning model
   */
  readonly fields: DailyEarningFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DailyEarning.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DailyEarningClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DailyEarning model
   */
  interface DailyEarningFieldRefs {
    readonly id: FieldRef<"DailyEarning", 'String'>
    readonly userId: FieldRef<"DailyEarning", 'String'>
    readonly tokens: FieldRef<"DailyEarning", 'Float'>
    readonly type: FieldRef<"DailyEarning", 'String'>
    readonly claimedAt: FieldRef<"DailyEarning", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DailyEarning findUnique
   */
  export type DailyEarningFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEarning
     */
    select?: DailyEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyEarning
     */
    omit?: DailyEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEarningInclude<ExtArgs> | null
    /**
     * Filter, which DailyEarning to fetch.
     */
    where: DailyEarningWhereUniqueInput
  }

  /**
   * DailyEarning findUniqueOrThrow
   */
  export type DailyEarningFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEarning
     */
    select?: DailyEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyEarning
     */
    omit?: DailyEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEarningInclude<ExtArgs> | null
    /**
     * Filter, which DailyEarning to fetch.
     */
    where: DailyEarningWhereUniqueInput
  }

  /**
   * DailyEarning findFirst
   */
  export type DailyEarningFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEarning
     */
    select?: DailyEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyEarning
     */
    omit?: DailyEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEarningInclude<ExtArgs> | null
    /**
     * Filter, which DailyEarning to fetch.
     */
    where?: DailyEarningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyEarnings to fetch.
     */
    orderBy?: DailyEarningOrderByWithRelationInput | DailyEarningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyEarnings.
     */
    cursor?: DailyEarningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyEarnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyEarnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyEarnings.
     */
    distinct?: DailyEarningScalarFieldEnum | DailyEarningScalarFieldEnum[]
  }

  /**
   * DailyEarning findFirstOrThrow
   */
  export type DailyEarningFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEarning
     */
    select?: DailyEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyEarning
     */
    omit?: DailyEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEarningInclude<ExtArgs> | null
    /**
     * Filter, which DailyEarning to fetch.
     */
    where?: DailyEarningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyEarnings to fetch.
     */
    orderBy?: DailyEarningOrderByWithRelationInput | DailyEarningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DailyEarnings.
     */
    cursor?: DailyEarningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyEarnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyEarnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DailyEarnings.
     */
    distinct?: DailyEarningScalarFieldEnum | DailyEarningScalarFieldEnum[]
  }

  /**
   * DailyEarning findMany
   */
  export type DailyEarningFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEarning
     */
    select?: DailyEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyEarning
     */
    omit?: DailyEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEarningInclude<ExtArgs> | null
    /**
     * Filter, which DailyEarnings to fetch.
     */
    where?: DailyEarningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DailyEarnings to fetch.
     */
    orderBy?: DailyEarningOrderByWithRelationInput | DailyEarningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DailyEarnings.
     */
    cursor?: DailyEarningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DailyEarnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DailyEarnings.
     */
    skip?: number
    distinct?: DailyEarningScalarFieldEnum | DailyEarningScalarFieldEnum[]
  }

  /**
   * DailyEarning create
   */
  export type DailyEarningCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEarning
     */
    select?: DailyEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyEarning
     */
    omit?: DailyEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEarningInclude<ExtArgs> | null
    /**
     * The data needed to create a DailyEarning.
     */
    data: XOR<DailyEarningCreateInput, DailyEarningUncheckedCreateInput>
  }

  /**
   * DailyEarning createMany
   */
  export type DailyEarningCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DailyEarnings.
     */
    data: DailyEarningCreateManyInput | DailyEarningCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DailyEarning createManyAndReturn
   */
  export type DailyEarningCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEarning
     */
    select?: DailyEarningSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyEarning
     */
    omit?: DailyEarningOmit<ExtArgs> | null
    /**
     * The data used to create many DailyEarnings.
     */
    data: DailyEarningCreateManyInput | DailyEarningCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEarningIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyEarning update
   */
  export type DailyEarningUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEarning
     */
    select?: DailyEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyEarning
     */
    omit?: DailyEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEarningInclude<ExtArgs> | null
    /**
     * The data needed to update a DailyEarning.
     */
    data: XOR<DailyEarningUpdateInput, DailyEarningUncheckedUpdateInput>
    /**
     * Choose, which DailyEarning to update.
     */
    where: DailyEarningWhereUniqueInput
  }

  /**
   * DailyEarning updateMany
   */
  export type DailyEarningUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DailyEarnings.
     */
    data: XOR<DailyEarningUpdateManyMutationInput, DailyEarningUncheckedUpdateManyInput>
    /**
     * Filter which DailyEarnings to update
     */
    where?: DailyEarningWhereInput
    /**
     * Limit how many DailyEarnings to update.
     */
    limit?: number
  }

  /**
   * DailyEarning updateManyAndReturn
   */
  export type DailyEarningUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEarning
     */
    select?: DailyEarningSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DailyEarning
     */
    omit?: DailyEarningOmit<ExtArgs> | null
    /**
     * The data used to update DailyEarnings.
     */
    data: XOR<DailyEarningUpdateManyMutationInput, DailyEarningUncheckedUpdateManyInput>
    /**
     * Filter which DailyEarnings to update
     */
    where?: DailyEarningWhereInput
    /**
     * Limit how many DailyEarnings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEarningIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DailyEarning upsert
   */
  export type DailyEarningUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEarning
     */
    select?: DailyEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyEarning
     */
    omit?: DailyEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEarningInclude<ExtArgs> | null
    /**
     * The filter to search for the DailyEarning to update in case it exists.
     */
    where: DailyEarningWhereUniqueInput
    /**
     * In case the DailyEarning found by the `where` argument doesn't exist, create a new DailyEarning with this data.
     */
    create: XOR<DailyEarningCreateInput, DailyEarningUncheckedCreateInput>
    /**
     * In case the DailyEarning was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DailyEarningUpdateInput, DailyEarningUncheckedUpdateInput>
  }

  /**
   * DailyEarning delete
   */
  export type DailyEarningDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEarning
     */
    select?: DailyEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyEarning
     */
    omit?: DailyEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEarningInclude<ExtArgs> | null
    /**
     * Filter which DailyEarning to delete.
     */
    where: DailyEarningWhereUniqueInput
  }

  /**
   * DailyEarning deleteMany
   */
  export type DailyEarningDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DailyEarnings to delete
     */
    where?: DailyEarningWhereInput
    /**
     * Limit how many DailyEarnings to delete.
     */
    limit?: number
  }

  /**
   * DailyEarning without action
   */
  export type DailyEarningDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DailyEarning
     */
    select?: DailyEarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DailyEarning
     */
    omit?: DailyEarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DailyEarningInclude<ExtArgs> | null
  }


  /**
   * Model AirdropSeason
   */

  export type AggregateAirdropSeason = {
    _count: AirdropSeasonCountAggregateOutputType | null
    _avg: AirdropSeasonAvgAggregateOutputType | null
    _sum: AirdropSeasonSumAggregateOutputType | null
    _min: AirdropSeasonMinAggregateOutputType | null
    _max: AirdropSeasonMaxAggregateOutputType | null
  }

  export type AirdropSeasonAvgAggregateOutputType = {
    totalAllocation: number | null
    claimedAmount: number | null
    feeAmount: Decimal | null
  }

  export type AirdropSeasonSumAggregateOutputType = {
    totalAllocation: bigint | null
    claimedAmount: bigint | null
    feeAmount: Decimal | null
  }

  export type AirdropSeasonMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: string | null
    totalAllocation: bigint | null
    claimedAmount: bigint | null
    startDate: Date | null
    endDate: Date | null
    nftPassRequired: boolean | null
    requireApproval: boolean | null
    feeAmount: Decimal | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AirdropSeasonMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    status: string | null
    totalAllocation: bigint | null
    claimedAmount: bigint | null
    startDate: Date | null
    endDate: Date | null
    nftPassRequired: boolean | null
    requireApproval: boolean | null
    feeAmount: Decimal | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AirdropSeasonCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    totalAllocation: number
    claimedAmount: number
    startDate: number
    endDate: number
    nftPassRequired: number
    requireApproval: number
    feeAmount: number
    createdBy: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AirdropSeasonAvgAggregateInputType = {
    totalAllocation?: true
    claimedAmount?: true
    feeAmount?: true
  }

  export type AirdropSeasonSumAggregateInputType = {
    totalAllocation?: true
    claimedAmount?: true
    feeAmount?: true
  }

  export type AirdropSeasonMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    totalAllocation?: true
    claimedAmount?: true
    startDate?: true
    endDate?: true
    nftPassRequired?: true
    requireApproval?: true
    feeAmount?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AirdropSeasonMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    totalAllocation?: true
    claimedAmount?: true
    startDate?: true
    endDate?: true
    nftPassRequired?: true
    requireApproval?: true
    feeAmount?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AirdropSeasonCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    totalAllocation?: true
    claimedAmount?: true
    startDate?: true
    endDate?: true
    nftPassRequired?: true
    requireApproval?: true
    feeAmount?: true
    createdBy?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AirdropSeasonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AirdropSeason to aggregate.
     */
    where?: AirdropSeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AirdropSeasons to fetch.
     */
    orderBy?: AirdropSeasonOrderByWithRelationInput | AirdropSeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AirdropSeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AirdropSeasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AirdropSeasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AirdropSeasons
    **/
    _count?: true | AirdropSeasonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AirdropSeasonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AirdropSeasonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AirdropSeasonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AirdropSeasonMaxAggregateInputType
  }

  export type GetAirdropSeasonAggregateType<T extends AirdropSeasonAggregateArgs> = {
        [P in keyof T & keyof AggregateAirdropSeason]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAirdropSeason[P]>
      : GetScalarType<T[P], AggregateAirdropSeason[P]>
  }




  export type AirdropSeasonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AirdropSeasonWhereInput
    orderBy?: AirdropSeasonOrderByWithAggregationInput | AirdropSeasonOrderByWithAggregationInput[]
    by: AirdropSeasonScalarFieldEnum[] | AirdropSeasonScalarFieldEnum
    having?: AirdropSeasonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AirdropSeasonCountAggregateInputType | true
    _avg?: AirdropSeasonAvgAggregateInputType
    _sum?: AirdropSeasonSumAggregateInputType
    _min?: AirdropSeasonMinAggregateInputType
    _max?: AirdropSeasonMaxAggregateInputType
  }

  export type AirdropSeasonGroupByOutputType = {
    id: string
    name: string
    description: string | null
    status: string
    totalAllocation: bigint
    claimedAmount: bigint
    startDate: Date
    endDate: Date | null
    nftPassRequired: boolean
    requireApproval: boolean
    feeAmount: Decimal
    createdBy: string
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: AirdropSeasonCountAggregateOutputType | null
    _avg: AirdropSeasonAvgAggregateOutputType | null
    _sum: AirdropSeasonSumAggregateOutputType | null
    _min: AirdropSeasonMinAggregateOutputType | null
    _max: AirdropSeasonMaxAggregateOutputType | null
  }

  type GetAirdropSeasonGroupByPayload<T extends AirdropSeasonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AirdropSeasonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AirdropSeasonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AirdropSeasonGroupByOutputType[P]>
            : GetScalarType<T[P], AirdropSeasonGroupByOutputType[P]>
        }
      >
    >


  export type AirdropSeasonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    totalAllocation?: boolean
    claimedAmount?: boolean
    startDate?: boolean
    endDate?: boolean
    nftPassRequired?: boolean
    requireApproval?: boolean
    feeAmount?: boolean
    createdBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    claims?: boolean | AirdropSeason$claimsArgs<ExtArgs>
    _count?: boolean | AirdropSeasonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["airdropSeason"]>

  export type AirdropSeasonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    totalAllocation?: boolean
    claimedAmount?: boolean
    startDate?: boolean
    endDate?: boolean
    nftPassRequired?: boolean
    requireApproval?: boolean
    feeAmount?: boolean
    createdBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["airdropSeason"]>

  export type AirdropSeasonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    totalAllocation?: boolean
    claimedAmount?: boolean
    startDate?: boolean
    endDate?: boolean
    nftPassRequired?: boolean
    requireApproval?: boolean
    feeAmount?: boolean
    createdBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["airdropSeason"]>

  export type AirdropSeasonSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    totalAllocation?: boolean
    claimedAmount?: boolean
    startDate?: boolean
    endDate?: boolean
    nftPassRequired?: boolean
    requireApproval?: boolean
    feeAmount?: boolean
    createdBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AirdropSeasonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "status" | "totalAllocation" | "claimedAmount" | "startDate" | "endDate" | "nftPassRequired" | "requireApproval" | "feeAmount" | "createdBy" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["airdropSeason"]>
  export type AirdropSeasonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    claims?: boolean | AirdropSeason$claimsArgs<ExtArgs>
    _count?: boolean | AirdropSeasonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AirdropSeasonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AirdropSeasonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AirdropSeasonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AirdropSeason"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      claims: Prisma.$AirdropClaimPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      status: string
      totalAllocation: bigint
      claimedAmount: bigint
      startDate: Date
      endDate: Date | null
      nftPassRequired: boolean
      requireApproval: boolean
      feeAmount: Prisma.Decimal
      createdBy: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["airdropSeason"]>
    composites: {}
  }

  type AirdropSeasonGetPayload<S extends boolean | null | undefined | AirdropSeasonDefaultArgs> = $Result.GetResult<Prisma.$AirdropSeasonPayload, S>

  type AirdropSeasonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AirdropSeasonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AirdropSeasonCountAggregateInputType | true
    }

  export interface AirdropSeasonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AirdropSeason'], meta: { name: 'AirdropSeason' } }
    /**
     * Find zero or one AirdropSeason that matches the filter.
     * @param {AirdropSeasonFindUniqueArgs} args - Arguments to find a AirdropSeason
     * @example
     * // Get one AirdropSeason
     * const airdropSeason = await prisma.airdropSeason.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AirdropSeasonFindUniqueArgs>(args: SelectSubset<T, AirdropSeasonFindUniqueArgs<ExtArgs>>): Prisma__AirdropSeasonClient<$Result.GetResult<Prisma.$AirdropSeasonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AirdropSeason that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AirdropSeasonFindUniqueOrThrowArgs} args - Arguments to find a AirdropSeason
     * @example
     * // Get one AirdropSeason
     * const airdropSeason = await prisma.airdropSeason.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AirdropSeasonFindUniqueOrThrowArgs>(args: SelectSubset<T, AirdropSeasonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AirdropSeasonClient<$Result.GetResult<Prisma.$AirdropSeasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AirdropSeason that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirdropSeasonFindFirstArgs} args - Arguments to find a AirdropSeason
     * @example
     * // Get one AirdropSeason
     * const airdropSeason = await prisma.airdropSeason.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AirdropSeasonFindFirstArgs>(args?: SelectSubset<T, AirdropSeasonFindFirstArgs<ExtArgs>>): Prisma__AirdropSeasonClient<$Result.GetResult<Prisma.$AirdropSeasonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AirdropSeason that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirdropSeasonFindFirstOrThrowArgs} args - Arguments to find a AirdropSeason
     * @example
     * // Get one AirdropSeason
     * const airdropSeason = await prisma.airdropSeason.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AirdropSeasonFindFirstOrThrowArgs>(args?: SelectSubset<T, AirdropSeasonFindFirstOrThrowArgs<ExtArgs>>): Prisma__AirdropSeasonClient<$Result.GetResult<Prisma.$AirdropSeasonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AirdropSeasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirdropSeasonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AirdropSeasons
     * const airdropSeasons = await prisma.airdropSeason.findMany()
     * 
     * // Get first 10 AirdropSeasons
     * const airdropSeasons = await prisma.airdropSeason.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const airdropSeasonWithIdOnly = await prisma.airdropSeason.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AirdropSeasonFindManyArgs>(args?: SelectSubset<T, AirdropSeasonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AirdropSeasonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AirdropSeason.
     * @param {AirdropSeasonCreateArgs} args - Arguments to create a AirdropSeason.
     * @example
     * // Create one AirdropSeason
     * const AirdropSeason = await prisma.airdropSeason.create({
     *   data: {
     *     // ... data to create a AirdropSeason
     *   }
     * })
     * 
     */
    create<T extends AirdropSeasonCreateArgs>(args: SelectSubset<T, AirdropSeasonCreateArgs<ExtArgs>>): Prisma__AirdropSeasonClient<$Result.GetResult<Prisma.$AirdropSeasonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AirdropSeasons.
     * @param {AirdropSeasonCreateManyArgs} args - Arguments to create many AirdropSeasons.
     * @example
     * // Create many AirdropSeasons
     * const airdropSeason = await prisma.airdropSeason.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AirdropSeasonCreateManyArgs>(args?: SelectSubset<T, AirdropSeasonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AirdropSeasons and returns the data saved in the database.
     * @param {AirdropSeasonCreateManyAndReturnArgs} args - Arguments to create many AirdropSeasons.
     * @example
     * // Create many AirdropSeasons
     * const airdropSeason = await prisma.airdropSeason.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AirdropSeasons and only return the `id`
     * const airdropSeasonWithIdOnly = await prisma.airdropSeason.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AirdropSeasonCreateManyAndReturnArgs>(args?: SelectSubset<T, AirdropSeasonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AirdropSeasonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AirdropSeason.
     * @param {AirdropSeasonDeleteArgs} args - Arguments to delete one AirdropSeason.
     * @example
     * // Delete one AirdropSeason
     * const AirdropSeason = await prisma.airdropSeason.delete({
     *   where: {
     *     // ... filter to delete one AirdropSeason
     *   }
     * })
     * 
     */
    delete<T extends AirdropSeasonDeleteArgs>(args: SelectSubset<T, AirdropSeasonDeleteArgs<ExtArgs>>): Prisma__AirdropSeasonClient<$Result.GetResult<Prisma.$AirdropSeasonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AirdropSeason.
     * @param {AirdropSeasonUpdateArgs} args - Arguments to update one AirdropSeason.
     * @example
     * // Update one AirdropSeason
     * const airdropSeason = await prisma.airdropSeason.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AirdropSeasonUpdateArgs>(args: SelectSubset<T, AirdropSeasonUpdateArgs<ExtArgs>>): Prisma__AirdropSeasonClient<$Result.GetResult<Prisma.$AirdropSeasonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AirdropSeasons.
     * @param {AirdropSeasonDeleteManyArgs} args - Arguments to filter AirdropSeasons to delete.
     * @example
     * // Delete a few AirdropSeasons
     * const { count } = await prisma.airdropSeason.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AirdropSeasonDeleteManyArgs>(args?: SelectSubset<T, AirdropSeasonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AirdropSeasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirdropSeasonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AirdropSeasons
     * const airdropSeason = await prisma.airdropSeason.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AirdropSeasonUpdateManyArgs>(args: SelectSubset<T, AirdropSeasonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AirdropSeasons and returns the data updated in the database.
     * @param {AirdropSeasonUpdateManyAndReturnArgs} args - Arguments to update many AirdropSeasons.
     * @example
     * // Update many AirdropSeasons
     * const airdropSeason = await prisma.airdropSeason.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AirdropSeasons and only return the `id`
     * const airdropSeasonWithIdOnly = await prisma.airdropSeason.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AirdropSeasonUpdateManyAndReturnArgs>(args: SelectSubset<T, AirdropSeasonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AirdropSeasonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AirdropSeason.
     * @param {AirdropSeasonUpsertArgs} args - Arguments to update or create a AirdropSeason.
     * @example
     * // Update or create a AirdropSeason
     * const airdropSeason = await prisma.airdropSeason.upsert({
     *   create: {
     *     // ... data to create a AirdropSeason
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AirdropSeason we want to update
     *   }
     * })
     */
    upsert<T extends AirdropSeasonUpsertArgs>(args: SelectSubset<T, AirdropSeasonUpsertArgs<ExtArgs>>): Prisma__AirdropSeasonClient<$Result.GetResult<Prisma.$AirdropSeasonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AirdropSeasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirdropSeasonCountArgs} args - Arguments to filter AirdropSeasons to count.
     * @example
     * // Count the number of AirdropSeasons
     * const count = await prisma.airdropSeason.count({
     *   where: {
     *     // ... the filter for the AirdropSeasons we want to count
     *   }
     * })
    **/
    count<T extends AirdropSeasonCountArgs>(
      args?: Subset<T, AirdropSeasonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AirdropSeasonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AirdropSeason.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirdropSeasonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AirdropSeasonAggregateArgs>(args: Subset<T, AirdropSeasonAggregateArgs>): Prisma.PrismaPromise<GetAirdropSeasonAggregateType<T>>

    /**
     * Group by AirdropSeason.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirdropSeasonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AirdropSeasonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AirdropSeasonGroupByArgs['orderBy'] }
        : { orderBy?: AirdropSeasonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AirdropSeasonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAirdropSeasonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AirdropSeason model
   */
  readonly fields: AirdropSeasonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AirdropSeason.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AirdropSeasonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    claims<T extends AirdropSeason$claimsArgs<ExtArgs> = {}>(args?: Subset<T, AirdropSeason$claimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AirdropClaimPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AirdropSeason model
   */
  interface AirdropSeasonFieldRefs {
    readonly id: FieldRef<"AirdropSeason", 'String'>
    readonly name: FieldRef<"AirdropSeason", 'String'>
    readonly description: FieldRef<"AirdropSeason", 'String'>
    readonly status: FieldRef<"AirdropSeason", 'String'>
    readonly totalAllocation: FieldRef<"AirdropSeason", 'BigInt'>
    readonly claimedAmount: FieldRef<"AirdropSeason", 'BigInt'>
    readonly startDate: FieldRef<"AirdropSeason", 'DateTime'>
    readonly endDate: FieldRef<"AirdropSeason", 'DateTime'>
    readonly nftPassRequired: FieldRef<"AirdropSeason", 'Boolean'>
    readonly requireApproval: FieldRef<"AirdropSeason", 'Boolean'>
    readonly feeAmount: FieldRef<"AirdropSeason", 'Decimal'>
    readonly createdBy: FieldRef<"AirdropSeason", 'String'>
    readonly metadata: FieldRef<"AirdropSeason", 'Json'>
    readonly createdAt: FieldRef<"AirdropSeason", 'DateTime'>
    readonly updatedAt: FieldRef<"AirdropSeason", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AirdropSeason findUnique
   */
  export type AirdropSeasonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropSeason
     */
    select?: AirdropSeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropSeason
     */
    omit?: AirdropSeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropSeasonInclude<ExtArgs> | null
    /**
     * Filter, which AirdropSeason to fetch.
     */
    where: AirdropSeasonWhereUniqueInput
  }

  /**
   * AirdropSeason findUniqueOrThrow
   */
  export type AirdropSeasonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropSeason
     */
    select?: AirdropSeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropSeason
     */
    omit?: AirdropSeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropSeasonInclude<ExtArgs> | null
    /**
     * Filter, which AirdropSeason to fetch.
     */
    where: AirdropSeasonWhereUniqueInput
  }

  /**
   * AirdropSeason findFirst
   */
  export type AirdropSeasonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropSeason
     */
    select?: AirdropSeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropSeason
     */
    omit?: AirdropSeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropSeasonInclude<ExtArgs> | null
    /**
     * Filter, which AirdropSeason to fetch.
     */
    where?: AirdropSeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AirdropSeasons to fetch.
     */
    orderBy?: AirdropSeasonOrderByWithRelationInput | AirdropSeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AirdropSeasons.
     */
    cursor?: AirdropSeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AirdropSeasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AirdropSeasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AirdropSeasons.
     */
    distinct?: AirdropSeasonScalarFieldEnum | AirdropSeasonScalarFieldEnum[]
  }

  /**
   * AirdropSeason findFirstOrThrow
   */
  export type AirdropSeasonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropSeason
     */
    select?: AirdropSeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropSeason
     */
    omit?: AirdropSeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropSeasonInclude<ExtArgs> | null
    /**
     * Filter, which AirdropSeason to fetch.
     */
    where?: AirdropSeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AirdropSeasons to fetch.
     */
    orderBy?: AirdropSeasonOrderByWithRelationInput | AirdropSeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AirdropSeasons.
     */
    cursor?: AirdropSeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AirdropSeasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AirdropSeasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AirdropSeasons.
     */
    distinct?: AirdropSeasonScalarFieldEnum | AirdropSeasonScalarFieldEnum[]
  }

  /**
   * AirdropSeason findMany
   */
  export type AirdropSeasonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropSeason
     */
    select?: AirdropSeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropSeason
     */
    omit?: AirdropSeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropSeasonInclude<ExtArgs> | null
    /**
     * Filter, which AirdropSeasons to fetch.
     */
    where?: AirdropSeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AirdropSeasons to fetch.
     */
    orderBy?: AirdropSeasonOrderByWithRelationInput | AirdropSeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AirdropSeasons.
     */
    cursor?: AirdropSeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AirdropSeasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AirdropSeasons.
     */
    skip?: number
    distinct?: AirdropSeasonScalarFieldEnum | AirdropSeasonScalarFieldEnum[]
  }

  /**
   * AirdropSeason create
   */
  export type AirdropSeasonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropSeason
     */
    select?: AirdropSeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropSeason
     */
    omit?: AirdropSeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropSeasonInclude<ExtArgs> | null
    /**
     * The data needed to create a AirdropSeason.
     */
    data: XOR<AirdropSeasonCreateInput, AirdropSeasonUncheckedCreateInput>
  }

  /**
   * AirdropSeason createMany
   */
  export type AirdropSeasonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AirdropSeasons.
     */
    data: AirdropSeasonCreateManyInput | AirdropSeasonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AirdropSeason createManyAndReturn
   */
  export type AirdropSeasonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropSeason
     */
    select?: AirdropSeasonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropSeason
     */
    omit?: AirdropSeasonOmit<ExtArgs> | null
    /**
     * The data used to create many AirdropSeasons.
     */
    data: AirdropSeasonCreateManyInput | AirdropSeasonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropSeasonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AirdropSeason update
   */
  export type AirdropSeasonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropSeason
     */
    select?: AirdropSeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropSeason
     */
    omit?: AirdropSeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropSeasonInclude<ExtArgs> | null
    /**
     * The data needed to update a AirdropSeason.
     */
    data: XOR<AirdropSeasonUpdateInput, AirdropSeasonUncheckedUpdateInput>
    /**
     * Choose, which AirdropSeason to update.
     */
    where: AirdropSeasonWhereUniqueInput
  }

  /**
   * AirdropSeason updateMany
   */
  export type AirdropSeasonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AirdropSeasons.
     */
    data: XOR<AirdropSeasonUpdateManyMutationInput, AirdropSeasonUncheckedUpdateManyInput>
    /**
     * Filter which AirdropSeasons to update
     */
    where?: AirdropSeasonWhereInput
    /**
     * Limit how many AirdropSeasons to update.
     */
    limit?: number
  }

  /**
   * AirdropSeason updateManyAndReturn
   */
  export type AirdropSeasonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropSeason
     */
    select?: AirdropSeasonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropSeason
     */
    omit?: AirdropSeasonOmit<ExtArgs> | null
    /**
     * The data used to update AirdropSeasons.
     */
    data: XOR<AirdropSeasonUpdateManyMutationInput, AirdropSeasonUncheckedUpdateManyInput>
    /**
     * Filter which AirdropSeasons to update
     */
    where?: AirdropSeasonWhereInput
    /**
     * Limit how many AirdropSeasons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropSeasonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AirdropSeason upsert
   */
  export type AirdropSeasonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropSeason
     */
    select?: AirdropSeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropSeason
     */
    omit?: AirdropSeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropSeasonInclude<ExtArgs> | null
    /**
     * The filter to search for the AirdropSeason to update in case it exists.
     */
    where: AirdropSeasonWhereUniqueInput
    /**
     * In case the AirdropSeason found by the `where` argument doesn't exist, create a new AirdropSeason with this data.
     */
    create: XOR<AirdropSeasonCreateInput, AirdropSeasonUncheckedCreateInput>
    /**
     * In case the AirdropSeason was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AirdropSeasonUpdateInput, AirdropSeasonUncheckedUpdateInput>
  }

  /**
   * AirdropSeason delete
   */
  export type AirdropSeasonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropSeason
     */
    select?: AirdropSeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropSeason
     */
    omit?: AirdropSeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropSeasonInclude<ExtArgs> | null
    /**
     * Filter which AirdropSeason to delete.
     */
    where: AirdropSeasonWhereUniqueInput
  }

  /**
   * AirdropSeason deleteMany
   */
  export type AirdropSeasonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AirdropSeasons to delete
     */
    where?: AirdropSeasonWhereInput
    /**
     * Limit how many AirdropSeasons to delete.
     */
    limit?: number
  }

  /**
   * AirdropSeason.claims
   */
  export type AirdropSeason$claimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropClaim
     */
    select?: AirdropClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropClaim
     */
    omit?: AirdropClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropClaimInclude<ExtArgs> | null
    where?: AirdropClaimWhereInput
    orderBy?: AirdropClaimOrderByWithRelationInput | AirdropClaimOrderByWithRelationInput[]
    cursor?: AirdropClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AirdropClaimScalarFieldEnum | AirdropClaimScalarFieldEnum[]
  }

  /**
   * AirdropSeason without action
   */
  export type AirdropSeasonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropSeason
     */
    select?: AirdropSeasonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropSeason
     */
    omit?: AirdropSeasonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropSeasonInclude<ExtArgs> | null
  }


  /**
   * Model AirdropClaim
   */

  export type AggregateAirdropClaim = {
    _count: AirdropClaimCountAggregateOutputType | null
    _avg: AirdropClaimAvgAggregateOutputType | null
    _sum: AirdropClaimSumAggregateOutputType | null
    _min: AirdropClaimMinAggregateOutputType | null
    _max: AirdropClaimMaxAggregateOutputType | null
  }

  export type AirdropClaimAvgAggregateOutputType = {
    tokens: number | null
  }

  export type AirdropClaimSumAggregateOutputType = {
    tokens: number | null
  }

  export type AirdropClaimMinAggregateOutputType = {
    id: string | null
    userId: string | null
    seasonId: string | null
    tokens: number | null
    tier: string | null
    paymentSignature: string | null
    transactionSignature: string | null
    status: string | null
    claimedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AirdropClaimMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    seasonId: string | null
    tokens: number | null
    tier: string | null
    paymentSignature: string | null
    transactionSignature: string | null
    status: string | null
    claimedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AirdropClaimCountAggregateOutputType = {
    id: number
    userId: number
    seasonId: number
    tokens: number
    tier: number
    paymentSignature: number
    transactionSignature: number
    status: number
    claimedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AirdropClaimAvgAggregateInputType = {
    tokens?: true
  }

  export type AirdropClaimSumAggregateInputType = {
    tokens?: true
  }

  export type AirdropClaimMinAggregateInputType = {
    id?: true
    userId?: true
    seasonId?: true
    tokens?: true
    tier?: true
    paymentSignature?: true
    transactionSignature?: true
    status?: true
    claimedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AirdropClaimMaxAggregateInputType = {
    id?: true
    userId?: true
    seasonId?: true
    tokens?: true
    tier?: true
    paymentSignature?: true
    transactionSignature?: true
    status?: true
    claimedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AirdropClaimCountAggregateInputType = {
    id?: true
    userId?: true
    seasonId?: true
    tokens?: true
    tier?: true
    paymentSignature?: true
    transactionSignature?: true
    status?: true
    claimedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AirdropClaimAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AirdropClaim to aggregate.
     */
    where?: AirdropClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AirdropClaims to fetch.
     */
    orderBy?: AirdropClaimOrderByWithRelationInput | AirdropClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AirdropClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AirdropClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AirdropClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AirdropClaims
    **/
    _count?: true | AirdropClaimCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AirdropClaimAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AirdropClaimSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AirdropClaimMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AirdropClaimMaxAggregateInputType
  }

  export type GetAirdropClaimAggregateType<T extends AirdropClaimAggregateArgs> = {
        [P in keyof T & keyof AggregateAirdropClaim]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAirdropClaim[P]>
      : GetScalarType<T[P], AggregateAirdropClaim[P]>
  }




  export type AirdropClaimGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AirdropClaimWhereInput
    orderBy?: AirdropClaimOrderByWithAggregationInput | AirdropClaimOrderByWithAggregationInput[]
    by: AirdropClaimScalarFieldEnum[] | AirdropClaimScalarFieldEnum
    having?: AirdropClaimScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AirdropClaimCountAggregateInputType | true
    _avg?: AirdropClaimAvgAggregateInputType
    _sum?: AirdropClaimSumAggregateInputType
    _min?: AirdropClaimMinAggregateInputType
    _max?: AirdropClaimMaxAggregateInputType
  }

  export type AirdropClaimGroupByOutputType = {
    id: string
    userId: string
    seasonId: string
    tokens: number
    tier: string
    paymentSignature: string
    transactionSignature: string | null
    status: string
    claimedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: AirdropClaimCountAggregateOutputType | null
    _avg: AirdropClaimAvgAggregateOutputType | null
    _sum: AirdropClaimSumAggregateOutputType | null
    _min: AirdropClaimMinAggregateOutputType | null
    _max: AirdropClaimMaxAggregateOutputType | null
  }

  type GetAirdropClaimGroupByPayload<T extends AirdropClaimGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AirdropClaimGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AirdropClaimGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AirdropClaimGroupByOutputType[P]>
            : GetScalarType<T[P], AirdropClaimGroupByOutputType[P]>
        }
      >
    >


  export type AirdropClaimSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    seasonId?: boolean
    tokens?: boolean
    tier?: boolean
    paymentSignature?: boolean
    transactionSignature?: boolean
    status?: boolean
    claimedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    season?: boolean | AirdropSeasonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["airdropClaim"]>

  export type AirdropClaimSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    seasonId?: boolean
    tokens?: boolean
    tier?: boolean
    paymentSignature?: boolean
    transactionSignature?: boolean
    status?: boolean
    claimedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    season?: boolean | AirdropSeasonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["airdropClaim"]>

  export type AirdropClaimSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    seasonId?: boolean
    tokens?: boolean
    tier?: boolean
    paymentSignature?: boolean
    transactionSignature?: boolean
    status?: boolean
    claimedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    season?: boolean | AirdropSeasonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["airdropClaim"]>

  export type AirdropClaimSelectScalar = {
    id?: boolean
    userId?: boolean
    seasonId?: boolean
    tokens?: boolean
    tier?: boolean
    paymentSignature?: boolean
    transactionSignature?: boolean
    status?: boolean
    claimedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AirdropClaimOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "seasonId" | "tokens" | "tier" | "paymentSignature" | "transactionSignature" | "status" | "claimedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["airdropClaim"]>
  export type AirdropClaimInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    season?: boolean | AirdropSeasonDefaultArgs<ExtArgs>
  }
  export type AirdropClaimIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    season?: boolean | AirdropSeasonDefaultArgs<ExtArgs>
  }
  export type AirdropClaimIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    season?: boolean | AirdropSeasonDefaultArgs<ExtArgs>
  }

  export type $AirdropClaimPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AirdropClaim"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      season: Prisma.$AirdropSeasonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      seasonId: string
      tokens: number
      tier: string
      paymentSignature: string
      transactionSignature: string | null
      status: string
      claimedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["airdropClaim"]>
    composites: {}
  }

  type AirdropClaimGetPayload<S extends boolean | null | undefined | AirdropClaimDefaultArgs> = $Result.GetResult<Prisma.$AirdropClaimPayload, S>

  type AirdropClaimCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AirdropClaimFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AirdropClaimCountAggregateInputType | true
    }

  export interface AirdropClaimDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AirdropClaim'], meta: { name: 'AirdropClaim' } }
    /**
     * Find zero or one AirdropClaim that matches the filter.
     * @param {AirdropClaimFindUniqueArgs} args - Arguments to find a AirdropClaim
     * @example
     * // Get one AirdropClaim
     * const airdropClaim = await prisma.airdropClaim.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AirdropClaimFindUniqueArgs>(args: SelectSubset<T, AirdropClaimFindUniqueArgs<ExtArgs>>): Prisma__AirdropClaimClient<$Result.GetResult<Prisma.$AirdropClaimPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AirdropClaim that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AirdropClaimFindUniqueOrThrowArgs} args - Arguments to find a AirdropClaim
     * @example
     * // Get one AirdropClaim
     * const airdropClaim = await prisma.airdropClaim.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AirdropClaimFindUniqueOrThrowArgs>(args: SelectSubset<T, AirdropClaimFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AirdropClaimClient<$Result.GetResult<Prisma.$AirdropClaimPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AirdropClaim that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirdropClaimFindFirstArgs} args - Arguments to find a AirdropClaim
     * @example
     * // Get one AirdropClaim
     * const airdropClaim = await prisma.airdropClaim.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AirdropClaimFindFirstArgs>(args?: SelectSubset<T, AirdropClaimFindFirstArgs<ExtArgs>>): Prisma__AirdropClaimClient<$Result.GetResult<Prisma.$AirdropClaimPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AirdropClaim that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirdropClaimFindFirstOrThrowArgs} args - Arguments to find a AirdropClaim
     * @example
     * // Get one AirdropClaim
     * const airdropClaim = await prisma.airdropClaim.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AirdropClaimFindFirstOrThrowArgs>(args?: SelectSubset<T, AirdropClaimFindFirstOrThrowArgs<ExtArgs>>): Prisma__AirdropClaimClient<$Result.GetResult<Prisma.$AirdropClaimPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AirdropClaims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirdropClaimFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AirdropClaims
     * const airdropClaims = await prisma.airdropClaim.findMany()
     * 
     * // Get first 10 AirdropClaims
     * const airdropClaims = await prisma.airdropClaim.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const airdropClaimWithIdOnly = await prisma.airdropClaim.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AirdropClaimFindManyArgs>(args?: SelectSubset<T, AirdropClaimFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AirdropClaimPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AirdropClaim.
     * @param {AirdropClaimCreateArgs} args - Arguments to create a AirdropClaim.
     * @example
     * // Create one AirdropClaim
     * const AirdropClaim = await prisma.airdropClaim.create({
     *   data: {
     *     // ... data to create a AirdropClaim
     *   }
     * })
     * 
     */
    create<T extends AirdropClaimCreateArgs>(args: SelectSubset<T, AirdropClaimCreateArgs<ExtArgs>>): Prisma__AirdropClaimClient<$Result.GetResult<Prisma.$AirdropClaimPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AirdropClaims.
     * @param {AirdropClaimCreateManyArgs} args - Arguments to create many AirdropClaims.
     * @example
     * // Create many AirdropClaims
     * const airdropClaim = await prisma.airdropClaim.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AirdropClaimCreateManyArgs>(args?: SelectSubset<T, AirdropClaimCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AirdropClaims and returns the data saved in the database.
     * @param {AirdropClaimCreateManyAndReturnArgs} args - Arguments to create many AirdropClaims.
     * @example
     * // Create many AirdropClaims
     * const airdropClaim = await prisma.airdropClaim.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AirdropClaims and only return the `id`
     * const airdropClaimWithIdOnly = await prisma.airdropClaim.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AirdropClaimCreateManyAndReturnArgs>(args?: SelectSubset<T, AirdropClaimCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AirdropClaimPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AirdropClaim.
     * @param {AirdropClaimDeleteArgs} args - Arguments to delete one AirdropClaim.
     * @example
     * // Delete one AirdropClaim
     * const AirdropClaim = await prisma.airdropClaim.delete({
     *   where: {
     *     // ... filter to delete one AirdropClaim
     *   }
     * })
     * 
     */
    delete<T extends AirdropClaimDeleteArgs>(args: SelectSubset<T, AirdropClaimDeleteArgs<ExtArgs>>): Prisma__AirdropClaimClient<$Result.GetResult<Prisma.$AirdropClaimPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AirdropClaim.
     * @param {AirdropClaimUpdateArgs} args - Arguments to update one AirdropClaim.
     * @example
     * // Update one AirdropClaim
     * const airdropClaim = await prisma.airdropClaim.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AirdropClaimUpdateArgs>(args: SelectSubset<T, AirdropClaimUpdateArgs<ExtArgs>>): Prisma__AirdropClaimClient<$Result.GetResult<Prisma.$AirdropClaimPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AirdropClaims.
     * @param {AirdropClaimDeleteManyArgs} args - Arguments to filter AirdropClaims to delete.
     * @example
     * // Delete a few AirdropClaims
     * const { count } = await prisma.airdropClaim.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AirdropClaimDeleteManyArgs>(args?: SelectSubset<T, AirdropClaimDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AirdropClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirdropClaimUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AirdropClaims
     * const airdropClaim = await prisma.airdropClaim.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AirdropClaimUpdateManyArgs>(args: SelectSubset<T, AirdropClaimUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AirdropClaims and returns the data updated in the database.
     * @param {AirdropClaimUpdateManyAndReturnArgs} args - Arguments to update many AirdropClaims.
     * @example
     * // Update many AirdropClaims
     * const airdropClaim = await prisma.airdropClaim.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AirdropClaims and only return the `id`
     * const airdropClaimWithIdOnly = await prisma.airdropClaim.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AirdropClaimUpdateManyAndReturnArgs>(args: SelectSubset<T, AirdropClaimUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AirdropClaimPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AirdropClaim.
     * @param {AirdropClaimUpsertArgs} args - Arguments to update or create a AirdropClaim.
     * @example
     * // Update or create a AirdropClaim
     * const airdropClaim = await prisma.airdropClaim.upsert({
     *   create: {
     *     // ... data to create a AirdropClaim
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AirdropClaim we want to update
     *   }
     * })
     */
    upsert<T extends AirdropClaimUpsertArgs>(args: SelectSubset<T, AirdropClaimUpsertArgs<ExtArgs>>): Prisma__AirdropClaimClient<$Result.GetResult<Prisma.$AirdropClaimPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AirdropClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirdropClaimCountArgs} args - Arguments to filter AirdropClaims to count.
     * @example
     * // Count the number of AirdropClaims
     * const count = await prisma.airdropClaim.count({
     *   where: {
     *     // ... the filter for the AirdropClaims we want to count
     *   }
     * })
    **/
    count<T extends AirdropClaimCountArgs>(
      args?: Subset<T, AirdropClaimCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AirdropClaimCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AirdropClaim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirdropClaimAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AirdropClaimAggregateArgs>(args: Subset<T, AirdropClaimAggregateArgs>): Prisma.PrismaPromise<GetAirdropClaimAggregateType<T>>

    /**
     * Group by AirdropClaim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AirdropClaimGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AirdropClaimGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AirdropClaimGroupByArgs['orderBy'] }
        : { orderBy?: AirdropClaimGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AirdropClaimGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAirdropClaimGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AirdropClaim model
   */
  readonly fields: AirdropClaimFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AirdropClaim.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AirdropClaimClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    season<T extends AirdropSeasonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AirdropSeasonDefaultArgs<ExtArgs>>): Prisma__AirdropSeasonClient<$Result.GetResult<Prisma.$AirdropSeasonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AirdropClaim model
   */
  interface AirdropClaimFieldRefs {
    readonly id: FieldRef<"AirdropClaim", 'String'>
    readonly userId: FieldRef<"AirdropClaim", 'String'>
    readonly seasonId: FieldRef<"AirdropClaim", 'String'>
    readonly tokens: FieldRef<"AirdropClaim", 'Float'>
    readonly tier: FieldRef<"AirdropClaim", 'String'>
    readonly paymentSignature: FieldRef<"AirdropClaim", 'String'>
    readonly transactionSignature: FieldRef<"AirdropClaim", 'String'>
    readonly status: FieldRef<"AirdropClaim", 'String'>
    readonly claimedAt: FieldRef<"AirdropClaim", 'DateTime'>
    readonly createdAt: FieldRef<"AirdropClaim", 'DateTime'>
    readonly updatedAt: FieldRef<"AirdropClaim", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AirdropClaim findUnique
   */
  export type AirdropClaimFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropClaim
     */
    select?: AirdropClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropClaim
     */
    omit?: AirdropClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropClaimInclude<ExtArgs> | null
    /**
     * Filter, which AirdropClaim to fetch.
     */
    where: AirdropClaimWhereUniqueInput
  }

  /**
   * AirdropClaim findUniqueOrThrow
   */
  export type AirdropClaimFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropClaim
     */
    select?: AirdropClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropClaim
     */
    omit?: AirdropClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropClaimInclude<ExtArgs> | null
    /**
     * Filter, which AirdropClaim to fetch.
     */
    where: AirdropClaimWhereUniqueInput
  }

  /**
   * AirdropClaim findFirst
   */
  export type AirdropClaimFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropClaim
     */
    select?: AirdropClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropClaim
     */
    omit?: AirdropClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropClaimInclude<ExtArgs> | null
    /**
     * Filter, which AirdropClaim to fetch.
     */
    where?: AirdropClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AirdropClaims to fetch.
     */
    orderBy?: AirdropClaimOrderByWithRelationInput | AirdropClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AirdropClaims.
     */
    cursor?: AirdropClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AirdropClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AirdropClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AirdropClaims.
     */
    distinct?: AirdropClaimScalarFieldEnum | AirdropClaimScalarFieldEnum[]
  }

  /**
   * AirdropClaim findFirstOrThrow
   */
  export type AirdropClaimFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropClaim
     */
    select?: AirdropClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropClaim
     */
    omit?: AirdropClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropClaimInclude<ExtArgs> | null
    /**
     * Filter, which AirdropClaim to fetch.
     */
    where?: AirdropClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AirdropClaims to fetch.
     */
    orderBy?: AirdropClaimOrderByWithRelationInput | AirdropClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AirdropClaims.
     */
    cursor?: AirdropClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AirdropClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AirdropClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AirdropClaims.
     */
    distinct?: AirdropClaimScalarFieldEnum | AirdropClaimScalarFieldEnum[]
  }

  /**
   * AirdropClaim findMany
   */
  export type AirdropClaimFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropClaim
     */
    select?: AirdropClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropClaim
     */
    omit?: AirdropClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropClaimInclude<ExtArgs> | null
    /**
     * Filter, which AirdropClaims to fetch.
     */
    where?: AirdropClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AirdropClaims to fetch.
     */
    orderBy?: AirdropClaimOrderByWithRelationInput | AirdropClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AirdropClaims.
     */
    cursor?: AirdropClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AirdropClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AirdropClaims.
     */
    skip?: number
    distinct?: AirdropClaimScalarFieldEnum | AirdropClaimScalarFieldEnum[]
  }

  /**
   * AirdropClaim create
   */
  export type AirdropClaimCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropClaim
     */
    select?: AirdropClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropClaim
     */
    omit?: AirdropClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropClaimInclude<ExtArgs> | null
    /**
     * The data needed to create a AirdropClaim.
     */
    data: XOR<AirdropClaimCreateInput, AirdropClaimUncheckedCreateInput>
  }

  /**
   * AirdropClaim createMany
   */
  export type AirdropClaimCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AirdropClaims.
     */
    data: AirdropClaimCreateManyInput | AirdropClaimCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AirdropClaim createManyAndReturn
   */
  export type AirdropClaimCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropClaim
     */
    select?: AirdropClaimSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropClaim
     */
    omit?: AirdropClaimOmit<ExtArgs> | null
    /**
     * The data used to create many AirdropClaims.
     */
    data: AirdropClaimCreateManyInput | AirdropClaimCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropClaimIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AirdropClaim update
   */
  export type AirdropClaimUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropClaim
     */
    select?: AirdropClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropClaim
     */
    omit?: AirdropClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropClaimInclude<ExtArgs> | null
    /**
     * The data needed to update a AirdropClaim.
     */
    data: XOR<AirdropClaimUpdateInput, AirdropClaimUncheckedUpdateInput>
    /**
     * Choose, which AirdropClaim to update.
     */
    where: AirdropClaimWhereUniqueInput
  }

  /**
   * AirdropClaim updateMany
   */
  export type AirdropClaimUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AirdropClaims.
     */
    data: XOR<AirdropClaimUpdateManyMutationInput, AirdropClaimUncheckedUpdateManyInput>
    /**
     * Filter which AirdropClaims to update
     */
    where?: AirdropClaimWhereInput
    /**
     * Limit how many AirdropClaims to update.
     */
    limit?: number
  }

  /**
   * AirdropClaim updateManyAndReturn
   */
  export type AirdropClaimUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropClaim
     */
    select?: AirdropClaimSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropClaim
     */
    omit?: AirdropClaimOmit<ExtArgs> | null
    /**
     * The data used to update AirdropClaims.
     */
    data: XOR<AirdropClaimUpdateManyMutationInput, AirdropClaimUncheckedUpdateManyInput>
    /**
     * Filter which AirdropClaims to update
     */
    where?: AirdropClaimWhereInput
    /**
     * Limit how many AirdropClaims to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropClaimIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AirdropClaim upsert
   */
  export type AirdropClaimUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropClaim
     */
    select?: AirdropClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropClaim
     */
    omit?: AirdropClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropClaimInclude<ExtArgs> | null
    /**
     * The filter to search for the AirdropClaim to update in case it exists.
     */
    where: AirdropClaimWhereUniqueInput
    /**
     * In case the AirdropClaim found by the `where` argument doesn't exist, create a new AirdropClaim with this data.
     */
    create: XOR<AirdropClaimCreateInput, AirdropClaimUncheckedCreateInput>
    /**
     * In case the AirdropClaim was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AirdropClaimUpdateInput, AirdropClaimUncheckedUpdateInput>
  }

  /**
   * AirdropClaim delete
   */
  export type AirdropClaimDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropClaim
     */
    select?: AirdropClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropClaim
     */
    omit?: AirdropClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropClaimInclude<ExtArgs> | null
    /**
     * Filter which AirdropClaim to delete.
     */
    where: AirdropClaimWhereUniqueInput
  }

  /**
   * AirdropClaim deleteMany
   */
  export type AirdropClaimDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AirdropClaims to delete
     */
    where?: AirdropClaimWhereInput
    /**
     * Limit how many AirdropClaims to delete.
     */
    limit?: number
  }

  /**
   * AirdropClaim without action
   */
  export type AirdropClaimDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AirdropClaim
     */
    select?: AirdropClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AirdropClaim
     */
    omit?: AirdropClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AirdropClaimInclude<ExtArgs> | null
  }


  /**
   * Model NftCollection
   */

  export type AggregateNftCollection = {
    _count: NftCollectionCountAggregateOutputType | null
    _avg: NftCollectionAvgAggregateOutputType | null
    _sum: NftCollectionSumAggregateOutputType | null
    _min: NftCollectionMinAggregateOutputType | null
    _max: NftCollectionMaxAggregateOutputType | null
  }

  export type NftCollectionAvgAggregateOutputType = {
    supply: number | null
  }

  export type NftCollectionSumAggregateOutputType = {
    supply: number | null
  }

  export type NftCollectionMinAggregateOutputType = {
    id: string | null
    mintAddress: string | null
    name: string | null
    symbol: string | null
    description: string | null
    uri: string | null
    supply: number | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NftCollectionMaxAggregateOutputType = {
    id: string | null
    mintAddress: string | null
    name: string | null
    symbol: string | null
    description: string | null
    uri: string | null
    supply: number | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NftCollectionCountAggregateOutputType = {
    id: number
    mintAddress: number
    name: number
    symbol: number
    description: number
    uri: number
    supply: number
    createdBy: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NftCollectionAvgAggregateInputType = {
    supply?: true
  }

  export type NftCollectionSumAggregateInputType = {
    supply?: true
  }

  export type NftCollectionMinAggregateInputType = {
    id?: true
    mintAddress?: true
    name?: true
    symbol?: true
    description?: true
    uri?: true
    supply?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NftCollectionMaxAggregateInputType = {
    id?: true
    mintAddress?: true
    name?: true
    symbol?: true
    description?: true
    uri?: true
    supply?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NftCollectionCountAggregateInputType = {
    id?: true
    mintAddress?: true
    name?: true
    symbol?: true
    description?: true
    uri?: true
    supply?: true
    createdBy?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NftCollectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NftCollection to aggregate.
     */
    where?: NftCollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NftCollections to fetch.
     */
    orderBy?: NftCollectionOrderByWithRelationInput | NftCollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NftCollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NftCollections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NftCollections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NftCollections
    **/
    _count?: true | NftCollectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NftCollectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NftCollectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NftCollectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NftCollectionMaxAggregateInputType
  }

  export type GetNftCollectionAggregateType<T extends NftCollectionAggregateArgs> = {
        [P in keyof T & keyof AggregateNftCollection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNftCollection[P]>
      : GetScalarType<T[P], AggregateNftCollection[P]>
  }




  export type NftCollectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NftCollectionWhereInput
    orderBy?: NftCollectionOrderByWithAggregationInput | NftCollectionOrderByWithAggregationInput[]
    by: NftCollectionScalarFieldEnum[] | NftCollectionScalarFieldEnum
    having?: NftCollectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NftCollectionCountAggregateInputType | true
    _avg?: NftCollectionAvgAggregateInputType
    _sum?: NftCollectionSumAggregateInputType
    _min?: NftCollectionMinAggregateInputType
    _max?: NftCollectionMaxAggregateInputType
  }

  export type NftCollectionGroupByOutputType = {
    id: string
    mintAddress: string
    name: string
    symbol: string
    description: string | null
    uri: string
    supply: number
    createdBy: string
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: NftCollectionCountAggregateOutputType | null
    _avg: NftCollectionAvgAggregateOutputType | null
    _sum: NftCollectionSumAggregateOutputType | null
    _min: NftCollectionMinAggregateOutputType | null
    _max: NftCollectionMaxAggregateOutputType | null
  }

  type GetNftCollectionGroupByPayload<T extends NftCollectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NftCollectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NftCollectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NftCollectionGroupByOutputType[P]>
            : GetScalarType<T[P], NftCollectionGroupByOutputType[P]>
        }
      >
    >


  export type NftCollectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mintAddress?: boolean
    name?: boolean
    symbol?: boolean
    description?: boolean
    uri?: boolean
    supply?: boolean
    createdBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    distributions?: boolean | NftCollection$distributionsArgs<ExtArgs>
    _count?: boolean | NftCollectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nftCollection"]>

  export type NftCollectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mintAddress?: boolean
    name?: boolean
    symbol?: boolean
    description?: boolean
    uri?: boolean
    supply?: boolean
    createdBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nftCollection"]>

  export type NftCollectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mintAddress?: boolean
    name?: boolean
    symbol?: boolean
    description?: boolean
    uri?: boolean
    supply?: boolean
    createdBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nftCollection"]>

  export type NftCollectionSelectScalar = {
    id?: boolean
    mintAddress?: boolean
    name?: boolean
    symbol?: boolean
    description?: boolean
    uri?: boolean
    supply?: boolean
    createdBy?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NftCollectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mintAddress" | "name" | "symbol" | "description" | "uri" | "supply" | "createdBy" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["nftCollection"]>
  export type NftCollectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    distributions?: boolean | NftCollection$distributionsArgs<ExtArgs>
    _count?: boolean | NftCollectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NftCollectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NftCollectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NftCollectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NftCollection"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      distributions: Prisma.$NftDistributionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mintAddress: string
      name: string
      symbol: string
      description: string | null
      uri: string
      supply: number
      createdBy: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["nftCollection"]>
    composites: {}
  }

  type NftCollectionGetPayload<S extends boolean | null | undefined | NftCollectionDefaultArgs> = $Result.GetResult<Prisma.$NftCollectionPayload, S>

  type NftCollectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NftCollectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NftCollectionCountAggregateInputType | true
    }

  export interface NftCollectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NftCollection'], meta: { name: 'NftCollection' } }
    /**
     * Find zero or one NftCollection that matches the filter.
     * @param {NftCollectionFindUniqueArgs} args - Arguments to find a NftCollection
     * @example
     * // Get one NftCollection
     * const nftCollection = await prisma.nftCollection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NftCollectionFindUniqueArgs>(args: SelectSubset<T, NftCollectionFindUniqueArgs<ExtArgs>>): Prisma__NftCollectionClient<$Result.GetResult<Prisma.$NftCollectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NftCollection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NftCollectionFindUniqueOrThrowArgs} args - Arguments to find a NftCollection
     * @example
     * // Get one NftCollection
     * const nftCollection = await prisma.nftCollection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NftCollectionFindUniqueOrThrowArgs>(args: SelectSubset<T, NftCollectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NftCollectionClient<$Result.GetResult<Prisma.$NftCollectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NftCollection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NftCollectionFindFirstArgs} args - Arguments to find a NftCollection
     * @example
     * // Get one NftCollection
     * const nftCollection = await prisma.nftCollection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NftCollectionFindFirstArgs>(args?: SelectSubset<T, NftCollectionFindFirstArgs<ExtArgs>>): Prisma__NftCollectionClient<$Result.GetResult<Prisma.$NftCollectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NftCollection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NftCollectionFindFirstOrThrowArgs} args - Arguments to find a NftCollection
     * @example
     * // Get one NftCollection
     * const nftCollection = await prisma.nftCollection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NftCollectionFindFirstOrThrowArgs>(args?: SelectSubset<T, NftCollectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__NftCollectionClient<$Result.GetResult<Prisma.$NftCollectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NftCollections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NftCollectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NftCollections
     * const nftCollections = await prisma.nftCollection.findMany()
     * 
     * // Get first 10 NftCollections
     * const nftCollections = await prisma.nftCollection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nftCollectionWithIdOnly = await prisma.nftCollection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NftCollectionFindManyArgs>(args?: SelectSubset<T, NftCollectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NftCollectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NftCollection.
     * @param {NftCollectionCreateArgs} args - Arguments to create a NftCollection.
     * @example
     * // Create one NftCollection
     * const NftCollection = await prisma.nftCollection.create({
     *   data: {
     *     // ... data to create a NftCollection
     *   }
     * })
     * 
     */
    create<T extends NftCollectionCreateArgs>(args: SelectSubset<T, NftCollectionCreateArgs<ExtArgs>>): Prisma__NftCollectionClient<$Result.GetResult<Prisma.$NftCollectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NftCollections.
     * @param {NftCollectionCreateManyArgs} args - Arguments to create many NftCollections.
     * @example
     * // Create many NftCollections
     * const nftCollection = await prisma.nftCollection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NftCollectionCreateManyArgs>(args?: SelectSubset<T, NftCollectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NftCollections and returns the data saved in the database.
     * @param {NftCollectionCreateManyAndReturnArgs} args - Arguments to create many NftCollections.
     * @example
     * // Create many NftCollections
     * const nftCollection = await prisma.nftCollection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NftCollections and only return the `id`
     * const nftCollectionWithIdOnly = await prisma.nftCollection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NftCollectionCreateManyAndReturnArgs>(args?: SelectSubset<T, NftCollectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NftCollectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NftCollection.
     * @param {NftCollectionDeleteArgs} args - Arguments to delete one NftCollection.
     * @example
     * // Delete one NftCollection
     * const NftCollection = await prisma.nftCollection.delete({
     *   where: {
     *     // ... filter to delete one NftCollection
     *   }
     * })
     * 
     */
    delete<T extends NftCollectionDeleteArgs>(args: SelectSubset<T, NftCollectionDeleteArgs<ExtArgs>>): Prisma__NftCollectionClient<$Result.GetResult<Prisma.$NftCollectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NftCollection.
     * @param {NftCollectionUpdateArgs} args - Arguments to update one NftCollection.
     * @example
     * // Update one NftCollection
     * const nftCollection = await prisma.nftCollection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NftCollectionUpdateArgs>(args: SelectSubset<T, NftCollectionUpdateArgs<ExtArgs>>): Prisma__NftCollectionClient<$Result.GetResult<Prisma.$NftCollectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NftCollections.
     * @param {NftCollectionDeleteManyArgs} args - Arguments to filter NftCollections to delete.
     * @example
     * // Delete a few NftCollections
     * const { count } = await prisma.nftCollection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NftCollectionDeleteManyArgs>(args?: SelectSubset<T, NftCollectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NftCollections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NftCollectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NftCollections
     * const nftCollection = await prisma.nftCollection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NftCollectionUpdateManyArgs>(args: SelectSubset<T, NftCollectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NftCollections and returns the data updated in the database.
     * @param {NftCollectionUpdateManyAndReturnArgs} args - Arguments to update many NftCollections.
     * @example
     * // Update many NftCollections
     * const nftCollection = await prisma.nftCollection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NftCollections and only return the `id`
     * const nftCollectionWithIdOnly = await prisma.nftCollection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NftCollectionUpdateManyAndReturnArgs>(args: SelectSubset<T, NftCollectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NftCollectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NftCollection.
     * @param {NftCollectionUpsertArgs} args - Arguments to update or create a NftCollection.
     * @example
     * // Update or create a NftCollection
     * const nftCollection = await prisma.nftCollection.upsert({
     *   create: {
     *     // ... data to create a NftCollection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NftCollection we want to update
     *   }
     * })
     */
    upsert<T extends NftCollectionUpsertArgs>(args: SelectSubset<T, NftCollectionUpsertArgs<ExtArgs>>): Prisma__NftCollectionClient<$Result.GetResult<Prisma.$NftCollectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NftCollections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NftCollectionCountArgs} args - Arguments to filter NftCollections to count.
     * @example
     * // Count the number of NftCollections
     * const count = await prisma.nftCollection.count({
     *   where: {
     *     // ... the filter for the NftCollections we want to count
     *   }
     * })
    **/
    count<T extends NftCollectionCountArgs>(
      args?: Subset<T, NftCollectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NftCollectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NftCollection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NftCollectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NftCollectionAggregateArgs>(args: Subset<T, NftCollectionAggregateArgs>): Prisma.PrismaPromise<GetNftCollectionAggregateType<T>>

    /**
     * Group by NftCollection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NftCollectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NftCollectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NftCollectionGroupByArgs['orderBy'] }
        : { orderBy?: NftCollectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NftCollectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNftCollectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NftCollection model
   */
  readonly fields: NftCollectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NftCollection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NftCollectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    distributions<T extends NftCollection$distributionsArgs<ExtArgs> = {}>(args?: Subset<T, NftCollection$distributionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NftDistributionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NftCollection model
   */
  interface NftCollectionFieldRefs {
    readonly id: FieldRef<"NftCollection", 'String'>
    readonly mintAddress: FieldRef<"NftCollection", 'String'>
    readonly name: FieldRef<"NftCollection", 'String'>
    readonly symbol: FieldRef<"NftCollection", 'String'>
    readonly description: FieldRef<"NftCollection", 'String'>
    readonly uri: FieldRef<"NftCollection", 'String'>
    readonly supply: FieldRef<"NftCollection", 'Int'>
    readonly createdBy: FieldRef<"NftCollection", 'String'>
    readonly metadata: FieldRef<"NftCollection", 'Json'>
    readonly createdAt: FieldRef<"NftCollection", 'DateTime'>
    readonly updatedAt: FieldRef<"NftCollection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NftCollection findUnique
   */
  export type NftCollectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftCollection
     */
    select?: NftCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftCollection
     */
    omit?: NftCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftCollectionInclude<ExtArgs> | null
    /**
     * Filter, which NftCollection to fetch.
     */
    where: NftCollectionWhereUniqueInput
  }

  /**
   * NftCollection findUniqueOrThrow
   */
  export type NftCollectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftCollection
     */
    select?: NftCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftCollection
     */
    omit?: NftCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftCollectionInclude<ExtArgs> | null
    /**
     * Filter, which NftCollection to fetch.
     */
    where: NftCollectionWhereUniqueInput
  }

  /**
   * NftCollection findFirst
   */
  export type NftCollectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftCollection
     */
    select?: NftCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftCollection
     */
    omit?: NftCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftCollectionInclude<ExtArgs> | null
    /**
     * Filter, which NftCollection to fetch.
     */
    where?: NftCollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NftCollections to fetch.
     */
    orderBy?: NftCollectionOrderByWithRelationInput | NftCollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NftCollections.
     */
    cursor?: NftCollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NftCollections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NftCollections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NftCollections.
     */
    distinct?: NftCollectionScalarFieldEnum | NftCollectionScalarFieldEnum[]
  }

  /**
   * NftCollection findFirstOrThrow
   */
  export type NftCollectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftCollection
     */
    select?: NftCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftCollection
     */
    omit?: NftCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftCollectionInclude<ExtArgs> | null
    /**
     * Filter, which NftCollection to fetch.
     */
    where?: NftCollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NftCollections to fetch.
     */
    orderBy?: NftCollectionOrderByWithRelationInput | NftCollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NftCollections.
     */
    cursor?: NftCollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NftCollections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NftCollections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NftCollections.
     */
    distinct?: NftCollectionScalarFieldEnum | NftCollectionScalarFieldEnum[]
  }

  /**
   * NftCollection findMany
   */
  export type NftCollectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftCollection
     */
    select?: NftCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftCollection
     */
    omit?: NftCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftCollectionInclude<ExtArgs> | null
    /**
     * Filter, which NftCollections to fetch.
     */
    where?: NftCollectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NftCollections to fetch.
     */
    orderBy?: NftCollectionOrderByWithRelationInput | NftCollectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NftCollections.
     */
    cursor?: NftCollectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NftCollections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NftCollections.
     */
    skip?: number
    distinct?: NftCollectionScalarFieldEnum | NftCollectionScalarFieldEnum[]
  }

  /**
   * NftCollection create
   */
  export type NftCollectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftCollection
     */
    select?: NftCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftCollection
     */
    omit?: NftCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftCollectionInclude<ExtArgs> | null
    /**
     * The data needed to create a NftCollection.
     */
    data: XOR<NftCollectionCreateInput, NftCollectionUncheckedCreateInput>
  }

  /**
   * NftCollection createMany
   */
  export type NftCollectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NftCollections.
     */
    data: NftCollectionCreateManyInput | NftCollectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NftCollection createManyAndReturn
   */
  export type NftCollectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftCollection
     */
    select?: NftCollectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NftCollection
     */
    omit?: NftCollectionOmit<ExtArgs> | null
    /**
     * The data used to create many NftCollections.
     */
    data: NftCollectionCreateManyInput | NftCollectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftCollectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NftCollection update
   */
  export type NftCollectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftCollection
     */
    select?: NftCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftCollection
     */
    omit?: NftCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftCollectionInclude<ExtArgs> | null
    /**
     * The data needed to update a NftCollection.
     */
    data: XOR<NftCollectionUpdateInput, NftCollectionUncheckedUpdateInput>
    /**
     * Choose, which NftCollection to update.
     */
    where: NftCollectionWhereUniqueInput
  }

  /**
   * NftCollection updateMany
   */
  export type NftCollectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NftCollections.
     */
    data: XOR<NftCollectionUpdateManyMutationInput, NftCollectionUncheckedUpdateManyInput>
    /**
     * Filter which NftCollections to update
     */
    where?: NftCollectionWhereInput
    /**
     * Limit how many NftCollections to update.
     */
    limit?: number
  }

  /**
   * NftCollection updateManyAndReturn
   */
  export type NftCollectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftCollection
     */
    select?: NftCollectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NftCollection
     */
    omit?: NftCollectionOmit<ExtArgs> | null
    /**
     * The data used to update NftCollections.
     */
    data: XOR<NftCollectionUpdateManyMutationInput, NftCollectionUncheckedUpdateManyInput>
    /**
     * Filter which NftCollections to update
     */
    where?: NftCollectionWhereInput
    /**
     * Limit how many NftCollections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftCollectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NftCollection upsert
   */
  export type NftCollectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftCollection
     */
    select?: NftCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftCollection
     */
    omit?: NftCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftCollectionInclude<ExtArgs> | null
    /**
     * The filter to search for the NftCollection to update in case it exists.
     */
    where: NftCollectionWhereUniqueInput
    /**
     * In case the NftCollection found by the `where` argument doesn't exist, create a new NftCollection with this data.
     */
    create: XOR<NftCollectionCreateInput, NftCollectionUncheckedCreateInput>
    /**
     * In case the NftCollection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NftCollectionUpdateInput, NftCollectionUncheckedUpdateInput>
  }

  /**
   * NftCollection delete
   */
  export type NftCollectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftCollection
     */
    select?: NftCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftCollection
     */
    omit?: NftCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftCollectionInclude<ExtArgs> | null
    /**
     * Filter which NftCollection to delete.
     */
    where: NftCollectionWhereUniqueInput
  }

  /**
   * NftCollection deleteMany
   */
  export type NftCollectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NftCollections to delete
     */
    where?: NftCollectionWhereInput
    /**
     * Limit how many NftCollections to delete.
     */
    limit?: number
  }

  /**
   * NftCollection.distributions
   */
  export type NftCollection$distributionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftDistribution
     */
    select?: NftDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftDistribution
     */
    omit?: NftDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftDistributionInclude<ExtArgs> | null
    where?: NftDistributionWhereInput
    orderBy?: NftDistributionOrderByWithRelationInput | NftDistributionOrderByWithRelationInput[]
    cursor?: NftDistributionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NftDistributionScalarFieldEnum | NftDistributionScalarFieldEnum[]
  }

  /**
   * NftCollection without action
   */
  export type NftCollectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftCollection
     */
    select?: NftCollectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftCollection
     */
    omit?: NftCollectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftCollectionInclude<ExtArgs> | null
  }


  /**
   * Model NftDistribution
   */

  export type AggregateNftDistribution = {
    _count: NftDistributionCountAggregateOutputType | null
    _avg: NftDistributionAvgAggregateOutputType | null
    _sum: NftDistributionSumAggregateOutputType | null
    _min: NftDistributionMinAggregateOutputType | null
    _max: NftDistributionMaxAggregateOutputType | null
  }

  export type NftDistributionAvgAggregateOutputType = {
    recipientCount: number | null
    nftsPerUser: number | null
  }

  export type NftDistributionSumAggregateOutputType = {
    recipientCount: number | null
    nftsPerUser: number | null
  }

  export type NftDistributionMinAggregateOutputType = {
    id: string | null
    mintAddress: string | null
    distributedBy: string | null
    recipientCount: number | null
    nftsPerUser: number | null
    success: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NftDistributionMaxAggregateOutputType = {
    id: string | null
    mintAddress: string | null
    distributedBy: string | null
    recipientCount: number | null
    nftsPerUser: number | null
    success: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NftDistributionCountAggregateOutputType = {
    id: number
    mintAddress: number
    distributedBy: number
    recipientCount: number
    nftsPerUser: number
    results: number
    success: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NftDistributionAvgAggregateInputType = {
    recipientCount?: true
    nftsPerUser?: true
  }

  export type NftDistributionSumAggregateInputType = {
    recipientCount?: true
    nftsPerUser?: true
  }

  export type NftDistributionMinAggregateInputType = {
    id?: true
    mintAddress?: true
    distributedBy?: true
    recipientCount?: true
    nftsPerUser?: true
    success?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NftDistributionMaxAggregateInputType = {
    id?: true
    mintAddress?: true
    distributedBy?: true
    recipientCount?: true
    nftsPerUser?: true
    success?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NftDistributionCountAggregateInputType = {
    id?: true
    mintAddress?: true
    distributedBy?: true
    recipientCount?: true
    nftsPerUser?: true
    results?: true
    success?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NftDistributionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NftDistribution to aggregate.
     */
    where?: NftDistributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NftDistributions to fetch.
     */
    orderBy?: NftDistributionOrderByWithRelationInput | NftDistributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NftDistributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NftDistributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NftDistributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NftDistributions
    **/
    _count?: true | NftDistributionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NftDistributionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NftDistributionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NftDistributionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NftDistributionMaxAggregateInputType
  }

  export type GetNftDistributionAggregateType<T extends NftDistributionAggregateArgs> = {
        [P in keyof T & keyof AggregateNftDistribution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNftDistribution[P]>
      : GetScalarType<T[P], AggregateNftDistribution[P]>
  }




  export type NftDistributionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NftDistributionWhereInput
    orderBy?: NftDistributionOrderByWithAggregationInput | NftDistributionOrderByWithAggregationInput[]
    by: NftDistributionScalarFieldEnum[] | NftDistributionScalarFieldEnum
    having?: NftDistributionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NftDistributionCountAggregateInputType | true
    _avg?: NftDistributionAvgAggregateInputType
    _sum?: NftDistributionSumAggregateInputType
    _min?: NftDistributionMinAggregateInputType
    _max?: NftDistributionMaxAggregateInputType
  }

  export type NftDistributionGroupByOutputType = {
    id: string
    mintAddress: string
    distributedBy: string
    recipientCount: number
    nftsPerUser: number
    results: JsonValue
    success: boolean
    createdAt: Date
    updatedAt: Date
    _count: NftDistributionCountAggregateOutputType | null
    _avg: NftDistributionAvgAggregateOutputType | null
    _sum: NftDistributionSumAggregateOutputType | null
    _min: NftDistributionMinAggregateOutputType | null
    _max: NftDistributionMaxAggregateOutputType | null
  }

  type GetNftDistributionGroupByPayload<T extends NftDistributionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NftDistributionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NftDistributionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NftDistributionGroupByOutputType[P]>
            : GetScalarType<T[P], NftDistributionGroupByOutputType[P]>
        }
      >
    >


  export type NftDistributionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mintAddress?: boolean
    distributedBy?: boolean
    recipientCount?: boolean
    nftsPerUser?: boolean
    results?: boolean
    success?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collection?: boolean | NftCollectionDefaultArgs<ExtArgs>
    distributor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nftDistribution"]>

  export type NftDistributionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mintAddress?: boolean
    distributedBy?: boolean
    recipientCount?: boolean
    nftsPerUser?: boolean
    results?: boolean
    success?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collection?: boolean | NftCollectionDefaultArgs<ExtArgs>
    distributor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nftDistribution"]>

  export type NftDistributionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mintAddress?: boolean
    distributedBy?: boolean
    recipientCount?: boolean
    nftsPerUser?: boolean
    results?: boolean
    success?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    collection?: boolean | NftCollectionDefaultArgs<ExtArgs>
    distributor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nftDistribution"]>

  export type NftDistributionSelectScalar = {
    id?: boolean
    mintAddress?: boolean
    distributedBy?: boolean
    recipientCount?: boolean
    nftsPerUser?: boolean
    results?: boolean
    success?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NftDistributionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "mintAddress" | "distributedBy" | "recipientCount" | "nftsPerUser" | "results" | "success" | "createdAt" | "updatedAt", ExtArgs["result"]["nftDistribution"]>
  export type NftDistributionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | NftCollectionDefaultArgs<ExtArgs>
    distributor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NftDistributionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | NftCollectionDefaultArgs<ExtArgs>
    distributor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NftDistributionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    collection?: boolean | NftCollectionDefaultArgs<ExtArgs>
    distributor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NftDistributionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NftDistribution"
    objects: {
      collection: Prisma.$NftCollectionPayload<ExtArgs>
      distributor: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mintAddress: string
      distributedBy: string
      recipientCount: number
      nftsPerUser: number
      results: Prisma.JsonValue
      success: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["nftDistribution"]>
    composites: {}
  }

  type NftDistributionGetPayload<S extends boolean | null | undefined | NftDistributionDefaultArgs> = $Result.GetResult<Prisma.$NftDistributionPayload, S>

  type NftDistributionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NftDistributionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NftDistributionCountAggregateInputType | true
    }

  export interface NftDistributionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NftDistribution'], meta: { name: 'NftDistribution' } }
    /**
     * Find zero or one NftDistribution that matches the filter.
     * @param {NftDistributionFindUniqueArgs} args - Arguments to find a NftDistribution
     * @example
     * // Get one NftDistribution
     * const nftDistribution = await prisma.nftDistribution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NftDistributionFindUniqueArgs>(args: SelectSubset<T, NftDistributionFindUniqueArgs<ExtArgs>>): Prisma__NftDistributionClient<$Result.GetResult<Prisma.$NftDistributionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NftDistribution that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NftDistributionFindUniqueOrThrowArgs} args - Arguments to find a NftDistribution
     * @example
     * // Get one NftDistribution
     * const nftDistribution = await prisma.nftDistribution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NftDistributionFindUniqueOrThrowArgs>(args: SelectSubset<T, NftDistributionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NftDistributionClient<$Result.GetResult<Prisma.$NftDistributionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NftDistribution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NftDistributionFindFirstArgs} args - Arguments to find a NftDistribution
     * @example
     * // Get one NftDistribution
     * const nftDistribution = await prisma.nftDistribution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NftDistributionFindFirstArgs>(args?: SelectSubset<T, NftDistributionFindFirstArgs<ExtArgs>>): Prisma__NftDistributionClient<$Result.GetResult<Prisma.$NftDistributionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NftDistribution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NftDistributionFindFirstOrThrowArgs} args - Arguments to find a NftDistribution
     * @example
     * // Get one NftDistribution
     * const nftDistribution = await prisma.nftDistribution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NftDistributionFindFirstOrThrowArgs>(args?: SelectSubset<T, NftDistributionFindFirstOrThrowArgs<ExtArgs>>): Prisma__NftDistributionClient<$Result.GetResult<Prisma.$NftDistributionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NftDistributions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NftDistributionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NftDistributions
     * const nftDistributions = await prisma.nftDistribution.findMany()
     * 
     * // Get first 10 NftDistributions
     * const nftDistributions = await prisma.nftDistribution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nftDistributionWithIdOnly = await prisma.nftDistribution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NftDistributionFindManyArgs>(args?: SelectSubset<T, NftDistributionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NftDistributionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NftDistribution.
     * @param {NftDistributionCreateArgs} args - Arguments to create a NftDistribution.
     * @example
     * // Create one NftDistribution
     * const NftDistribution = await prisma.nftDistribution.create({
     *   data: {
     *     // ... data to create a NftDistribution
     *   }
     * })
     * 
     */
    create<T extends NftDistributionCreateArgs>(args: SelectSubset<T, NftDistributionCreateArgs<ExtArgs>>): Prisma__NftDistributionClient<$Result.GetResult<Prisma.$NftDistributionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NftDistributions.
     * @param {NftDistributionCreateManyArgs} args - Arguments to create many NftDistributions.
     * @example
     * // Create many NftDistributions
     * const nftDistribution = await prisma.nftDistribution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NftDistributionCreateManyArgs>(args?: SelectSubset<T, NftDistributionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NftDistributions and returns the data saved in the database.
     * @param {NftDistributionCreateManyAndReturnArgs} args - Arguments to create many NftDistributions.
     * @example
     * // Create many NftDistributions
     * const nftDistribution = await prisma.nftDistribution.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NftDistributions and only return the `id`
     * const nftDistributionWithIdOnly = await prisma.nftDistribution.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NftDistributionCreateManyAndReturnArgs>(args?: SelectSubset<T, NftDistributionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NftDistributionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NftDistribution.
     * @param {NftDistributionDeleteArgs} args - Arguments to delete one NftDistribution.
     * @example
     * // Delete one NftDistribution
     * const NftDistribution = await prisma.nftDistribution.delete({
     *   where: {
     *     // ... filter to delete one NftDistribution
     *   }
     * })
     * 
     */
    delete<T extends NftDistributionDeleteArgs>(args: SelectSubset<T, NftDistributionDeleteArgs<ExtArgs>>): Prisma__NftDistributionClient<$Result.GetResult<Prisma.$NftDistributionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NftDistribution.
     * @param {NftDistributionUpdateArgs} args - Arguments to update one NftDistribution.
     * @example
     * // Update one NftDistribution
     * const nftDistribution = await prisma.nftDistribution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NftDistributionUpdateArgs>(args: SelectSubset<T, NftDistributionUpdateArgs<ExtArgs>>): Prisma__NftDistributionClient<$Result.GetResult<Prisma.$NftDistributionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NftDistributions.
     * @param {NftDistributionDeleteManyArgs} args - Arguments to filter NftDistributions to delete.
     * @example
     * // Delete a few NftDistributions
     * const { count } = await prisma.nftDistribution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NftDistributionDeleteManyArgs>(args?: SelectSubset<T, NftDistributionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NftDistributions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NftDistributionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NftDistributions
     * const nftDistribution = await prisma.nftDistribution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NftDistributionUpdateManyArgs>(args: SelectSubset<T, NftDistributionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NftDistributions and returns the data updated in the database.
     * @param {NftDistributionUpdateManyAndReturnArgs} args - Arguments to update many NftDistributions.
     * @example
     * // Update many NftDistributions
     * const nftDistribution = await prisma.nftDistribution.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NftDistributions and only return the `id`
     * const nftDistributionWithIdOnly = await prisma.nftDistribution.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NftDistributionUpdateManyAndReturnArgs>(args: SelectSubset<T, NftDistributionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NftDistributionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NftDistribution.
     * @param {NftDistributionUpsertArgs} args - Arguments to update or create a NftDistribution.
     * @example
     * // Update or create a NftDistribution
     * const nftDistribution = await prisma.nftDistribution.upsert({
     *   create: {
     *     // ... data to create a NftDistribution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NftDistribution we want to update
     *   }
     * })
     */
    upsert<T extends NftDistributionUpsertArgs>(args: SelectSubset<T, NftDistributionUpsertArgs<ExtArgs>>): Prisma__NftDistributionClient<$Result.GetResult<Prisma.$NftDistributionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NftDistributions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NftDistributionCountArgs} args - Arguments to filter NftDistributions to count.
     * @example
     * // Count the number of NftDistributions
     * const count = await prisma.nftDistribution.count({
     *   where: {
     *     // ... the filter for the NftDistributions we want to count
     *   }
     * })
    **/
    count<T extends NftDistributionCountArgs>(
      args?: Subset<T, NftDistributionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NftDistributionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NftDistribution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NftDistributionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NftDistributionAggregateArgs>(args: Subset<T, NftDistributionAggregateArgs>): Prisma.PrismaPromise<GetNftDistributionAggregateType<T>>

    /**
     * Group by NftDistribution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NftDistributionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NftDistributionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NftDistributionGroupByArgs['orderBy'] }
        : { orderBy?: NftDistributionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NftDistributionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNftDistributionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NftDistribution model
   */
  readonly fields: NftDistributionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NftDistribution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NftDistributionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    collection<T extends NftCollectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NftCollectionDefaultArgs<ExtArgs>>): Prisma__NftCollectionClient<$Result.GetResult<Prisma.$NftCollectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    distributor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NftDistribution model
   */
  interface NftDistributionFieldRefs {
    readonly id: FieldRef<"NftDistribution", 'String'>
    readonly mintAddress: FieldRef<"NftDistribution", 'String'>
    readonly distributedBy: FieldRef<"NftDistribution", 'String'>
    readonly recipientCount: FieldRef<"NftDistribution", 'Int'>
    readonly nftsPerUser: FieldRef<"NftDistribution", 'Int'>
    readonly results: FieldRef<"NftDistribution", 'Json'>
    readonly success: FieldRef<"NftDistribution", 'Boolean'>
    readonly createdAt: FieldRef<"NftDistribution", 'DateTime'>
    readonly updatedAt: FieldRef<"NftDistribution", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NftDistribution findUnique
   */
  export type NftDistributionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftDistribution
     */
    select?: NftDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftDistribution
     */
    omit?: NftDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftDistributionInclude<ExtArgs> | null
    /**
     * Filter, which NftDistribution to fetch.
     */
    where: NftDistributionWhereUniqueInput
  }

  /**
   * NftDistribution findUniqueOrThrow
   */
  export type NftDistributionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftDistribution
     */
    select?: NftDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftDistribution
     */
    omit?: NftDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftDistributionInclude<ExtArgs> | null
    /**
     * Filter, which NftDistribution to fetch.
     */
    where: NftDistributionWhereUniqueInput
  }

  /**
   * NftDistribution findFirst
   */
  export type NftDistributionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftDistribution
     */
    select?: NftDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftDistribution
     */
    omit?: NftDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftDistributionInclude<ExtArgs> | null
    /**
     * Filter, which NftDistribution to fetch.
     */
    where?: NftDistributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NftDistributions to fetch.
     */
    orderBy?: NftDistributionOrderByWithRelationInput | NftDistributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NftDistributions.
     */
    cursor?: NftDistributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NftDistributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NftDistributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NftDistributions.
     */
    distinct?: NftDistributionScalarFieldEnum | NftDistributionScalarFieldEnum[]
  }

  /**
   * NftDistribution findFirstOrThrow
   */
  export type NftDistributionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftDistribution
     */
    select?: NftDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftDistribution
     */
    omit?: NftDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftDistributionInclude<ExtArgs> | null
    /**
     * Filter, which NftDistribution to fetch.
     */
    where?: NftDistributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NftDistributions to fetch.
     */
    orderBy?: NftDistributionOrderByWithRelationInput | NftDistributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NftDistributions.
     */
    cursor?: NftDistributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NftDistributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NftDistributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NftDistributions.
     */
    distinct?: NftDistributionScalarFieldEnum | NftDistributionScalarFieldEnum[]
  }

  /**
   * NftDistribution findMany
   */
  export type NftDistributionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftDistribution
     */
    select?: NftDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftDistribution
     */
    omit?: NftDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftDistributionInclude<ExtArgs> | null
    /**
     * Filter, which NftDistributions to fetch.
     */
    where?: NftDistributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NftDistributions to fetch.
     */
    orderBy?: NftDistributionOrderByWithRelationInput | NftDistributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NftDistributions.
     */
    cursor?: NftDistributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NftDistributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NftDistributions.
     */
    skip?: number
    distinct?: NftDistributionScalarFieldEnum | NftDistributionScalarFieldEnum[]
  }

  /**
   * NftDistribution create
   */
  export type NftDistributionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftDistribution
     */
    select?: NftDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftDistribution
     */
    omit?: NftDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftDistributionInclude<ExtArgs> | null
    /**
     * The data needed to create a NftDistribution.
     */
    data: XOR<NftDistributionCreateInput, NftDistributionUncheckedCreateInput>
  }

  /**
   * NftDistribution createMany
   */
  export type NftDistributionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NftDistributions.
     */
    data: NftDistributionCreateManyInput | NftDistributionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NftDistribution createManyAndReturn
   */
  export type NftDistributionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftDistribution
     */
    select?: NftDistributionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NftDistribution
     */
    omit?: NftDistributionOmit<ExtArgs> | null
    /**
     * The data used to create many NftDistributions.
     */
    data: NftDistributionCreateManyInput | NftDistributionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftDistributionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NftDistribution update
   */
  export type NftDistributionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftDistribution
     */
    select?: NftDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftDistribution
     */
    omit?: NftDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftDistributionInclude<ExtArgs> | null
    /**
     * The data needed to update a NftDistribution.
     */
    data: XOR<NftDistributionUpdateInput, NftDistributionUncheckedUpdateInput>
    /**
     * Choose, which NftDistribution to update.
     */
    where: NftDistributionWhereUniqueInput
  }

  /**
   * NftDistribution updateMany
   */
  export type NftDistributionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NftDistributions.
     */
    data: XOR<NftDistributionUpdateManyMutationInput, NftDistributionUncheckedUpdateManyInput>
    /**
     * Filter which NftDistributions to update
     */
    where?: NftDistributionWhereInput
    /**
     * Limit how many NftDistributions to update.
     */
    limit?: number
  }

  /**
   * NftDistribution updateManyAndReturn
   */
  export type NftDistributionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftDistribution
     */
    select?: NftDistributionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NftDistribution
     */
    omit?: NftDistributionOmit<ExtArgs> | null
    /**
     * The data used to update NftDistributions.
     */
    data: XOR<NftDistributionUpdateManyMutationInput, NftDistributionUncheckedUpdateManyInput>
    /**
     * Filter which NftDistributions to update
     */
    where?: NftDistributionWhereInput
    /**
     * Limit how many NftDistributions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftDistributionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NftDistribution upsert
   */
  export type NftDistributionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftDistribution
     */
    select?: NftDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftDistribution
     */
    omit?: NftDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftDistributionInclude<ExtArgs> | null
    /**
     * The filter to search for the NftDistribution to update in case it exists.
     */
    where: NftDistributionWhereUniqueInput
    /**
     * In case the NftDistribution found by the `where` argument doesn't exist, create a new NftDistribution with this data.
     */
    create: XOR<NftDistributionCreateInput, NftDistributionUncheckedCreateInput>
    /**
     * In case the NftDistribution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NftDistributionUpdateInput, NftDistributionUncheckedUpdateInput>
  }

  /**
   * NftDistribution delete
   */
  export type NftDistributionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftDistribution
     */
    select?: NftDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftDistribution
     */
    omit?: NftDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftDistributionInclude<ExtArgs> | null
    /**
     * Filter which NftDistribution to delete.
     */
    where: NftDistributionWhereUniqueInput
  }

  /**
   * NftDistribution deleteMany
   */
  export type NftDistributionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NftDistributions to delete
     */
    where?: NftDistributionWhereInput
    /**
     * Limit how many NftDistributions to delete.
     */
    limit?: number
  }

  /**
   * NftDistribution without action
   */
  export type NftDistributionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftDistribution
     */
    select?: NftDistributionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftDistribution
     */
    omit?: NftDistributionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftDistributionInclude<ExtArgs> | null
  }


  /**
   * Model NftClaimApproval
   */

  export type AggregateNftClaimApproval = {
    _count: NftClaimApprovalCountAggregateOutputType | null
    _min: NftClaimApprovalMinAggregateOutputType | null
    _max: NftClaimApprovalMaxAggregateOutputType | null
  }

  export type NftClaimApprovalMinAggregateOutputType = {
    id: string | null
    userId: string | null
    approved: boolean | null
    approvedBy: string | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NftClaimApprovalMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    approved: boolean | null
    approvedBy: string | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NftClaimApprovalCountAggregateOutputType = {
    id: number
    userId: number
    approved: number
    approvedBy: number
    approvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NftClaimApprovalMinAggregateInputType = {
    id?: true
    userId?: true
    approved?: true
    approvedBy?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NftClaimApprovalMaxAggregateInputType = {
    id?: true
    userId?: true
    approved?: true
    approvedBy?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NftClaimApprovalCountAggregateInputType = {
    id?: true
    userId?: true
    approved?: true
    approvedBy?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NftClaimApprovalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NftClaimApproval to aggregate.
     */
    where?: NftClaimApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NftClaimApprovals to fetch.
     */
    orderBy?: NftClaimApprovalOrderByWithRelationInput | NftClaimApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NftClaimApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NftClaimApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NftClaimApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NftClaimApprovals
    **/
    _count?: true | NftClaimApprovalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NftClaimApprovalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NftClaimApprovalMaxAggregateInputType
  }

  export type GetNftClaimApprovalAggregateType<T extends NftClaimApprovalAggregateArgs> = {
        [P in keyof T & keyof AggregateNftClaimApproval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNftClaimApproval[P]>
      : GetScalarType<T[P], AggregateNftClaimApproval[P]>
  }




  export type NftClaimApprovalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NftClaimApprovalWhereInput
    orderBy?: NftClaimApprovalOrderByWithAggregationInput | NftClaimApprovalOrderByWithAggregationInput[]
    by: NftClaimApprovalScalarFieldEnum[] | NftClaimApprovalScalarFieldEnum
    having?: NftClaimApprovalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NftClaimApprovalCountAggregateInputType | true
    _min?: NftClaimApprovalMinAggregateInputType
    _max?: NftClaimApprovalMaxAggregateInputType
  }

  export type NftClaimApprovalGroupByOutputType = {
    id: string
    userId: string
    approved: boolean
    approvedBy: string | null
    approvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: NftClaimApprovalCountAggregateOutputType | null
    _min: NftClaimApprovalMinAggregateOutputType | null
    _max: NftClaimApprovalMaxAggregateOutputType | null
  }

  type GetNftClaimApprovalGroupByPayload<T extends NftClaimApprovalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NftClaimApprovalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NftClaimApprovalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NftClaimApprovalGroupByOutputType[P]>
            : GetScalarType<T[P], NftClaimApprovalGroupByOutputType[P]>
        }
      >
    >


  export type NftClaimApprovalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    approved?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | NftClaimApproval$approverArgs<ExtArgs>
  }, ExtArgs["result"]["nftClaimApproval"]>

  export type NftClaimApprovalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    approved?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | NftClaimApproval$approverArgs<ExtArgs>
  }, ExtArgs["result"]["nftClaimApproval"]>

  export type NftClaimApprovalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    approved?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | NftClaimApproval$approverArgs<ExtArgs>
  }, ExtArgs["result"]["nftClaimApproval"]>

  export type NftClaimApprovalSelectScalar = {
    id?: boolean
    userId?: boolean
    approved?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NftClaimApprovalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "approved" | "approvedBy" | "approvedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["nftClaimApproval"]>
  export type NftClaimApprovalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | NftClaimApproval$approverArgs<ExtArgs>
  }
  export type NftClaimApprovalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | NftClaimApproval$approverArgs<ExtArgs>
  }
  export type NftClaimApprovalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | NftClaimApproval$approverArgs<ExtArgs>
  }

  export type $NftClaimApprovalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NftClaimApproval"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      approved: boolean
      approvedBy: string | null
      approvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["nftClaimApproval"]>
    composites: {}
  }

  type NftClaimApprovalGetPayload<S extends boolean | null | undefined | NftClaimApprovalDefaultArgs> = $Result.GetResult<Prisma.$NftClaimApprovalPayload, S>

  type NftClaimApprovalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NftClaimApprovalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NftClaimApprovalCountAggregateInputType | true
    }

  export interface NftClaimApprovalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NftClaimApproval'], meta: { name: 'NftClaimApproval' } }
    /**
     * Find zero or one NftClaimApproval that matches the filter.
     * @param {NftClaimApprovalFindUniqueArgs} args - Arguments to find a NftClaimApproval
     * @example
     * // Get one NftClaimApproval
     * const nftClaimApproval = await prisma.nftClaimApproval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NftClaimApprovalFindUniqueArgs>(args: SelectSubset<T, NftClaimApprovalFindUniqueArgs<ExtArgs>>): Prisma__NftClaimApprovalClient<$Result.GetResult<Prisma.$NftClaimApprovalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NftClaimApproval that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NftClaimApprovalFindUniqueOrThrowArgs} args - Arguments to find a NftClaimApproval
     * @example
     * // Get one NftClaimApproval
     * const nftClaimApproval = await prisma.nftClaimApproval.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NftClaimApprovalFindUniqueOrThrowArgs>(args: SelectSubset<T, NftClaimApprovalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NftClaimApprovalClient<$Result.GetResult<Prisma.$NftClaimApprovalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NftClaimApproval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NftClaimApprovalFindFirstArgs} args - Arguments to find a NftClaimApproval
     * @example
     * // Get one NftClaimApproval
     * const nftClaimApproval = await prisma.nftClaimApproval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NftClaimApprovalFindFirstArgs>(args?: SelectSubset<T, NftClaimApprovalFindFirstArgs<ExtArgs>>): Prisma__NftClaimApprovalClient<$Result.GetResult<Prisma.$NftClaimApprovalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NftClaimApproval that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NftClaimApprovalFindFirstOrThrowArgs} args - Arguments to find a NftClaimApproval
     * @example
     * // Get one NftClaimApproval
     * const nftClaimApproval = await prisma.nftClaimApproval.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NftClaimApprovalFindFirstOrThrowArgs>(args?: SelectSubset<T, NftClaimApprovalFindFirstOrThrowArgs<ExtArgs>>): Prisma__NftClaimApprovalClient<$Result.GetResult<Prisma.$NftClaimApprovalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NftClaimApprovals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NftClaimApprovalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NftClaimApprovals
     * const nftClaimApprovals = await prisma.nftClaimApproval.findMany()
     * 
     * // Get first 10 NftClaimApprovals
     * const nftClaimApprovals = await prisma.nftClaimApproval.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nftClaimApprovalWithIdOnly = await prisma.nftClaimApproval.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NftClaimApprovalFindManyArgs>(args?: SelectSubset<T, NftClaimApprovalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NftClaimApprovalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NftClaimApproval.
     * @param {NftClaimApprovalCreateArgs} args - Arguments to create a NftClaimApproval.
     * @example
     * // Create one NftClaimApproval
     * const NftClaimApproval = await prisma.nftClaimApproval.create({
     *   data: {
     *     // ... data to create a NftClaimApproval
     *   }
     * })
     * 
     */
    create<T extends NftClaimApprovalCreateArgs>(args: SelectSubset<T, NftClaimApprovalCreateArgs<ExtArgs>>): Prisma__NftClaimApprovalClient<$Result.GetResult<Prisma.$NftClaimApprovalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NftClaimApprovals.
     * @param {NftClaimApprovalCreateManyArgs} args - Arguments to create many NftClaimApprovals.
     * @example
     * // Create many NftClaimApprovals
     * const nftClaimApproval = await prisma.nftClaimApproval.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NftClaimApprovalCreateManyArgs>(args?: SelectSubset<T, NftClaimApprovalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NftClaimApprovals and returns the data saved in the database.
     * @param {NftClaimApprovalCreateManyAndReturnArgs} args - Arguments to create many NftClaimApprovals.
     * @example
     * // Create many NftClaimApprovals
     * const nftClaimApproval = await prisma.nftClaimApproval.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NftClaimApprovals and only return the `id`
     * const nftClaimApprovalWithIdOnly = await prisma.nftClaimApproval.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NftClaimApprovalCreateManyAndReturnArgs>(args?: SelectSubset<T, NftClaimApprovalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NftClaimApprovalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NftClaimApproval.
     * @param {NftClaimApprovalDeleteArgs} args - Arguments to delete one NftClaimApproval.
     * @example
     * // Delete one NftClaimApproval
     * const NftClaimApproval = await prisma.nftClaimApproval.delete({
     *   where: {
     *     // ... filter to delete one NftClaimApproval
     *   }
     * })
     * 
     */
    delete<T extends NftClaimApprovalDeleteArgs>(args: SelectSubset<T, NftClaimApprovalDeleteArgs<ExtArgs>>): Prisma__NftClaimApprovalClient<$Result.GetResult<Prisma.$NftClaimApprovalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NftClaimApproval.
     * @param {NftClaimApprovalUpdateArgs} args - Arguments to update one NftClaimApproval.
     * @example
     * // Update one NftClaimApproval
     * const nftClaimApproval = await prisma.nftClaimApproval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NftClaimApprovalUpdateArgs>(args: SelectSubset<T, NftClaimApprovalUpdateArgs<ExtArgs>>): Prisma__NftClaimApprovalClient<$Result.GetResult<Prisma.$NftClaimApprovalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NftClaimApprovals.
     * @param {NftClaimApprovalDeleteManyArgs} args - Arguments to filter NftClaimApprovals to delete.
     * @example
     * // Delete a few NftClaimApprovals
     * const { count } = await prisma.nftClaimApproval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NftClaimApprovalDeleteManyArgs>(args?: SelectSubset<T, NftClaimApprovalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NftClaimApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NftClaimApprovalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NftClaimApprovals
     * const nftClaimApproval = await prisma.nftClaimApproval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NftClaimApprovalUpdateManyArgs>(args: SelectSubset<T, NftClaimApprovalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NftClaimApprovals and returns the data updated in the database.
     * @param {NftClaimApprovalUpdateManyAndReturnArgs} args - Arguments to update many NftClaimApprovals.
     * @example
     * // Update many NftClaimApprovals
     * const nftClaimApproval = await prisma.nftClaimApproval.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NftClaimApprovals and only return the `id`
     * const nftClaimApprovalWithIdOnly = await prisma.nftClaimApproval.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NftClaimApprovalUpdateManyAndReturnArgs>(args: SelectSubset<T, NftClaimApprovalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NftClaimApprovalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NftClaimApproval.
     * @param {NftClaimApprovalUpsertArgs} args - Arguments to update or create a NftClaimApproval.
     * @example
     * // Update or create a NftClaimApproval
     * const nftClaimApproval = await prisma.nftClaimApproval.upsert({
     *   create: {
     *     // ... data to create a NftClaimApproval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NftClaimApproval we want to update
     *   }
     * })
     */
    upsert<T extends NftClaimApprovalUpsertArgs>(args: SelectSubset<T, NftClaimApprovalUpsertArgs<ExtArgs>>): Prisma__NftClaimApprovalClient<$Result.GetResult<Prisma.$NftClaimApprovalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NftClaimApprovals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NftClaimApprovalCountArgs} args - Arguments to filter NftClaimApprovals to count.
     * @example
     * // Count the number of NftClaimApprovals
     * const count = await prisma.nftClaimApproval.count({
     *   where: {
     *     // ... the filter for the NftClaimApprovals we want to count
     *   }
     * })
    **/
    count<T extends NftClaimApprovalCountArgs>(
      args?: Subset<T, NftClaimApprovalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NftClaimApprovalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NftClaimApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NftClaimApprovalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NftClaimApprovalAggregateArgs>(args: Subset<T, NftClaimApprovalAggregateArgs>): Prisma.PrismaPromise<GetNftClaimApprovalAggregateType<T>>

    /**
     * Group by NftClaimApproval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NftClaimApprovalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NftClaimApprovalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NftClaimApprovalGroupByArgs['orderBy'] }
        : { orderBy?: NftClaimApprovalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NftClaimApprovalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNftClaimApprovalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NftClaimApproval model
   */
  readonly fields: NftClaimApprovalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NftClaimApproval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NftClaimApprovalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approver<T extends NftClaimApproval$approverArgs<ExtArgs> = {}>(args?: Subset<T, NftClaimApproval$approverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NftClaimApproval model
   */
  interface NftClaimApprovalFieldRefs {
    readonly id: FieldRef<"NftClaimApproval", 'String'>
    readonly userId: FieldRef<"NftClaimApproval", 'String'>
    readonly approved: FieldRef<"NftClaimApproval", 'Boolean'>
    readonly approvedBy: FieldRef<"NftClaimApproval", 'String'>
    readonly approvedAt: FieldRef<"NftClaimApproval", 'DateTime'>
    readonly createdAt: FieldRef<"NftClaimApproval", 'DateTime'>
    readonly updatedAt: FieldRef<"NftClaimApproval", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NftClaimApproval findUnique
   */
  export type NftClaimApprovalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftClaimApproval
     */
    select?: NftClaimApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftClaimApproval
     */
    omit?: NftClaimApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftClaimApprovalInclude<ExtArgs> | null
    /**
     * Filter, which NftClaimApproval to fetch.
     */
    where: NftClaimApprovalWhereUniqueInput
  }

  /**
   * NftClaimApproval findUniqueOrThrow
   */
  export type NftClaimApprovalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftClaimApproval
     */
    select?: NftClaimApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftClaimApproval
     */
    omit?: NftClaimApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftClaimApprovalInclude<ExtArgs> | null
    /**
     * Filter, which NftClaimApproval to fetch.
     */
    where: NftClaimApprovalWhereUniqueInput
  }

  /**
   * NftClaimApproval findFirst
   */
  export type NftClaimApprovalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftClaimApproval
     */
    select?: NftClaimApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftClaimApproval
     */
    omit?: NftClaimApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftClaimApprovalInclude<ExtArgs> | null
    /**
     * Filter, which NftClaimApproval to fetch.
     */
    where?: NftClaimApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NftClaimApprovals to fetch.
     */
    orderBy?: NftClaimApprovalOrderByWithRelationInput | NftClaimApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NftClaimApprovals.
     */
    cursor?: NftClaimApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NftClaimApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NftClaimApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NftClaimApprovals.
     */
    distinct?: NftClaimApprovalScalarFieldEnum | NftClaimApprovalScalarFieldEnum[]
  }

  /**
   * NftClaimApproval findFirstOrThrow
   */
  export type NftClaimApprovalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftClaimApproval
     */
    select?: NftClaimApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftClaimApproval
     */
    omit?: NftClaimApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftClaimApprovalInclude<ExtArgs> | null
    /**
     * Filter, which NftClaimApproval to fetch.
     */
    where?: NftClaimApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NftClaimApprovals to fetch.
     */
    orderBy?: NftClaimApprovalOrderByWithRelationInput | NftClaimApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NftClaimApprovals.
     */
    cursor?: NftClaimApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NftClaimApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NftClaimApprovals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NftClaimApprovals.
     */
    distinct?: NftClaimApprovalScalarFieldEnum | NftClaimApprovalScalarFieldEnum[]
  }

  /**
   * NftClaimApproval findMany
   */
  export type NftClaimApprovalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftClaimApproval
     */
    select?: NftClaimApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftClaimApproval
     */
    omit?: NftClaimApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftClaimApprovalInclude<ExtArgs> | null
    /**
     * Filter, which NftClaimApprovals to fetch.
     */
    where?: NftClaimApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NftClaimApprovals to fetch.
     */
    orderBy?: NftClaimApprovalOrderByWithRelationInput | NftClaimApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NftClaimApprovals.
     */
    cursor?: NftClaimApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NftClaimApprovals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NftClaimApprovals.
     */
    skip?: number
    distinct?: NftClaimApprovalScalarFieldEnum | NftClaimApprovalScalarFieldEnum[]
  }

  /**
   * NftClaimApproval create
   */
  export type NftClaimApprovalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftClaimApproval
     */
    select?: NftClaimApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftClaimApproval
     */
    omit?: NftClaimApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftClaimApprovalInclude<ExtArgs> | null
    /**
     * The data needed to create a NftClaimApproval.
     */
    data: XOR<NftClaimApprovalCreateInput, NftClaimApprovalUncheckedCreateInput>
  }

  /**
   * NftClaimApproval createMany
   */
  export type NftClaimApprovalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NftClaimApprovals.
     */
    data: NftClaimApprovalCreateManyInput | NftClaimApprovalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NftClaimApproval createManyAndReturn
   */
  export type NftClaimApprovalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftClaimApproval
     */
    select?: NftClaimApprovalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NftClaimApproval
     */
    omit?: NftClaimApprovalOmit<ExtArgs> | null
    /**
     * The data used to create many NftClaimApprovals.
     */
    data: NftClaimApprovalCreateManyInput | NftClaimApprovalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftClaimApprovalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NftClaimApproval update
   */
  export type NftClaimApprovalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftClaimApproval
     */
    select?: NftClaimApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftClaimApproval
     */
    omit?: NftClaimApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftClaimApprovalInclude<ExtArgs> | null
    /**
     * The data needed to update a NftClaimApproval.
     */
    data: XOR<NftClaimApprovalUpdateInput, NftClaimApprovalUncheckedUpdateInput>
    /**
     * Choose, which NftClaimApproval to update.
     */
    where: NftClaimApprovalWhereUniqueInput
  }

  /**
   * NftClaimApproval updateMany
   */
  export type NftClaimApprovalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NftClaimApprovals.
     */
    data: XOR<NftClaimApprovalUpdateManyMutationInput, NftClaimApprovalUncheckedUpdateManyInput>
    /**
     * Filter which NftClaimApprovals to update
     */
    where?: NftClaimApprovalWhereInput
    /**
     * Limit how many NftClaimApprovals to update.
     */
    limit?: number
  }

  /**
   * NftClaimApproval updateManyAndReturn
   */
  export type NftClaimApprovalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftClaimApproval
     */
    select?: NftClaimApprovalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NftClaimApproval
     */
    omit?: NftClaimApprovalOmit<ExtArgs> | null
    /**
     * The data used to update NftClaimApprovals.
     */
    data: XOR<NftClaimApprovalUpdateManyMutationInput, NftClaimApprovalUncheckedUpdateManyInput>
    /**
     * Filter which NftClaimApprovals to update
     */
    where?: NftClaimApprovalWhereInput
    /**
     * Limit how many NftClaimApprovals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftClaimApprovalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NftClaimApproval upsert
   */
  export type NftClaimApprovalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftClaimApproval
     */
    select?: NftClaimApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftClaimApproval
     */
    omit?: NftClaimApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftClaimApprovalInclude<ExtArgs> | null
    /**
     * The filter to search for the NftClaimApproval to update in case it exists.
     */
    where: NftClaimApprovalWhereUniqueInput
    /**
     * In case the NftClaimApproval found by the `where` argument doesn't exist, create a new NftClaimApproval with this data.
     */
    create: XOR<NftClaimApprovalCreateInput, NftClaimApprovalUncheckedCreateInput>
    /**
     * In case the NftClaimApproval was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NftClaimApprovalUpdateInput, NftClaimApprovalUncheckedUpdateInput>
  }

  /**
   * NftClaimApproval delete
   */
  export type NftClaimApprovalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftClaimApproval
     */
    select?: NftClaimApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftClaimApproval
     */
    omit?: NftClaimApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftClaimApprovalInclude<ExtArgs> | null
    /**
     * Filter which NftClaimApproval to delete.
     */
    where: NftClaimApprovalWhereUniqueInput
  }

  /**
   * NftClaimApproval deleteMany
   */
  export type NftClaimApprovalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NftClaimApprovals to delete
     */
    where?: NftClaimApprovalWhereInput
    /**
     * Limit how many NftClaimApprovals to delete.
     */
    limit?: number
  }

  /**
   * NftClaimApproval.approver
   */
  export type NftClaimApproval$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * NftClaimApproval without action
   */
  export type NftClaimApprovalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NftClaimApproval
     */
    select?: NftClaimApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NftClaimApproval
     */
    omit?: NftClaimApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NftClaimApprovalInclude<ExtArgs> | null
  }


  /**
   * Model UserNftHolding
   */

  export type AggregateUserNftHolding = {
    _count: UserNftHoldingCountAggregateOutputType | null
    _avg: UserNftHoldingAvgAggregateOutputType | null
    _sum: UserNftHoldingSumAggregateOutputType | null
    _min: UserNftHoldingMinAggregateOutputType | null
    _max: UserNftHoldingMaxAggregateOutputType | null
  }

  export type UserNftHoldingAvgAggregateOutputType = {
    amount: number | null
  }

  export type UserNftHoldingSumAggregateOutputType = {
    amount: number | null
  }

  export type UserNftHoldingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    mintAddress: string | null
    tokenAccount: string | null
    amount: number | null
    acquiredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserNftHoldingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    mintAddress: string | null
    tokenAccount: string | null
    amount: number | null
    acquiredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserNftHoldingCountAggregateOutputType = {
    id: number
    userId: number
    mintAddress: number
    tokenAccount: number
    amount: number
    metadata: number
    acquiredAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserNftHoldingAvgAggregateInputType = {
    amount?: true
  }

  export type UserNftHoldingSumAggregateInputType = {
    amount?: true
  }

  export type UserNftHoldingMinAggregateInputType = {
    id?: true
    userId?: true
    mintAddress?: true
    tokenAccount?: true
    amount?: true
    acquiredAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserNftHoldingMaxAggregateInputType = {
    id?: true
    userId?: true
    mintAddress?: true
    tokenAccount?: true
    amount?: true
    acquiredAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserNftHoldingCountAggregateInputType = {
    id?: true
    userId?: true
    mintAddress?: true
    tokenAccount?: true
    amount?: true
    metadata?: true
    acquiredAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserNftHoldingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserNftHolding to aggregate.
     */
    where?: UserNftHoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNftHoldings to fetch.
     */
    orderBy?: UserNftHoldingOrderByWithRelationInput | UserNftHoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserNftHoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNftHoldings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNftHoldings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserNftHoldings
    **/
    _count?: true | UserNftHoldingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserNftHoldingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserNftHoldingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserNftHoldingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserNftHoldingMaxAggregateInputType
  }

  export type GetUserNftHoldingAggregateType<T extends UserNftHoldingAggregateArgs> = {
        [P in keyof T & keyof AggregateUserNftHolding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserNftHolding[P]>
      : GetScalarType<T[P], AggregateUserNftHolding[P]>
  }




  export type UserNftHoldingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserNftHoldingWhereInput
    orderBy?: UserNftHoldingOrderByWithAggregationInput | UserNftHoldingOrderByWithAggregationInput[]
    by: UserNftHoldingScalarFieldEnum[] | UserNftHoldingScalarFieldEnum
    having?: UserNftHoldingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserNftHoldingCountAggregateInputType | true
    _avg?: UserNftHoldingAvgAggregateInputType
    _sum?: UserNftHoldingSumAggregateInputType
    _min?: UserNftHoldingMinAggregateInputType
    _max?: UserNftHoldingMaxAggregateInputType
  }

  export type UserNftHoldingGroupByOutputType = {
    id: string
    userId: string
    mintAddress: string
    tokenAccount: string
    amount: number
    metadata: JsonValue | null
    acquiredAt: Date
    createdAt: Date
    updatedAt: Date
    _count: UserNftHoldingCountAggregateOutputType | null
    _avg: UserNftHoldingAvgAggregateOutputType | null
    _sum: UserNftHoldingSumAggregateOutputType | null
    _min: UserNftHoldingMinAggregateOutputType | null
    _max: UserNftHoldingMaxAggregateOutputType | null
  }

  type GetUserNftHoldingGroupByPayload<T extends UserNftHoldingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserNftHoldingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserNftHoldingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserNftHoldingGroupByOutputType[P]>
            : GetScalarType<T[P], UserNftHoldingGroupByOutputType[P]>
        }
      >
    >


  export type UserNftHoldingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mintAddress?: boolean
    tokenAccount?: boolean
    amount?: boolean
    metadata?: boolean
    acquiredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userNftHolding"]>

  export type UserNftHoldingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mintAddress?: boolean
    tokenAccount?: boolean
    amount?: boolean
    metadata?: boolean
    acquiredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userNftHolding"]>

  export type UserNftHoldingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    mintAddress?: boolean
    tokenAccount?: boolean
    amount?: boolean
    metadata?: boolean
    acquiredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userNftHolding"]>

  export type UserNftHoldingSelectScalar = {
    id?: boolean
    userId?: boolean
    mintAddress?: boolean
    tokenAccount?: boolean
    amount?: boolean
    metadata?: boolean
    acquiredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserNftHoldingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "mintAddress" | "tokenAccount" | "amount" | "metadata" | "acquiredAt" | "createdAt" | "updatedAt", ExtArgs["result"]["userNftHolding"]>
  export type UserNftHoldingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserNftHoldingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserNftHoldingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserNftHoldingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserNftHolding"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      mintAddress: string
      tokenAccount: string
      amount: number
      metadata: Prisma.JsonValue | null
      acquiredAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userNftHolding"]>
    composites: {}
  }

  type UserNftHoldingGetPayload<S extends boolean | null | undefined | UserNftHoldingDefaultArgs> = $Result.GetResult<Prisma.$UserNftHoldingPayload, S>

  type UserNftHoldingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserNftHoldingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserNftHoldingCountAggregateInputType | true
    }

  export interface UserNftHoldingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserNftHolding'], meta: { name: 'UserNftHolding' } }
    /**
     * Find zero or one UserNftHolding that matches the filter.
     * @param {UserNftHoldingFindUniqueArgs} args - Arguments to find a UserNftHolding
     * @example
     * // Get one UserNftHolding
     * const userNftHolding = await prisma.userNftHolding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserNftHoldingFindUniqueArgs>(args: SelectSubset<T, UserNftHoldingFindUniqueArgs<ExtArgs>>): Prisma__UserNftHoldingClient<$Result.GetResult<Prisma.$UserNftHoldingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserNftHolding that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserNftHoldingFindUniqueOrThrowArgs} args - Arguments to find a UserNftHolding
     * @example
     * // Get one UserNftHolding
     * const userNftHolding = await prisma.userNftHolding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserNftHoldingFindUniqueOrThrowArgs>(args: SelectSubset<T, UserNftHoldingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserNftHoldingClient<$Result.GetResult<Prisma.$UserNftHoldingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserNftHolding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNftHoldingFindFirstArgs} args - Arguments to find a UserNftHolding
     * @example
     * // Get one UserNftHolding
     * const userNftHolding = await prisma.userNftHolding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserNftHoldingFindFirstArgs>(args?: SelectSubset<T, UserNftHoldingFindFirstArgs<ExtArgs>>): Prisma__UserNftHoldingClient<$Result.GetResult<Prisma.$UserNftHoldingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserNftHolding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNftHoldingFindFirstOrThrowArgs} args - Arguments to find a UserNftHolding
     * @example
     * // Get one UserNftHolding
     * const userNftHolding = await prisma.userNftHolding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserNftHoldingFindFirstOrThrowArgs>(args?: SelectSubset<T, UserNftHoldingFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserNftHoldingClient<$Result.GetResult<Prisma.$UserNftHoldingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserNftHoldings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNftHoldingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserNftHoldings
     * const userNftHoldings = await prisma.userNftHolding.findMany()
     * 
     * // Get first 10 UserNftHoldings
     * const userNftHoldings = await prisma.userNftHolding.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userNftHoldingWithIdOnly = await prisma.userNftHolding.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserNftHoldingFindManyArgs>(args?: SelectSubset<T, UserNftHoldingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNftHoldingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserNftHolding.
     * @param {UserNftHoldingCreateArgs} args - Arguments to create a UserNftHolding.
     * @example
     * // Create one UserNftHolding
     * const UserNftHolding = await prisma.userNftHolding.create({
     *   data: {
     *     // ... data to create a UserNftHolding
     *   }
     * })
     * 
     */
    create<T extends UserNftHoldingCreateArgs>(args: SelectSubset<T, UserNftHoldingCreateArgs<ExtArgs>>): Prisma__UserNftHoldingClient<$Result.GetResult<Prisma.$UserNftHoldingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserNftHoldings.
     * @param {UserNftHoldingCreateManyArgs} args - Arguments to create many UserNftHoldings.
     * @example
     * // Create many UserNftHoldings
     * const userNftHolding = await prisma.userNftHolding.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserNftHoldingCreateManyArgs>(args?: SelectSubset<T, UserNftHoldingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserNftHoldings and returns the data saved in the database.
     * @param {UserNftHoldingCreateManyAndReturnArgs} args - Arguments to create many UserNftHoldings.
     * @example
     * // Create many UserNftHoldings
     * const userNftHolding = await prisma.userNftHolding.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserNftHoldings and only return the `id`
     * const userNftHoldingWithIdOnly = await prisma.userNftHolding.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserNftHoldingCreateManyAndReturnArgs>(args?: SelectSubset<T, UserNftHoldingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNftHoldingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserNftHolding.
     * @param {UserNftHoldingDeleteArgs} args - Arguments to delete one UserNftHolding.
     * @example
     * // Delete one UserNftHolding
     * const UserNftHolding = await prisma.userNftHolding.delete({
     *   where: {
     *     // ... filter to delete one UserNftHolding
     *   }
     * })
     * 
     */
    delete<T extends UserNftHoldingDeleteArgs>(args: SelectSubset<T, UserNftHoldingDeleteArgs<ExtArgs>>): Prisma__UserNftHoldingClient<$Result.GetResult<Prisma.$UserNftHoldingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserNftHolding.
     * @param {UserNftHoldingUpdateArgs} args - Arguments to update one UserNftHolding.
     * @example
     * // Update one UserNftHolding
     * const userNftHolding = await prisma.userNftHolding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserNftHoldingUpdateArgs>(args: SelectSubset<T, UserNftHoldingUpdateArgs<ExtArgs>>): Prisma__UserNftHoldingClient<$Result.GetResult<Prisma.$UserNftHoldingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserNftHoldings.
     * @param {UserNftHoldingDeleteManyArgs} args - Arguments to filter UserNftHoldings to delete.
     * @example
     * // Delete a few UserNftHoldings
     * const { count } = await prisma.userNftHolding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserNftHoldingDeleteManyArgs>(args?: SelectSubset<T, UserNftHoldingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserNftHoldings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNftHoldingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserNftHoldings
     * const userNftHolding = await prisma.userNftHolding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserNftHoldingUpdateManyArgs>(args: SelectSubset<T, UserNftHoldingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserNftHoldings and returns the data updated in the database.
     * @param {UserNftHoldingUpdateManyAndReturnArgs} args - Arguments to update many UserNftHoldings.
     * @example
     * // Update many UserNftHoldings
     * const userNftHolding = await prisma.userNftHolding.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserNftHoldings and only return the `id`
     * const userNftHoldingWithIdOnly = await prisma.userNftHolding.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserNftHoldingUpdateManyAndReturnArgs>(args: SelectSubset<T, UserNftHoldingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserNftHoldingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserNftHolding.
     * @param {UserNftHoldingUpsertArgs} args - Arguments to update or create a UserNftHolding.
     * @example
     * // Update or create a UserNftHolding
     * const userNftHolding = await prisma.userNftHolding.upsert({
     *   create: {
     *     // ... data to create a UserNftHolding
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserNftHolding we want to update
     *   }
     * })
     */
    upsert<T extends UserNftHoldingUpsertArgs>(args: SelectSubset<T, UserNftHoldingUpsertArgs<ExtArgs>>): Prisma__UserNftHoldingClient<$Result.GetResult<Prisma.$UserNftHoldingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserNftHoldings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNftHoldingCountArgs} args - Arguments to filter UserNftHoldings to count.
     * @example
     * // Count the number of UserNftHoldings
     * const count = await prisma.userNftHolding.count({
     *   where: {
     *     // ... the filter for the UserNftHoldings we want to count
     *   }
     * })
    **/
    count<T extends UserNftHoldingCountArgs>(
      args?: Subset<T, UserNftHoldingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserNftHoldingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserNftHolding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNftHoldingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserNftHoldingAggregateArgs>(args: Subset<T, UserNftHoldingAggregateArgs>): Prisma.PrismaPromise<GetUserNftHoldingAggregateType<T>>

    /**
     * Group by UserNftHolding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNftHoldingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserNftHoldingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserNftHoldingGroupByArgs['orderBy'] }
        : { orderBy?: UserNftHoldingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserNftHoldingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserNftHoldingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserNftHolding model
   */
  readonly fields: UserNftHoldingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserNftHolding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserNftHoldingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserNftHolding model
   */
  interface UserNftHoldingFieldRefs {
    readonly id: FieldRef<"UserNftHolding", 'String'>
    readonly userId: FieldRef<"UserNftHolding", 'String'>
    readonly mintAddress: FieldRef<"UserNftHolding", 'String'>
    readonly tokenAccount: FieldRef<"UserNftHolding", 'String'>
    readonly amount: FieldRef<"UserNftHolding", 'Int'>
    readonly metadata: FieldRef<"UserNftHolding", 'Json'>
    readonly acquiredAt: FieldRef<"UserNftHolding", 'DateTime'>
    readonly createdAt: FieldRef<"UserNftHolding", 'DateTime'>
    readonly updatedAt: FieldRef<"UserNftHolding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserNftHolding findUnique
   */
  export type UserNftHoldingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNftHolding
     */
    select?: UserNftHoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNftHolding
     */
    omit?: UserNftHoldingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNftHoldingInclude<ExtArgs> | null
    /**
     * Filter, which UserNftHolding to fetch.
     */
    where: UserNftHoldingWhereUniqueInput
  }

  /**
   * UserNftHolding findUniqueOrThrow
   */
  export type UserNftHoldingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNftHolding
     */
    select?: UserNftHoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNftHolding
     */
    omit?: UserNftHoldingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNftHoldingInclude<ExtArgs> | null
    /**
     * Filter, which UserNftHolding to fetch.
     */
    where: UserNftHoldingWhereUniqueInput
  }

  /**
   * UserNftHolding findFirst
   */
  export type UserNftHoldingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNftHolding
     */
    select?: UserNftHoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNftHolding
     */
    omit?: UserNftHoldingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNftHoldingInclude<ExtArgs> | null
    /**
     * Filter, which UserNftHolding to fetch.
     */
    where?: UserNftHoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNftHoldings to fetch.
     */
    orderBy?: UserNftHoldingOrderByWithRelationInput | UserNftHoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNftHoldings.
     */
    cursor?: UserNftHoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNftHoldings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNftHoldings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNftHoldings.
     */
    distinct?: UserNftHoldingScalarFieldEnum | UserNftHoldingScalarFieldEnum[]
  }

  /**
   * UserNftHolding findFirstOrThrow
   */
  export type UserNftHoldingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNftHolding
     */
    select?: UserNftHoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNftHolding
     */
    omit?: UserNftHoldingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNftHoldingInclude<ExtArgs> | null
    /**
     * Filter, which UserNftHolding to fetch.
     */
    where?: UserNftHoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNftHoldings to fetch.
     */
    orderBy?: UserNftHoldingOrderByWithRelationInput | UserNftHoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserNftHoldings.
     */
    cursor?: UserNftHoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNftHoldings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNftHoldings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserNftHoldings.
     */
    distinct?: UserNftHoldingScalarFieldEnum | UserNftHoldingScalarFieldEnum[]
  }

  /**
   * UserNftHolding findMany
   */
  export type UserNftHoldingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNftHolding
     */
    select?: UserNftHoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNftHolding
     */
    omit?: UserNftHoldingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNftHoldingInclude<ExtArgs> | null
    /**
     * Filter, which UserNftHoldings to fetch.
     */
    where?: UserNftHoldingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserNftHoldings to fetch.
     */
    orderBy?: UserNftHoldingOrderByWithRelationInput | UserNftHoldingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserNftHoldings.
     */
    cursor?: UserNftHoldingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserNftHoldings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserNftHoldings.
     */
    skip?: number
    distinct?: UserNftHoldingScalarFieldEnum | UserNftHoldingScalarFieldEnum[]
  }

  /**
   * UserNftHolding create
   */
  export type UserNftHoldingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNftHolding
     */
    select?: UserNftHoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNftHolding
     */
    omit?: UserNftHoldingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNftHoldingInclude<ExtArgs> | null
    /**
     * The data needed to create a UserNftHolding.
     */
    data: XOR<UserNftHoldingCreateInput, UserNftHoldingUncheckedCreateInput>
  }

  /**
   * UserNftHolding createMany
   */
  export type UserNftHoldingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserNftHoldings.
     */
    data: UserNftHoldingCreateManyInput | UserNftHoldingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserNftHolding createManyAndReturn
   */
  export type UserNftHoldingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNftHolding
     */
    select?: UserNftHoldingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserNftHolding
     */
    omit?: UserNftHoldingOmit<ExtArgs> | null
    /**
     * The data used to create many UserNftHoldings.
     */
    data: UserNftHoldingCreateManyInput | UserNftHoldingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNftHoldingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserNftHolding update
   */
  export type UserNftHoldingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNftHolding
     */
    select?: UserNftHoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNftHolding
     */
    omit?: UserNftHoldingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNftHoldingInclude<ExtArgs> | null
    /**
     * The data needed to update a UserNftHolding.
     */
    data: XOR<UserNftHoldingUpdateInput, UserNftHoldingUncheckedUpdateInput>
    /**
     * Choose, which UserNftHolding to update.
     */
    where: UserNftHoldingWhereUniqueInput
  }

  /**
   * UserNftHolding updateMany
   */
  export type UserNftHoldingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserNftHoldings.
     */
    data: XOR<UserNftHoldingUpdateManyMutationInput, UserNftHoldingUncheckedUpdateManyInput>
    /**
     * Filter which UserNftHoldings to update
     */
    where?: UserNftHoldingWhereInput
    /**
     * Limit how many UserNftHoldings to update.
     */
    limit?: number
  }

  /**
   * UserNftHolding updateManyAndReturn
   */
  export type UserNftHoldingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNftHolding
     */
    select?: UserNftHoldingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserNftHolding
     */
    omit?: UserNftHoldingOmit<ExtArgs> | null
    /**
     * The data used to update UserNftHoldings.
     */
    data: XOR<UserNftHoldingUpdateManyMutationInput, UserNftHoldingUncheckedUpdateManyInput>
    /**
     * Filter which UserNftHoldings to update
     */
    where?: UserNftHoldingWhereInput
    /**
     * Limit how many UserNftHoldings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNftHoldingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserNftHolding upsert
   */
  export type UserNftHoldingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNftHolding
     */
    select?: UserNftHoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNftHolding
     */
    omit?: UserNftHoldingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNftHoldingInclude<ExtArgs> | null
    /**
     * The filter to search for the UserNftHolding to update in case it exists.
     */
    where: UserNftHoldingWhereUniqueInput
    /**
     * In case the UserNftHolding found by the `where` argument doesn't exist, create a new UserNftHolding with this data.
     */
    create: XOR<UserNftHoldingCreateInput, UserNftHoldingUncheckedCreateInput>
    /**
     * In case the UserNftHolding was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserNftHoldingUpdateInput, UserNftHoldingUncheckedUpdateInput>
  }

  /**
   * UserNftHolding delete
   */
  export type UserNftHoldingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNftHolding
     */
    select?: UserNftHoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNftHolding
     */
    omit?: UserNftHoldingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNftHoldingInclude<ExtArgs> | null
    /**
     * Filter which UserNftHolding to delete.
     */
    where: UserNftHoldingWhereUniqueInput
  }

  /**
   * UserNftHolding deleteMany
   */
  export type UserNftHoldingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserNftHoldings to delete
     */
    where?: UserNftHoldingWhereInput
    /**
     * Limit how many UserNftHoldings to delete.
     */
    limit?: number
  }

  /**
   * UserNftHolding without action
   */
  export type UserNftHoldingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserNftHolding
     */
    select?: UserNftHoldingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserNftHolding
     */
    omit?: UserNftHoldingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserNftHoldingInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    walletAddress: 'walletAddress',
    twitterId: 'twitterId',
    twitterUsername: 'twitterUsername',
    twitterName: 'twitterName',
    twitterImage: 'twitterImage',
    twitterFollowers: 'twitterFollowers',
    twitterActivity: 'twitterActivity',
    level: 'level',
    streak: 'streak',
    lastCheckIn: 'lastCheckIn',
    referralCode: 'referralCode',
    email: 'email',
    totalPoints: 'totalPoints',
    rank: 'rank',
    isAdmin: 'isAdmin',
    isActive: 'isActive',
    totalEarnedTokens: 'totalEarnedTokens',
    lastLoginReward: 'lastLoginReward',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    permissions: 'permissions',
    riskScore: 'riskScore',
    suspiciousFlags: 'suspiciousFlags',
    isBanned: 'isBanned',
    bannedAt: 'bannedAt',
    lastActivity: 'lastActivity',
    claimsEnabled: 'claimsEnabled'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    icon: 'icon',
    requirements: 'requirements',
    points: 'points',
    isSecret: 'isSecret',
    createdAt: 'createdAt'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const UserAchievementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    achievementId: 'achievementId',
    unlockedAt: 'unlockedAt',
    progress: 'progress'
  };

  export type UserAchievementScalarFieldEnum = (typeof UserAchievementScalarFieldEnum)[keyof typeof UserAchievementScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    message: 'message',
    type: 'type',
    read: 'read',
    actionUrl: 'actionUrl',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const TwitterAnalyticsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tweetId: 'tweetId',
    likes: 'likes',
    retweets: 'retweets',
    comments: 'comments',
    impressions: 'impressions',
    engagement_rate: 'engagement_rate',
    calculatedAt: 'calculatedAt'
  };

  export type TwitterAnalyticsScalarFieldEnum = (typeof TwitterAnalyticsScalarFieldEnum)[keyof typeof TwitterAnalyticsScalarFieldEnum]


  export const TwitterEngagementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tweetId: 'tweetId',
    engagementType: 'engagementType',
    points: 'points',
    verified: 'verified',
    createdAt: 'createdAt'
  };

  export type TwitterEngagementScalarFieldEnum = (typeof TwitterEngagementScalarFieldEnum)[keyof typeof TwitterEngagementScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    points: 'points',
    requirements: 'requirements',
    isActive: 'isActive',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const AdminSessionScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    permissions: 'permissions',
    expiresAt: 'expiresAt',
    lastActivity: 'lastActivity',
    createdAt: 'createdAt'
  };

  export type AdminSessionScalarFieldEnum = (typeof AdminSessionScalarFieldEnum)[keyof typeof AdminSessionScalarFieldEnum]


  export const AdminAuditLogScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    action: 'action',
    metadata: 'metadata',
    timestamp: 'timestamp',
    ipAddress: 'ipAddress'
  };

  export type AdminAuditLogScalarFieldEnum = (typeof AdminAuditLogScalarFieldEnum)[keyof typeof AdminAuditLogScalarFieldEnum]


  export const FraudAlertScalarFieldEnum: {
    id: 'id',
    type: 'type',
    severity: 'severity',
    userId: 'userId',
    description: 'description',
    evidence: 'evidence',
    riskScore: 'riskScore',
    status: 'status',
    createdAt: 'createdAt',
    investigatedBy: 'investigatedBy',
    resolvedAt: 'resolvedAt'
  };

  export type FraudAlertScalarFieldEnum = (typeof FraudAlertScalarFieldEnum)[keyof typeof FraudAlertScalarFieldEnum]


  export const CampaignConfigScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    tokenMint: 'tokenMint',
    totalAllocation: 'totalAllocation',
    startDate: 'startDate',
    endDate: 'endDate',
    eligibilityCriteria: 'eligibilityCriteria',
    distributionRules: 'distributionRules',
    isActive: 'isActive',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CampaignConfigScalarFieldEnum = (typeof CampaignConfigScalarFieldEnum)[keyof typeof CampaignConfigScalarFieldEnum]


  export const TaskCompletionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    taskId: 'taskId',
    completed: 'completed',
    points: 'points',
    metadata: 'metadata',
    completedAt: 'completedAt',
    createdAt: 'createdAt'
  };

  export type TaskCompletionScalarFieldEnum = (typeof TaskCompletionScalarFieldEnum)[keyof typeof TaskCompletionScalarFieldEnum]


  export const ClaimScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    transactionHash: 'transactionHash',
    status: 'status',
    paymentMethod: 'paymentMethod',
    metadata: 'metadata',
    processedAt: 'processedAt',
    feesPaid: 'feesPaid',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    type: 'type',
    nftPasses: 'nftPasses',
    userTier: 'userTier'
  };

  export type ClaimScalarFieldEnum = (typeof ClaimScalarFieldEnum)[keyof typeof ClaimScalarFieldEnum]


  export const PointHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    points: 'points',
    action: 'action',
    description: 'description',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type PointHistoryScalarFieldEnum = (typeof PointHistoryScalarFieldEnum)[keyof typeof PointHistoryScalarFieldEnum]


  export const ReferralScalarFieldEnum: {
    id: 'id',
    referrerId: 'referrerId',
    referredId: 'referredId',
    points: 'points',
    completed: 'completed',
    createdAt: 'createdAt',
    isActive: 'isActive'
  };

  export type ReferralScalarFieldEnum = (typeof ReferralScalarFieldEnum)[keyof typeof ReferralScalarFieldEnum]


  export const SystemConfigScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    description: 'description',
    updatedAt: 'updatedAt'
  };

  export type SystemConfigScalarFieldEnum = (typeof SystemConfigScalarFieldEnum)[keyof typeof SystemConfigScalarFieldEnum]


  export const AnalyticsScalarFieldEnum: {
    id: 'id',
    date: 'date',
    totalUsers: 'totalUsers',
    activeUsers: 'activeUsers',
    totalClaims: 'totalClaims',
    totalPoints: 'totalPoints',
    totalEngagements: 'totalEngagements',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AnalyticsScalarFieldEnum = (typeof AnalyticsScalarFieldEnum)[keyof typeof AnalyticsScalarFieldEnum]


  export const DailyEarningScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokens: 'tokens',
    type: 'type',
    claimedAt: 'claimedAt'
  };

  export type DailyEarningScalarFieldEnum = (typeof DailyEarningScalarFieldEnum)[keyof typeof DailyEarningScalarFieldEnum]


  export const AirdropSeasonScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    totalAllocation: 'totalAllocation',
    claimedAmount: 'claimedAmount',
    startDate: 'startDate',
    endDate: 'endDate',
    nftPassRequired: 'nftPassRequired',
    requireApproval: 'requireApproval',
    feeAmount: 'feeAmount',
    createdBy: 'createdBy',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AirdropSeasonScalarFieldEnum = (typeof AirdropSeasonScalarFieldEnum)[keyof typeof AirdropSeasonScalarFieldEnum]


  export const AirdropClaimScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    seasonId: 'seasonId',
    tokens: 'tokens',
    tier: 'tier',
    paymentSignature: 'paymentSignature',
    transactionSignature: 'transactionSignature',
    status: 'status',
    claimedAt: 'claimedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AirdropClaimScalarFieldEnum = (typeof AirdropClaimScalarFieldEnum)[keyof typeof AirdropClaimScalarFieldEnum]


  export const NftCollectionScalarFieldEnum: {
    id: 'id',
    mintAddress: 'mintAddress',
    name: 'name',
    symbol: 'symbol',
    description: 'description',
    uri: 'uri',
    supply: 'supply',
    createdBy: 'createdBy',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NftCollectionScalarFieldEnum = (typeof NftCollectionScalarFieldEnum)[keyof typeof NftCollectionScalarFieldEnum]


  export const NftDistributionScalarFieldEnum: {
    id: 'id',
    mintAddress: 'mintAddress',
    distributedBy: 'distributedBy',
    recipientCount: 'recipientCount',
    nftsPerUser: 'nftsPerUser',
    results: 'results',
    success: 'success',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NftDistributionScalarFieldEnum = (typeof NftDistributionScalarFieldEnum)[keyof typeof NftDistributionScalarFieldEnum]


  export const NftClaimApprovalScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    approved: 'approved',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NftClaimApprovalScalarFieldEnum = (typeof NftClaimApprovalScalarFieldEnum)[keyof typeof NftClaimApprovalScalarFieldEnum]


  export const UserNftHoldingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    mintAddress: 'mintAddress',
    tokenAccount: 'tokenAccount',
    amount: 'amount',
    metadata: 'metadata',
    acquiredAt: 'acquiredAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserNftHoldingScalarFieldEnum = (typeof UserNftHoldingScalarFieldEnum)[keyof typeof UserNftHoldingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'TwitterActivity'
   */
  export type EnumTwitterActivityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TwitterActivity'>
    


  /**
   * Reference to a field of type 'TwitterActivity[]'
   */
  export type ListEnumTwitterActivityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TwitterActivity[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'EngagementType'
   */
  export type EnumEngagementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EngagementType'>
    


  /**
   * Reference to a field of type 'EngagementType[]'
   */
  export type ListEnumEngagementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EngagementType[]'>
    


  /**
   * Reference to a field of type 'TaskType'
   */
  export type EnumTaskTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskType'>
    


  /**
   * Reference to a field of type 'TaskType[]'
   */
  export type ListEnumTaskTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskType[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'ClaimStatus'
   */
  export type EnumClaimStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClaimStatus'>
    


  /**
   * Reference to a field of type 'ClaimStatus[]'
   */
  export type ListEnumClaimStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClaimStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    walletAddress?: StringFilter<"User"> | string
    twitterId?: StringNullableFilter<"User"> | string | null
    twitterUsername?: StringNullableFilter<"User"> | string | null
    twitterName?: StringNullableFilter<"User"> | string | null
    twitterImage?: StringNullableFilter<"User"> | string | null
    twitterFollowers?: IntNullableFilter<"User"> | number | null
    twitterActivity?: EnumTwitterActivityNullableFilter<"User"> | $Enums.TwitterActivity | null
    level?: IntFilter<"User"> | number
    streak?: IntFilter<"User"> | number
    lastCheckIn?: DateTimeNullableFilter<"User"> | Date | string | null
    referralCode?: StringFilter<"User"> | string
    email?: StringNullableFilter<"User"> | string | null
    totalPoints?: IntFilter<"User"> | number
    rank?: IntFilter<"User"> | number
    isAdmin?: BoolFilter<"User"> | boolean
    isActive?: BoolFilter<"User"> | boolean
    totalEarnedTokens?: FloatFilter<"User"> | number
    lastLoginReward?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    permissions?: JsonNullableFilter<"User">
    riskScore?: IntFilter<"User"> | number
    suspiciousFlags?: StringNullableListFilter<"User">
    isBanned?: BoolFilter<"User"> | boolean
    bannedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastActivity?: DateTimeNullableFilter<"User"> | Date | string | null
    claimsEnabled?: BoolNullableFilter<"User"> | boolean | null
    dailyEarnings?: DailyEarningListRelationFilter
    airdropClaims?: AirdropClaimListRelationFilter
    engagements?: TwitterEngagementListRelationFilter
    tasks?: TaskCompletionListRelationFilter
    claims?: ClaimListRelationFilter
    pointHistory?: PointHistoryListRelationFilter
    referrals?: ReferralListRelationFilter
    referredBy?: XOR<ReferralNullableScalarRelationFilter, ReferralWhereInput> | null
    achievements?: UserAchievementListRelationFilter
    notifications?: NotificationListRelationFilter
    adminSessions?: AdminSessionListRelationFilter
    auditLogs?: AdminAuditLogListRelationFilter
    fraudAlerts?: FraudAlertListRelationFilter
    campaigns?: CampaignConfigListRelationFilter
    nftCollections?: NftCollectionListRelationFilter
    nftDistributions?: NftDistributionListRelationFilter
    nftHoldings?: UserNftHoldingListRelationFilter
    nftClaimApproval?: XOR<NftClaimApprovalNullableScalarRelationFilter, NftClaimApprovalWhereInput> | null
    approvedClaims?: NftClaimApprovalListRelationFilter
    airdropSeasons?: AirdropSeasonListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    walletAddress?: SortOrder
    twitterId?: SortOrderInput | SortOrder
    twitterUsername?: SortOrderInput | SortOrder
    twitterName?: SortOrderInput | SortOrder
    twitterImage?: SortOrderInput | SortOrder
    twitterFollowers?: SortOrderInput | SortOrder
    twitterActivity?: SortOrderInput | SortOrder
    level?: SortOrder
    streak?: SortOrder
    lastCheckIn?: SortOrderInput | SortOrder
    referralCode?: SortOrder
    email?: SortOrderInput | SortOrder
    totalPoints?: SortOrder
    rank?: SortOrder
    isAdmin?: SortOrder
    isActive?: SortOrder
    totalEarnedTokens?: SortOrder
    lastLoginReward?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    permissions?: SortOrderInput | SortOrder
    riskScore?: SortOrder
    suspiciousFlags?: SortOrder
    isBanned?: SortOrder
    bannedAt?: SortOrderInput | SortOrder
    lastActivity?: SortOrderInput | SortOrder
    claimsEnabled?: SortOrderInput | SortOrder
    dailyEarnings?: DailyEarningOrderByRelationAggregateInput
    airdropClaims?: AirdropClaimOrderByRelationAggregateInput
    engagements?: TwitterEngagementOrderByRelationAggregateInput
    tasks?: TaskCompletionOrderByRelationAggregateInput
    claims?: ClaimOrderByRelationAggregateInput
    pointHistory?: PointHistoryOrderByRelationAggregateInput
    referrals?: ReferralOrderByRelationAggregateInput
    referredBy?: ReferralOrderByWithRelationInput
    achievements?: UserAchievementOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    adminSessions?: AdminSessionOrderByRelationAggregateInput
    auditLogs?: AdminAuditLogOrderByRelationAggregateInput
    fraudAlerts?: FraudAlertOrderByRelationAggregateInput
    campaigns?: CampaignConfigOrderByRelationAggregateInput
    nftCollections?: NftCollectionOrderByRelationAggregateInput
    nftDistributions?: NftDistributionOrderByRelationAggregateInput
    nftHoldings?: UserNftHoldingOrderByRelationAggregateInput
    nftClaimApproval?: NftClaimApprovalOrderByWithRelationInput
    approvedClaims?: NftClaimApprovalOrderByRelationAggregateInput
    airdropSeasons?: AirdropSeasonOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    walletAddress?: string
    twitterId?: string
    referralCode?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    twitterUsername?: StringNullableFilter<"User"> | string | null
    twitterName?: StringNullableFilter<"User"> | string | null
    twitterImage?: StringNullableFilter<"User"> | string | null
    twitterFollowers?: IntNullableFilter<"User"> | number | null
    twitterActivity?: EnumTwitterActivityNullableFilter<"User"> | $Enums.TwitterActivity | null
    level?: IntFilter<"User"> | number
    streak?: IntFilter<"User"> | number
    lastCheckIn?: DateTimeNullableFilter<"User"> | Date | string | null
    totalPoints?: IntFilter<"User"> | number
    rank?: IntFilter<"User"> | number
    isAdmin?: BoolFilter<"User"> | boolean
    isActive?: BoolFilter<"User"> | boolean
    totalEarnedTokens?: FloatFilter<"User"> | number
    lastLoginReward?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    permissions?: JsonNullableFilter<"User">
    riskScore?: IntFilter<"User"> | number
    suspiciousFlags?: StringNullableListFilter<"User">
    isBanned?: BoolFilter<"User"> | boolean
    bannedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastActivity?: DateTimeNullableFilter<"User"> | Date | string | null
    claimsEnabled?: BoolNullableFilter<"User"> | boolean | null
    dailyEarnings?: DailyEarningListRelationFilter
    airdropClaims?: AirdropClaimListRelationFilter
    engagements?: TwitterEngagementListRelationFilter
    tasks?: TaskCompletionListRelationFilter
    claims?: ClaimListRelationFilter
    pointHistory?: PointHistoryListRelationFilter
    referrals?: ReferralListRelationFilter
    referredBy?: XOR<ReferralNullableScalarRelationFilter, ReferralWhereInput> | null
    achievements?: UserAchievementListRelationFilter
    notifications?: NotificationListRelationFilter
    adminSessions?: AdminSessionListRelationFilter
    auditLogs?: AdminAuditLogListRelationFilter
    fraudAlerts?: FraudAlertListRelationFilter
    campaigns?: CampaignConfigListRelationFilter
    nftCollections?: NftCollectionListRelationFilter
    nftDistributions?: NftDistributionListRelationFilter
    nftHoldings?: UserNftHoldingListRelationFilter
    nftClaimApproval?: XOR<NftClaimApprovalNullableScalarRelationFilter, NftClaimApprovalWhereInput> | null
    approvedClaims?: NftClaimApprovalListRelationFilter
    airdropSeasons?: AirdropSeasonListRelationFilter
  }, "id" | "walletAddress" | "twitterId" | "referralCode" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    walletAddress?: SortOrder
    twitterId?: SortOrderInput | SortOrder
    twitterUsername?: SortOrderInput | SortOrder
    twitterName?: SortOrderInput | SortOrder
    twitterImage?: SortOrderInput | SortOrder
    twitterFollowers?: SortOrderInput | SortOrder
    twitterActivity?: SortOrderInput | SortOrder
    level?: SortOrder
    streak?: SortOrder
    lastCheckIn?: SortOrderInput | SortOrder
    referralCode?: SortOrder
    email?: SortOrderInput | SortOrder
    totalPoints?: SortOrder
    rank?: SortOrder
    isAdmin?: SortOrder
    isActive?: SortOrder
    totalEarnedTokens?: SortOrder
    lastLoginReward?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    permissions?: SortOrderInput | SortOrder
    riskScore?: SortOrder
    suspiciousFlags?: SortOrder
    isBanned?: SortOrder
    bannedAt?: SortOrderInput | SortOrder
    lastActivity?: SortOrderInput | SortOrder
    claimsEnabled?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    walletAddress?: StringWithAggregatesFilter<"User"> | string
    twitterId?: StringNullableWithAggregatesFilter<"User"> | string | null
    twitterUsername?: StringNullableWithAggregatesFilter<"User"> | string | null
    twitterName?: StringNullableWithAggregatesFilter<"User"> | string | null
    twitterImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    twitterFollowers?: IntNullableWithAggregatesFilter<"User"> | number | null
    twitterActivity?: EnumTwitterActivityNullableWithAggregatesFilter<"User"> | $Enums.TwitterActivity | null
    level?: IntWithAggregatesFilter<"User"> | number
    streak?: IntWithAggregatesFilter<"User"> | number
    lastCheckIn?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    referralCode?: StringWithAggregatesFilter<"User"> | string
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    totalPoints?: IntWithAggregatesFilter<"User"> | number
    rank?: IntWithAggregatesFilter<"User"> | number
    isAdmin?: BoolWithAggregatesFilter<"User"> | boolean
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    totalEarnedTokens?: FloatWithAggregatesFilter<"User"> | number
    lastLoginReward?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    permissions?: JsonNullableWithAggregatesFilter<"User">
    riskScore?: IntWithAggregatesFilter<"User"> | number
    suspiciousFlags?: StringNullableListFilter<"User">
    isBanned?: BoolWithAggregatesFilter<"User"> | boolean
    bannedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastActivity?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    claimsEnabled?: BoolNullableWithAggregatesFilter<"User"> | boolean | null
  }

  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: StringFilter<"Achievement"> | string
    name?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    icon?: StringFilter<"Achievement"> | string
    requirements?: JsonFilter<"Achievement">
    points?: IntFilter<"Achievement"> | number
    isSecret?: BoolFilter<"Achievement"> | boolean
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    userAchievements?: UserAchievementListRelationFilter
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    requirements?: SortOrder
    points?: SortOrder
    isSecret?: SortOrder
    createdAt?: SortOrder
    userAchievements?: UserAchievementOrderByRelationAggregateInput
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    name?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    icon?: StringFilter<"Achievement"> | string
    requirements?: JsonFilter<"Achievement">
    points?: IntFilter<"Achievement"> | number
    isSecret?: BoolFilter<"Achievement"> | boolean
    createdAt?: DateTimeFilter<"Achievement"> | Date | string
    userAchievements?: UserAchievementListRelationFilter
  }, "id">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    requirements?: SortOrder
    points?: SortOrder
    isSecret?: SortOrder
    createdAt?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _avg?: AchievementAvgOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
    _sum?: AchievementSumOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Achievement"> | string
    name?: StringWithAggregatesFilter<"Achievement"> | string
    description?: StringWithAggregatesFilter<"Achievement"> | string
    icon?: StringWithAggregatesFilter<"Achievement"> | string
    requirements?: JsonWithAggregatesFilter<"Achievement">
    points?: IntWithAggregatesFilter<"Achievement"> | number
    isSecret?: BoolWithAggregatesFilter<"Achievement"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Achievement"> | Date | string
  }

  export type UserAchievementWhereInput = {
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    unlockedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    progress?: IntFilter<"UserAchievement"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    achievement?: XOR<AchievementScalarRelationFilter, AchievementWhereInput>
  }

  export type UserAchievementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    unlockedAt?: SortOrder
    progress?: SortOrder
    user?: UserOrderByWithRelationInput
    achievement?: AchievementOrderByWithRelationInput
  }

  export type UserAchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_achievementId?: UserAchievementUserIdAchievementIdCompoundUniqueInput
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    unlockedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    progress?: IntFilter<"UserAchievement"> | number
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    achievement?: XOR<AchievementScalarRelationFilter, AchievementWhereInput>
  }, "id" | "userId_achievementId">

  export type UserAchievementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    unlockedAt?: SortOrder
    progress?: SortOrder
    _count?: UserAchievementCountOrderByAggregateInput
    _avg?: UserAchievementAvgOrderByAggregateInput
    _max?: UserAchievementMaxOrderByAggregateInput
    _min?: UserAchievementMinOrderByAggregateInput
    _sum?: UserAchievementSumOrderByAggregateInput
  }

  export type UserAchievementScalarWhereWithAggregatesInput = {
    AND?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    OR?: UserAchievementScalarWhereWithAggregatesInput[]
    NOT?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAchievement"> | string
    userId?: StringWithAggregatesFilter<"UserAchievement"> | string
    achievementId?: StringWithAggregatesFilter<"UserAchievement"> | string
    unlockedAt?: DateTimeWithAggregatesFilter<"UserAchievement"> | Date | string
    progress?: IntWithAggregatesFilter<"UserAchievement"> | number
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    read?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    read?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    actionUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type TwitterAnalyticsWhereInput = {
    AND?: TwitterAnalyticsWhereInput | TwitterAnalyticsWhereInput[]
    OR?: TwitterAnalyticsWhereInput[]
    NOT?: TwitterAnalyticsWhereInput | TwitterAnalyticsWhereInput[]
    id?: StringFilter<"TwitterAnalytics"> | string
    userId?: StringNullableFilter<"TwitterAnalytics"> | string | null
    tweetId?: StringFilter<"TwitterAnalytics"> | string
    likes?: IntFilter<"TwitterAnalytics"> | number
    retweets?: IntFilter<"TwitterAnalytics"> | number
    comments?: IntFilter<"TwitterAnalytics"> | number
    impressions?: IntFilter<"TwitterAnalytics"> | number
    engagement_rate?: FloatFilter<"TwitterAnalytics"> | number
    calculatedAt?: DateTimeFilter<"TwitterAnalytics"> | Date | string
  }

  export type TwitterAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    tweetId?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    comments?: SortOrder
    impressions?: SortOrder
    engagement_rate?: SortOrder
    calculatedAt?: SortOrder
  }

  export type TwitterAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tweetId?: string
    AND?: TwitterAnalyticsWhereInput | TwitterAnalyticsWhereInput[]
    OR?: TwitterAnalyticsWhereInput[]
    NOT?: TwitterAnalyticsWhereInput | TwitterAnalyticsWhereInput[]
    userId?: StringNullableFilter<"TwitterAnalytics"> | string | null
    likes?: IntFilter<"TwitterAnalytics"> | number
    retweets?: IntFilter<"TwitterAnalytics"> | number
    comments?: IntFilter<"TwitterAnalytics"> | number
    impressions?: IntFilter<"TwitterAnalytics"> | number
    engagement_rate?: FloatFilter<"TwitterAnalytics"> | number
    calculatedAt?: DateTimeFilter<"TwitterAnalytics"> | Date | string
  }, "id" | "tweetId">

  export type TwitterAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    tweetId?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    comments?: SortOrder
    impressions?: SortOrder
    engagement_rate?: SortOrder
    calculatedAt?: SortOrder
    _count?: TwitterAnalyticsCountOrderByAggregateInput
    _avg?: TwitterAnalyticsAvgOrderByAggregateInput
    _max?: TwitterAnalyticsMaxOrderByAggregateInput
    _min?: TwitterAnalyticsMinOrderByAggregateInput
    _sum?: TwitterAnalyticsSumOrderByAggregateInput
  }

  export type TwitterAnalyticsScalarWhereWithAggregatesInput = {
    AND?: TwitterAnalyticsScalarWhereWithAggregatesInput | TwitterAnalyticsScalarWhereWithAggregatesInput[]
    OR?: TwitterAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: TwitterAnalyticsScalarWhereWithAggregatesInput | TwitterAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TwitterAnalytics"> | string
    userId?: StringNullableWithAggregatesFilter<"TwitterAnalytics"> | string | null
    tweetId?: StringWithAggregatesFilter<"TwitterAnalytics"> | string
    likes?: IntWithAggregatesFilter<"TwitterAnalytics"> | number
    retweets?: IntWithAggregatesFilter<"TwitterAnalytics"> | number
    comments?: IntWithAggregatesFilter<"TwitterAnalytics"> | number
    impressions?: IntWithAggregatesFilter<"TwitterAnalytics"> | number
    engagement_rate?: FloatWithAggregatesFilter<"TwitterAnalytics"> | number
    calculatedAt?: DateTimeWithAggregatesFilter<"TwitterAnalytics"> | Date | string
  }

  export type TwitterEngagementWhereInput = {
    AND?: TwitterEngagementWhereInput | TwitterEngagementWhereInput[]
    OR?: TwitterEngagementWhereInput[]
    NOT?: TwitterEngagementWhereInput | TwitterEngagementWhereInput[]
    id?: StringFilter<"TwitterEngagement"> | string
    userId?: StringFilter<"TwitterEngagement"> | string
    tweetId?: StringFilter<"TwitterEngagement"> | string
    engagementType?: EnumEngagementTypeFilter<"TwitterEngagement"> | $Enums.EngagementType
    points?: IntFilter<"TwitterEngagement"> | number
    verified?: BoolFilter<"TwitterEngagement"> | boolean
    createdAt?: DateTimeFilter<"TwitterEngagement"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TwitterEngagementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tweetId?: SortOrder
    engagementType?: SortOrder
    points?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TwitterEngagementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_tweetId_engagementType?: TwitterEngagementUserIdTweetIdEngagementTypeCompoundUniqueInput
    AND?: TwitterEngagementWhereInput | TwitterEngagementWhereInput[]
    OR?: TwitterEngagementWhereInput[]
    NOT?: TwitterEngagementWhereInput | TwitterEngagementWhereInput[]
    userId?: StringFilter<"TwitterEngagement"> | string
    tweetId?: StringFilter<"TwitterEngagement"> | string
    engagementType?: EnumEngagementTypeFilter<"TwitterEngagement"> | $Enums.EngagementType
    points?: IntFilter<"TwitterEngagement"> | number
    verified?: BoolFilter<"TwitterEngagement"> | boolean
    createdAt?: DateTimeFilter<"TwitterEngagement"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_tweetId_engagementType">

  export type TwitterEngagementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tweetId?: SortOrder
    engagementType?: SortOrder
    points?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    _count?: TwitterEngagementCountOrderByAggregateInput
    _avg?: TwitterEngagementAvgOrderByAggregateInput
    _max?: TwitterEngagementMaxOrderByAggregateInput
    _min?: TwitterEngagementMinOrderByAggregateInput
    _sum?: TwitterEngagementSumOrderByAggregateInput
  }

  export type TwitterEngagementScalarWhereWithAggregatesInput = {
    AND?: TwitterEngagementScalarWhereWithAggregatesInput | TwitterEngagementScalarWhereWithAggregatesInput[]
    OR?: TwitterEngagementScalarWhereWithAggregatesInput[]
    NOT?: TwitterEngagementScalarWhereWithAggregatesInput | TwitterEngagementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TwitterEngagement"> | string
    userId?: StringWithAggregatesFilter<"TwitterEngagement"> | string
    tweetId?: StringWithAggregatesFilter<"TwitterEngagement"> | string
    engagementType?: EnumEngagementTypeWithAggregatesFilter<"TwitterEngagement"> | $Enums.EngagementType
    points?: IntWithAggregatesFilter<"TwitterEngagement"> | number
    verified?: BoolWithAggregatesFilter<"TwitterEngagement"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TwitterEngagement"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    name?: StringFilter<"Task"> | string
    description?: StringFilter<"Task"> | string
    type?: EnumTaskTypeFilter<"Task"> | $Enums.TaskType
    points?: IntFilter<"Task"> | number
    requirements?: JsonFilter<"Task">
    isActive?: BoolFilter<"Task"> | boolean
    expiresAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    completions?: TaskCompletionListRelationFilter
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    points?: SortOrder
    requirements?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    completions?: TaskCompletionOrderByRelationAggregateInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    name?: StringFilter<"Task"> | string
    description?: StringFilter<"Task"> | string
    type?: EnumTaskTypeFilter<"Task"> | $Enums.TaskType
    points?: IntFilter<"Task"> | number
    requirements?: JsonFilter<"Task">
    isActive?: BoolFilter<"Task"> | boolean
    expiresAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    completions?: TaskCompletionListRelationFilter
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    points?: SortOrder
    requirements?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    name?: StringWithAggregatesFilter<"Task"> | string
    description?: StringWithAggregatesFilter<"Task"> | string
    type?: EnumTaskTypeWithAggregatesFilter<"Task"> | $Enums.TaskType
    points?: IntWithAggregatesFilter<"Task"> | number
    requirements?: JsonWithAggregatesFilter<"Task">
    isActive?: BoolWithAggregatesFilter<"Task"> | boolean
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type AdminSessionWhereInput = {
    AND?: AdminSessionWhereInput | AdminSessionWhereInput[]
    OR?: AdminSessionWhereInput[]
    NOT?: AdminSessionWhereInput | AdminSessionWhereInput[]
    id?: StringFilter<"AdminSession"> | string
    adminId?: StringFilter<"AdminSession"> | string
    ipAddress?: StringFilter<"AdminSession"> | string
    userAgent?: StringFilter<"AdminSession"> | string
    permissions?: JsonFilter<"AdminSession">
    expiresAt?: DateTimeFilter<"AdminSession"> | Date | string
    lastActivity?: DateTimeFilter<"AdminSession"> | Date | string
    createdAt?: DateTimeFilter<"AdminSession"> | Date | string
    admin?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AdminSessionOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    permissions?: SortOrder
    expiresAt?: SortOrder
    lastActivity?: SortOrder
    createdAt?: SortOrder
    admin?: UserOrderByWithRelationInput
  }

  export type AdminSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminSessionWhereInput | AdminSessionWhereInput[]
    OR?: AdminSessionWhereInput[]
    NOT?: AdminSessionWhereInput | AdminSessionWhereInput[]
    adminId?: StringFilter<"AdminSession"> | string
    ipAddress?: StringFilter<"AdminSession"> | string
    userAgent?: StringFilter<"AdminSession"> | string
    permissions?: JsonFilter<"AdminSession">
    expiresAt?: DateTimeFilter<"AdminSession"> | Date | string
    lastActivity?: DateTimeFilter<"AdminSession"> | Date | string
    createdAt?: DateTimeFilter<"AdminSession"> | Date | string
    admin?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AdminSessionOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    permissions?: SortOrder
    expiresAt?: SortOrder
    lastActivity?: SortOrder
    createdAt?: SortOrder
    _count?: AdminSessionCountOrderByAggregateInput
    _max?: AdminSessionMaxOrderByAggregateInput
    _min?: AdminSessionMinOrderByAggregateInput
  }

  export type AdminSessionScalarWhereWithAggregatesInput = {
    AND?: AdminSessionScalarWhereWithAggregatesInput | AdminSessionScalarWhereWithAggregatesInput[]
    OR?: AdminSessionScalarWhereWithAggregatesInput[]
    NOT?: AdminSessionScalarWhereWithAggregatesInput | AdminSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminSession"> | string
    adminId?: StringWithAggregatesFilter<"AdminSession"> | string
    ipAddress?: StringWithAggregatesFilter<"AdminSession"> | string
    userAgent?: StringWithAggregatesFilter<"AdminSession"> | string
    permissions?: JsonWithAggregatesFilter<"AdminSession">
    expiresAt?: DateTimeWithAggregatesFilter<"AdminSession"> | Date | string
    lastActivity?: DateTimeWithAggregatesFilter<"AdminSession"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminSession"> | Date | string
  }

  export type AdminAuditLogWhereInput = {
    AND?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    OR?: AdminAuditLogWhereInput[]
    NOT?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    id?: StringFilter<"AdminAuditLog"> | string
    adminId?: StringFilter<"AdminAuditLog"> | string
    action?: StringFilter<"AdminAuditLog"> | string
    metadata?: JsonFilter<"AdminAuditLog">
    timestamp?: DateTimeFilter<"AdminAuditLog"> | Date | string
    ipAddress?: StringFilter<"AdminAuditLog"> | string
    admin?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AdminAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
    admin?: UserOrderByWithRelationInput
  }

  export type AdminAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    OR?: AdminAuditLogWhereInput[]
    NOT?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    adminId?: StringFilter<"AdminAuditLog"> | string
    action?: StringFilter<"AdminAuditLog"> | string
    metadata?: JsonFilter<"AdminAuditLog">
    timestamp?: DateTimeFilter<"AdminAuditLog"> | Date | string
    ipAddress?: StringFilter<"AdminAuditLog"> | string
    admin?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AdminAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
    _count?: AdminAuditLogCountOrderByAggregateInput
    _max?: AdminAuditLogMaxOrderByAggregateInput
    _min?: AdminAuditLogMinOrderByAggregateInput
  }

  export type AdminAuditLogScalarWhereWithAggregatesInput = {
    AND?: AdminAuditLogScalarWhereWithAggregatesInput | AdminAuditLogScalarWhereWithAggregatesInput[]
    OR?: AdminAuditLogScalarWhereWithAggregatesInput[]
    NOT?: AdminAuditLogScalarWhereWithAggregatesInput | AdminAuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    adminId?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    action?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    metadata?: JsonWithAggregatesFilter<"AdminAuditLog">
    timestamp?: DateTimeWithAggregatesFilter<"AdminAuditLog"> | Date | string
    ipAddress?: StringWithAggregatesFilter<"AdminAuditLog"> | string
  }

  export type FraudAlertWhereInput = {
    AND?: FraudAlertWhereInput | FraudAlertWhereInput[]
    OR?: FraudAlertWhereInput[]
    NOT?: FraudAlertWhereInput | FraudAlertWhereInput[]
    id?: StringFilter<"FraudAlert"> | string
    type?: StringFilter<"FraudAlert"> | string
    severity?: StringFilter<"FraudAlert"> | string
    userId?: StringFilter<"FraudAlert"> | string
    description?: StringFilter<"FraudAlert"> | string
    evidence?: JsonFilter<"FraudAlert">
    riskScore?: IntFilter<"FraudAlert"> | number
    status?: StringFilter<"FraudAlert"> | string
    createdAt?: DateTimeFilter<"FraudAlert"> | Date | string
    investigatedBy?: StringNullableFilter<"FraudAlert"> | string | null
    resolvedAt?: DateTimeNullableFilter<"FraudAlert"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FraudAlertOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    evidence?: SortOrder
    riskScore?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    investigatedBy?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type FraudAlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FraudAlertWhereInput | FraudAlertWhereInput[]
    OR?: FraudAlertWhereInput[]
    NOT?: FraudAlertWhereInput | FraudAlertWhereInput[]
    type?: StringFilter<"FraudAlert"> | string
    severity?: StringFilter<"FraudAlert"> | string
    userId?: StringFilter<"FraudAlert"> | string
    description?: StringFilter<"FraudAlert"> | string
    evidence?: JsonFilter<"FraudAlert">
    riskScore?: IntFilter<"FraudAlert"> | number
    status?: StringFilter<"FraudAlert"> | string
    createdAt?: DateTimeFilter<"FraudAlert"> | Date | string
    investigatedBy?: StringNullableFilter<"FraudAlert"> | string | null
    resolvedAt?: DateTimeNullableFilter<"FraudAlert"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type FraudAlertOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    evidence?: SortOrder
    riskScore?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    investigatedBy?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    _count?: FraudAlertCountOrderByAggregateInput
    _avg?: FraudAlertAvgOrderByAggregateInput
    _max?: FraudAlertMaxOrderByAggregateInput
    _min?: FraudAlertMinOrderByAggregateInput
    _sum?: FraudAlertSumOrderByAggregateInput
  }

  export type FraudAlertScalarWhereWithAggregatesInput = {
    AND?: FraudAlertScalarWhereWithAggregatesInput | FraudAlertScalarWhereWithAggregatesInput[]
    OR?: FraudAlertScalarWhereWithAggregatesInput[]
    NOT?: FraudAlertScalarWhereWithAggregatesInput | FraudAlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FraudAlert"> | string
    type?: StringWithAggregatesFilter<"FraudAlert"> | string
    severity?: StringWithAggregatesFilter<"FraudAlert"> | string
    userId?: StringWithAggregatesFilter<"FraudAlert"> | string
    description?: StringWithAggregatesFilter<"FraudAlert"> | string
    evidence?: JsonWithAggregatesFilter<"FraudAlert">
    riskScore?: IntWithAggregatesFilter<"FraudAlert"> | number
    status?: StringWithAggregatesFilter<"FraudAlert"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FraudAlert"> | Date | string
    investigatedBy?: StringNullableWithAggregatesFilter<"FraudAlert"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"FraudAlert"> | Date | string | null
  }

  export type CampaignConfigWhereInput = {
    AND?: CampaignConfigWhereInput | CampaignConfigWhereInput[]
    OR?: CampaignConfigWhereInput[]
    NOT?: CampaignConfigWhereInput | CampaignConfigWhereInput[]
    id?: StringFilter<"CampaignConfig"> | string
    name?: StringFilter<"CampaignConfig"> | string
    description?: StringNullableFilter<"CampaignConfig"> | string | null
    tokenMint?: StringFilter<"CampaignConfig"> | string
    totalAllocation?: BigIntFilter<"CampaignConfig"> | bigint | number
    startDate?: DateTimeFilter<"CampaignConfig"> | Date | string
    endDate?: DateTimeFilter<"CampaignConfig"> | Date | string
    eligibilityCriteria?: JsonFilter<"CampaignConfig">
    distributionRules?: JsonFilter<"CampaignConfig">
    isActive?: BoolFilter<"CampaignConfig"> | boolean
    createdBy?: StringFilter<"CampaignConfig"> | string
    createdAt?: DateTimeFilter<"CampaignConfig"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignConfig"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CampaignConfigOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    tokenMint?: SortOrder
    totalAllocation?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    eligibilityCriteria?: SortOrder
    distributionRules?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
  }

  export type CampaignConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CampaignConfigWhereInput | CampaignConfigWhereInput[]
    OR?: CampaignConfigWhereInput[]
    NOT?: CampaignConfigWhereInput | CampaignConfigWhereInput[]
    name?: StringFilter<"CampaignConfig"> | string
    description?: StringNullableFilter<"CampaignConfig"> | string | null
    tokenMint?: StringFilter<"CampaignConfig"> | string
    totalAllocation?: BigIntFilter<"CampaignConfig"> | bigint | number
    startDate?: DateTimeFilter<"CampaignConfig"> | Date | string
    endDate?: DateTimeFilter<"CampaignConfig"> | Date | string
    eligibilityCriteria?: JsonFilter<"CampaignConfig">
    distributionRules?: JsonFilter<"CampaignConfig">
    isActive?: BoolFilter<"CampaignConfig"> | boolean
    createdBy?: StringFilter<"CampaignConfig"> | string
    createdAt?: DateTimeFilter<"CampaignConfig"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignConfig"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CampaignConfigOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    tokenMint?: SortOrder
    totalAllocation?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    eligibilityCriteria?: SortOrder
    distributionRules?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CampaignConfigCountOrderByAggregateInput
    _avg?: CampaignConfigAvgOrderByAggregateInput
    _max?: CampaignConfigMaxOrderByAggregateInput
    _min?: CampaignConfigMinOrderByAggregateInput
    _sum?: CampaignConfigSumOrderByAggregateInput
  }

  export type CampaignConfigScalarWhereWithAggregatesInput = {
    AND?: CampaignConfigScalarWhereWithAggregatesInput | CampaignConfigScalarWhereWithAggregatesInput[]
    OR?: CampaignConfigScalarWhereWithAggregatesInput[]
    NOT?: CampaignConfigScalarWhereWithAggregatesInput | CampaignConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CampaignConfig"> | string
    name?: StringWithAggregatesFilter<"CampaignConfig"> | string
    description?: StringNullableWithAggregatesFilter<"CampaignConfig"> | string | null
    tokenMint?: StringWithAggregatesFilter<"CampaignConfig"> | string
    totalAllocation?: BigIntWithAggregatesFilter<"CampaignConfig"> | bigint | number
    startDate?: DateTimeWithAggregatesFilter<"CampaignConfig"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"CampaignConfig"> | Date | string
    eligibilityCriteria?: JsonWithAggregatesFilter<"CampaignConfig">
    distributionRules?: JsonWithAggregatesFilter<"CampaignConfig">
    isActive?: BoolWithAggregatesFilter<"CampaignConfig"> | boolean
    createdBy?: StringWithAggregatesFilter<"CampaignConfig"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CampaignConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CampaignConfig"> | Date | string
  }

  export type TaskCompletionWhereInput = {
    AND?: TaskCompletionWhereInput | TaskCompletionWhereInput[]
    OR?: TaskCompletionWhereInput[]
    NOT?: TaskCompletionWhereInput | TaskCompletionWhereInput[]
    id?: StringFilter<"TaskCompletion"> | string
    userId?: StringFilter<"TaskCompletion"> | string
    taskId?: StringFilter<"TaskCompletion"> | string
    completed?: BoolFilter<"TaskCompletion"> | boolean
    points?: IntFilter<"TaskCompletion"> | number
    metadata?: JsonNullableFilter<"TaskCompletion">
    completedAt?: DateTimeNullableFilter<"TaskCompletion"> | Date | string | null
    createdAt?: DateTimeFilter<"TaskCompletion"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }

  export type TaskCompletionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    completed?: SortOrder
    points?: SortOrder
    metadata?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    task?: TaskOrderByWithRelationInput
  }

  export type TaskCompletionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_taskId?: TaskCompletionUserIdTaskIdCompoundUniqueInput
    AND?: TaskCompletionWhereInput | TaskCompletionWhereInput[]
    OR?: TaskCompletionWhereInput[]
    NOT?: TaskCompletionWhereInput | TaskCompletionWhereInput[]
    userId?: StringFilter<"TaskCompletion"> | string
    taskId?: StringFilter<"TaskCompletion"> | string
    completed?: BoolFilter<"TaskCompletion"> | boolean
    points?: IntFilter<"TaskCompletion"> | number
    metadata?: JsonNullableFilter<"TaskCompletion">
    completedAt?: DateTimeNullableFilter<"TaskCompletion"> | Date | string | null
    createdAt?: DateTimeFilter<"TaskCompletion"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }, "id" | "userId_taskId">

  export type TaskCompletionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    completed?: SortOrder
    points?: SortOrder
    metadata?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TaskCompletionCountOrderByAggregateInput
    _avg?: TaskCompletionAvgOrderByAggregateInput
    _max?: TaskCompletionMaxOrderByAggregateInput
    _min?: TaskCompletionMinOrderByAggregateInput
    _sum?: TaskCompletionSumOrderByAggregateInput
  }

  export type TaskCompletionScalarWhereWithAggregatesInput = {
    AND?: TaskCompletionScalarWhereWithAggregatesInput | TaskCompletionScalarWhereWithAggregatesInput[]
    OR?: TaskCompletionScalarWhereWithAggregatesInput[]
    NOT?: TaskCompletionScalarWhereWithAggregatesInput | TaskCompletionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaskCompletion"> | string
    userId?: StringWithAggregatesFilter<"TaskCompletion"> | string
    taskId?: StringWithAggregatesFilter<"TaskCompletion"> | string
    completed?: BoolWithAggregatesFilter<"TaskCompletion"> | boolean
    points?: IntWithAggregatesFilter<"TaskCompletion"> | number
    metadata?: JsonNullableWithAggregatesFilter<"TaskCompletion">
    completedAt?: DateTimeNullableWithAggregatesFilter<"TaskCompletion"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TaskCompletion"> | Date | string
  }

  export type ClaimWhereInput = {
    AND?: ClaimWhereInput | ClaimWhereInput[]
    OR?: ClaimWhereInput[]
    NOT?: ClaimWhereInput | ClaimWhereInput[]
    id?: StringFilter<"Claim"> | string
    userId?: StringFilter<"Claim"> | string
    amount?: FloatFilter<"Claim"> | number
    transactionHash?: StringNullableFilter<"Claim"> | string | null
    status?: EnumClaimStatusFilter<"Claim"> | $Enums.ClaimStatus
    paymentMethod?: EnumPaymentMethodFilter<"Claim"> | $Enums.PaymentMethod
    metadata?: JsonNullableFilter<"Claim">
    processedAt?: DateTimeNullableFilter<"Claim"> | Date | string | null
    feesPaid?: DecimalFilter<"Claim"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Claim"> | Date | string
    updatedAt?: DateTimeFilter<"Claim"> | Date | string
    type?: StringNullableFilter<"Claim"> | string | null
    nftPasses?: JsonNullableFilter<"Claim">
    userTier?: StringNullableFilter<"Claim"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ClaimOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    transactionHash?: SortOrderInput | SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    metadata?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    feesPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrderInput | SortOrder
    nftPasses?: SortOrderInput | SortOrder
    userTier?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ClaimWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClaimWhereInput | ClaimWhereInput[]
    OR?: ClaimWhereInput[]
    NOT?: ClaimWhereInput | ClaimWhereInput[]
    userId?: StringFilter<"Claim"> | string
    amount?: FloatFilter<"Claim"> | number
    transactionHash?: StringNullableFilter<"Claim"> | string | null
    status?: EnumClaimStatusFilter<"Claim"> | $Enums.ClaimStatus
    paymentMethod?: EnumPaymentMethodFilter<"Claim"> | $Enums.PaymentMethod
    metadata?: JsonNullableFilter<"Claim">
    processedAt?: DateTimeNullableFilter<"Claim"> | Date | string | null
    feesPaid?: DecimalFilter<"Claim"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Claim"> | Date | string
    updatedAt?: DateTimeFilter<"Claim"> | Date | string
    type?: StringNullableFilter<"Claim"> | string | null
    nftPasses?: JsonNullableFilter<"Claim">
    userTier?: StringNullableFilter<"Claim"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ClaimOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    transactionHash?: SortOrderInput | SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    metadata?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    feesPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrderInput | SortOrder
    nftPasses?: SortOrderInput | SortOrder
    userTier?: SortOrderInput | SortOrder
    _count?: ClaimCountOrderByAggregateInput
    _avg?: ClaimAvgOrderByAggregateInput
    _max?: ClaimMaxOrderByAggregateInput
    _min?: ClaimMinOrderByAggregateInput
    _sum?: ClaimSumOrderByAggregateInput
  }

  export type ClaimScalarWhereWithAggregatesInput = {
    AND?: ClaimScalarWhereWithAggregatesInput | ClaimScalarWhereWithAggregatesInput[]
    OR?: ClaimScalarWhereWithAggregatesInput[]
    NOT?: ClaimScalarWhereWithAggregatesInput | ClaimScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Claim"> | string
    userId?: StringWithAggregatesFilter<"Claim"> | string
    amount?: FloatWithAggregatesFilter<"Claim"> | number
    transactionHash?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    status?: EnumClaimStatusWithAggregatesFilter<"Claim"> | $Enums.ClaimStatus
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Claim"> | $Enums.PaymentMethod
    metadata?: JsonNullableWithAggregatesFilter<"Claim">
    processedAt?: DateTimeNullableWithAggregatesFilter<"Claim"> | Date | string | null
    feesPaid?: DecimalWithAggregatesFilter<"Claim"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Claim"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Claim"> | Date | string
    type?: StringNullableWithAggregatesFilter<"Claim"> | string | null
    nftPasses?: JsonNullableWithAggregatesFilter<"Claim">
    userTier?: StringNullableWithAggregatesFilter<"Claim"> | string | null
  }

  export type PointHistoryWhereInput = {
    AND?: PointHistoryWhereInput | PointHistoryWhereInput[]
    OR?: PointHistoryWhereInput[]
    NOT?: PointHistoryWhereInput | PointHistoryWhereInput[]
    id?: StringFilter<"PointHistory"> | string
    userId?: StringFilter<"PointHistory"> | string
    points?: IntFilter<"PointHistory"> | number
    action?: StringFilter<"PointHistory"> | string
    description?: StringNullableFilter<"PointHistory"> | string | null
    metadata?: JsonNullableFilter<"PointHistory">
    createdAt?: DateTimeFilter<"PointHistory"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PointHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    action?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PointHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PointHistoryWhereInput | PointHistoryWhereInput[]
    OR?: PointHistoryWhereInput[]
    NOT?: PointHistoryWhereInput | PointHistoryWhereInput[]
    userId?: StringFilter<"PointHistory"> | string
    points?: IntFilter<"PointHistory"> | number
    action?: StringFilter<"PointHistory"> | string
    description?: StringNullableFilter<"PointHistory"> | string | null
    metadata?: JsonNullableFilter<"PointHistory">
    createdAt?: DateTimeFilter<"PointHistory"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PointHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    action?: SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PointHistoryCountOrderByAggregateInput
    _avg?: PointHistoryAvgOrderByAggregateInput
    _max?: PointHistoryMaxOrderByAggregateInput
    _min?: PointHistoryMinOrderByAggregateInput
    _sum?: PointHistorySumOrderByAggregateInput
  }

  export type PointHistoryScalarWhereWithAggregatesInput = {
    AND?: PointHistoryScalarWhereWithAggregatesInput | PointHistoryScalarWhereWithAggregatesInput[]
    OR?: PointHistoryScalarWhereWithAggregatesInput[]
    NOT?: PointHistoryScalarWhereWithAggregatesInput | PointHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PointHistory"> | string
    userId?: StringWithAggregatesFilter<"PointHistory"> | string
    points?: IntWithAggregatesFilter<"PointHistory"> | number
    action?: StringWithAggregatesFilter<"PointHistory"> | string
    description?: StringNullableWithAggregatesFilter<"PointHistory"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"PointHistory">
    createdAt?: DateTimeWithAggregatesFilter<"PointHistory"> | Date | string
  }

  export type ReferralWhereInput = {
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    id?: StringFilter<"Referral"> | string
    referrerId?: StringFilter<"Referral"> | string
    referredId?: StringFilter<"Referral"> | string
    points?: IntFilter<"Referral"> | number
    completed?: BoolFilter<"Referral"> | boolean
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    isActive?: BoolFilter<"Referral"> | boolean
    referrer?: XOR<UserScalarRelationFilter, UserWhereInput>
    referred?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReferralOrderByWithRelationInput = {
    id?: SortOrder
    referrerId?: SortOrder
    referredId?: SortOrder
    points?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
    referrer?: UserOrderByWithRelationInput
    referred?: UserOrderByWithRelationInput
  }

  export type ReferralWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    referredId?: string
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    referrerId?: StringFilter<"Referral"> | string
    points?: IntFilter<"Referral"> | number
    completed?: BoolFilter<"Referral"> | boolean
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    isActive?: BoolFilter<"Referral"> | boolean
    referrer?: XOR<UserScalarRelationFilter, UserWhereInput>
    referred?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "referredId">

  export type ReferralOrderByWithAggregationInput = {
    id?: SortOrder
    referrerId?: SortOrder
    referredId?: SortOrder
    points?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
    _count?: ReferralCountOrderByAggregateInput
    _avg?: ReferralAvgOrderByAggregateInput
    _max?: ReferralMaxOrderByAggregateInput
    _min?: ReferralMinOrderByAggregateInput
    _sum?: ReferralSumOrderByAggregateInput
  }

  export type ReferralScalarWhereWithAggregatesInput = {
    AND?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    OR?: ReferralScalarWhereWithAggregatesInput[]
    NOT?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Referral"> | string
    referrerId?: StringWithAggregatesFilter<"Referral"> | string
    referredId?: StringWithAggregatesFilter<"Referral"> | string
    points?: IntWithAggregatesFilter<"Referral"> | number
    completed?: BoolWithAggregatesFilter<"Referral"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Referral"> | Date | string
    isActive?: BoolWithAggregatesFilter<"Referral"> | boolean
  }

  export type SystemConfigWhereInput = {
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    id?: StringFilter<"SystemConfig"> | string
    key?: StringFilter<"SystemConfig"> | string
    value?: JsonFilter<"SystemConfig">
    description?: StringNullableFilter<"SystemConfig"> | string | null
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }

  export type SystemConfigOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    value?: JsonFilter<"SystemConfig">
    description?: StringNullableFilter<"SystemConfig"> | string | null
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }, "id" | "key">

  export type SystemConfigOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: SystemConfigCountOrderByAggregateInput
    _max?: SystemConfigMaxOrderByAggregateInput
    _min?: SystemConfigMinOrderByAggregateInput
  }

  export type SystemConfigScalarWhereWithAggregatesInput = {
    AND?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    OR?: SystemConfigScalarWhereWithAggregatesInput[]
    NOT?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemConfig"> | string
    key?: StringWithAggregatesFilter<"SystemConfig"> | string
    value?: JsonWithAggregatesFilter<"SystemConfig">
    description?: StringNullableWithAggregatesFilter<"SystemConfig"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
  }

  export type AnalyticsWhereInput = {
    AND?: AnalyticsWhereInput | AnalyticsWhereInput[]
    OR?: AnalyticsWhereInput[]
    NOT?: AnalyticsWhereInput | AnalyticsWhereInput[]
    id?: StringFilter<"Analytics"> | string
    date?: DateTimeFilter<"Analytics"> | Date | string
    totalUsers?: IntFilter<"Analytics"> | number
    activeUsers?: IntFilter<"Analytics"> | number
    totalClaims?: IntFilter<"Analytics"> | number
    totalPoints?: IntFilter<"Analytics"> | number
    totalEngagements?: IntFilter<"Analytics"> | number
    metadata?: JsonNullableFilter<"Analytics">
    createdAt?: DateTimeFilter<"Analytics"> | Date | string
  }

  export type AnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    totalUsers?: SortOrder
    activeUsers?: SortOrder
    totalClaims?: SortOrder
    totalPoints?: SortOrder
    totalEngagements?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalyticsWhereInput | AnalyticsWhereInput[]
    OR?: AnalyticsWhereInput[]
    NOT?: AnalyticsWhereInput | AnalyticsWhereInput[]
    date?: DateTimeFilter<"Analytics"> | Date | string
    totalUsers?: IntFilter<"Analytics"> | number
    activeUsers?: IntFilter<"Analytics"> | number
    totalClaims?: IntFilter<"Analytics"> | number
    totalPoints?: IntFilter<"Analytics"> | number
    totalEngagements?: IntFilter<"Analytics"> | number
    metadata?: JsonNullableFilter<"Analytics">
    createdAt?: DateTimeFilter<"Analytics"> | Date | string
  }, "id">

  export type AnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    totalUsers?: SortOrder
    activeUsers?: SortOrder
    totalClaims?: SortOrder
    totalPoints?: SortOrder
    totalEngagements?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AnalyticsCountOrderByAggregateInput
    _avg?: AnalyticsAvgOrderByAggregateInput
    _max?: AnalyticsMaxOrderByAggregateInput
    _min?: AnalyticsMinOrderByAggregateInput
    _sum?: AnalyticsSumOrderByAggregateInput
  }

  export type AnalyticsScalarWhereWithAggregatesInput = {
    AND?: AnalyticsScalarWhereWithAggregatesInput | AnalyticsScalarWhereWithAggregatesInput[]
    OR?: AnalyticsScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsScalarWhereWithAggregatesInput | AnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Analytics"> | string
    date?: DateTimeWithAggregatesFilter<"Analytics"> | Date | string
    totalUsers?: IntWithAggregatesFilter<"Analytics"> | number
    activeUsers?: IntWithAggregatesFilter<"Analytics"> | number
    totalClaims?: IntWithAggregatesFilter<"Analytics"> | number
    totalPoints?: IntWithAggregatesFilter<"Analytics"> | number
    totalEngagements?: IntWithAggregatesFilter<"Analytics"> | number
    metadata?: JsonNullableWithAggregatesFilter<"Analytics">
    createdAt?: DateTimeWithAggregatesFilter<"Analytics"> | Date | string
  }

  export type DailyEarningWhereInput = {
    AND?: DailyEarningWhereInput | DailyEarningWhereInput[]
    OR?: DailyEarningWhereInput[]
    NOT?: DailyEarningWhereInput | DailyEarningWhereInput[]
    id?: StringFilter<"DailyEarning"> | string
    userId?: StringFilter<"DailyEarning"> | string
    tokens?: FloatFilter<"DailyEarning"> | number
    type?: StringFilter<"DailyEarning"> | string
    claimedAt?: DateTimeFilter<"DailyEarning"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DailyEarningOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokens?: SortOrder
    type?: SortOrder
    claimedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DailyEarningWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DailyEarningWhereInput | DailyEarningWhereInput[]
    OR?: DailyEarningWhereInput[]
    NOT?: DailyEarningWhereInput | DailyEarningWhereInput[]
    userId?: StringFilter<"DailyEarning"> | string
    tokens?: FloatFilter<"DailyEarning"> | number
    type?: StringFilter<"DailyEarning"> | string
    claimedAt?: DateTimeFilter<"DailyEarning"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type DailyEarningOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokens?: SortOrder
    type?: SortOrder
    claimedAt?: SortOrder
    _count?: DailyEarningCountOrderByAggregateInput
    _avg?: DailyEarningAvgOrderByAggregateInput
    _max?: DailyEarningMaxOrderByAggregateInput
    _min?: DailyEarningMinOrderByAggregateInput
    _sum?: DailyEarningSumOrderByAggregateInput
  }

  export type DailyEarningScalarWhereWithAggregatesInput = {
    AND?: DailyEarningScalarWhereWithAggregatesInput | DailyEarningScalarWhereWithAggregatesInput[]
    OR?: DailyEarningScalarWhereWithAggregatesInput[]
    NOT?: DailyEarningScalarWhereWithAggregatesInput | DailyEarningScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DailyEarning"> | string
    userId?: StringWithAggregatesFilter<"DailyEarning"> | string
    tokens?: FloatWithAggregatesFilter<"DailyEarning"> | number
    type?: StringWithAggregatesFilter<"DailyEarning"> | string
    claimedAt?: DateTimeWithAggregatesFilter<"DailyEarning"> | Date | string
  }

  export type AirdropSeasonWhereInput = {
    AND?: AirdropSeasonWhereInput | AirdropSeasonWhereInput[]
    OR?: AirdropSeasonWhereInput[]
    NOT?: AirdropSeasonWhereInput | AirdropSeasonWhereInput[]
    id?: StringFilter<"AirdropSeason"> | string
    name?: StringFilter<"AirdropSeason"> | string
    description?: StringNullableFilter<"AirdropSeason"> | string | null
    status?: StringFilter<"AirdropSeason"> | string
    totalAllocation?: BigIntFilter<"AirdropSeason"> | bigint | number
    claimedAmount?: BigIntFilter<"AirdropSeason"> | bigint | number
    startDate?: DateTimeFilter<"AirdropSeason"> | Date | string
    endDate?: DateTimeNullableFilter<"AirdropSeason"> | Date | string | null
    nftPassRequired?: BoolFilter<"AirdropSeason"> | boolean
    requireApproval?: BoolFilter<"AirdropSeason"> | boolean
    feeAmount?: DecimalFilter<"AirdropSeason"> | Decimal | DecimalJsLike | number | string
    createdBy?: StringFilter<"AirdropSeason"> | string
    metadata?: JsonNullableFilter<"AirdropSeason">
    createdAt?: DateTimeFilter<"AirdropSeason"> | Date | string
    updatedAt?: DateTimeFilter<"AirdropSeason"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    claims?: AirdropClaimListRelationFilter
  }

  export type AirdropSeasonOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    totalAllocation?: SortOrder
    claimedAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    nftPassRequired?: SortOrder
    requireApproval?: SortOrder
    feeAmount?: SortOrder
    createdBy?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    claims?: AirdropClaimOrderByRelationAggregateInput
  }

  export type AirdropSeasonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AirdropSeasonWhereInput | AirdropSeasonWhereInput[]
    OR?: AirdropSeasonWhereInput[]
    NOT?: AirdropSeasonWhereInput | AirdropSeasonWhereInput[]
    name?: StringFilter<"AirdropSeason"> | string
    description?: StringNullableFilter<"AirdropSeason"> | string | null
    status?: StringFilter<"AirdropSeason"> | string
    totalAllocation?: BigIntFilter<"AirdropSeason"> | bigint | number
    claimedAmount?: BigIntFilter<"AirdropSeason"> | bigint | number
    startDate?: DateTimeFilter<"AirdropSeason"> | Date | string
    endDate?: DateTimeNullableFilter<"AirdropSeason"> | Date | string | null
    nftPassRequired?: BoolFilter<"AirdropSeason"> | boolean
    requireApproval?: BoolFilter<"AirdropSeason"> | boolean
    feeAmount?: DecimalFilter<"AirdropSeason"> | Decimal | DecimalJsLike | number | string
    createdBy?: StringFilter<"AirdropSeason"> | string
    metadata?: JsonNullableFilter<"AirdropSeason">
    createdAt?: DateTimeFilter<"AirdropSeason"> | Date | string
    updatedAt?: DateTimeFilter<"AirdropSeason"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    claims?: AirdropClaimListRelationFilter
  }, "id">

  export type AirdropSeasonOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    totalAllocation?: SortOrder
    claimedAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    nftPassRequired?: SortOrder
    requireApproval?: SortOrder
    feeAmount?: SortOrder
    createdBy?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AirdropSeasonCountOrderByAggregateInput
    _avg?: AirdropSeasonAvgOrderByAggregateInput
    _max?: AirdropSeasonMaxOrderByAggregateInput
    _min?: AirdropSeasonMinOrderByAggregateInput
    _sum?: AirdropSeasonSumOrderByAggregateInput
  }

  export type AirdropSeasonScalarWhereWithAggregatesInput = {
    AND?: AirdropSeasonScalarWhereWithAggregatesInput | AirdropSeasonScalarWhereWithAggregatesInput[]
    OR?: AirdropSeasonScalarWhereWithAggregatesInput[]
    NOT?: AirdropSeasonScalarWhereWithAggregatesInput | AirdropSeasonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AirdropSeason"> | string
    name?: StringWithAggregatesFilter<"AirdropSeason"> | string
    description?: StringNullableWithAggregatesFilter<"AirdropSeason"> | string | null
    status?: StringWithAggregatesFilter<"AirdropSeason"> | string
    totalAllocation?: BigIntWithAggregatesFilter<"AirdropSeason"> | bigint | number
    claimedAmount?: BigIntWithAggregatesFilter<"AirdropSeason"> | bigint | number
    startDate?: DateTimeWithAggregatesFilter<"AirdropSeason"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"AirdropSeason"> | Date | string | null
    nftPassRequired?: BoolWithAggregatesFilter<"AirdropSeason"> | boolean
    requireApproval?: BoolWithAggregatesFilter<"AirdropSeason"> | boolean
    feeAmount?: DecimalWithAggregatesFilter<"AirdropSeason"> | Decimal | DecimalJsLike | number | string
    createdBy?: StringWithAggregatesFilter<"AirdropSeason"> | string
    metadata?: JsonNullableWithAggregatesFilter<"AirdropSeason">
    createdAt?: DateTimeWithAggregatesFilter<"AirdropSeason"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AirdropSeason"> | Date | string
  }

  export type AirdropClaimWhereInput = {
    AND?: AirdropClaimWhereInput | AirdropClaimWhereInput[]
    OR?: AirdropClaimWhereInput[]
    NOT?: AirdropClaimWhereInput | AirdropClaimWhereInput[]
    id?: StringFilter<"AirdropClaim"> | string
    userId?: StringFilter<"AirdropClaim"> | string
    seasonId?: StringFilter<"AirdropClaim"> | string
    tokens?: FloatFilter<"AirdropClaim"> | number
    tier?: StringFilter<"AirdropClaim"> | string
    paymentSignature?: StringFilter<"AirdropClaim"> | string
    transactionSignature?: StringNullableFilter<"AirdropClaim"> | string | null
    status?: StringFilter<"AirdropClaim"> | string
    claimedAt?: DateTimeFilter<"AirdropClaim"> | Date | string
    createdAt?: DateTimeFilter<"AirdropClaim"> | Date | string
    updatedAt?: DateTimeFilter<"AirdropClaim"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    season?: XOR<AirdropSeasonScalarRelationFilter, AirdropSeasonWhereInput>
  }

  export type AirdropClaimOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    seasonId?: SortOrder
    tokens?: SortOrder
    tier?: SortOrder
    paymentSignature?: SortOrder
    transactionSignature?: SortOrderInput | SortOrder
    status?: SortOrder
    claimedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    season?: AirdropSeasonOrderByWithRelationInput
  }

  export type AirdropClaimWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_seasonId?: AirdropClaimUserIdSeasonIdCompoundUniqueInput
    AND?: AirdropClaimWhereInput | AirdropClaimWhereInput[]
    OR?: AirdropClaimWhereInput[]
    NOT?: AirdropClaimWhereInput | AirdropClaimWhereInput[]
    userId?: StringFilter<"AirdropClaim"> | string
    seasonId?: StringFilter<"AirdropClaim"> | string
    tokens?: FloatFilter<"AirdropClaim"> | number
    tier?: StringFilter<"AirdropClaim"> | string
    paymentSignature?: StringFilter<"AirdropClaim"> | string
    transactionSignature?: StringNullableFilter<"AirdropClaim"> | string | null
    status?: StringFilter<"AirdropClaim"> | string
    claimedAt?: DateTimeFilter<"AirdropClaim"> | Date | string
    createdAt?: DateTimeFilter<"AirdropClaim"> | Date | string
    updatedAt?: DateTimeFilter<"AirdropClaim"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    season?: XOR<AirdropSeasonScalarRelationFilter, AirdropSeasonWhereInput>
  }, "id" | "userId_seasonId">

  export type AirdropClaimOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    seasonId?: SortOrder
    tokens?: SortOrder
    tier?: SortOrder
    paymentSignature?: SortOrder
    transactionSignature?: SortOrderInput | SortOrder
    status?: SortOrder
    claimedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AirdropClaimCountOrderByAggregateInput
    _avg?: AirdropClaimAvgOrderByAggregateInput
    _max?: AirdropClaimMaxOrderByAggregateInput
    _min?: AirdropClaimMinOrderByAggregateInput
    _sum?: AirdropClaimSumOrderByAggregateInput
  }

  export type AirdropClaimScalarWhereWithAggregatesInput = {
    AND?: AirdropClaimScalarWhereWithAggregatesInput | AirdropClaimScalarWhereWithAggregatesInput[]
    OR?: AirdropClaimScalarWhereWithAggregatesInput[]
    NOT?: AirdropClaimScalarWhereWithAggregatesInput | AirdropClaimScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AirdropClaim"> | string
    userId?: StringWithAggregatesFilter<"AirdropClaim"> | string
    seasonId?: StringWithAggregatesFilter<"AirdropClaim"> | string
    tokens?: FloatWithAggregatesFilter<"AirdropClaim"> | number
    tier?: StringWithAggregatesFilter<"AirdropClaim"> | string
    paymentSignature?: StringWithAggregatesFilter<"AirdropClaim"> | string
    transactionSignature?: StringNullableWithAggregatesFilter<"AirdropClaim"> | string | null
    status?: StringWithAggregatesFilter<"AirdropClaim"> | string
    claimedAt?: DateTimeWithAggregatesFilter<"AirdropClaim"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AirdropClaim"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AirdropClaim"> | Date | string
  }

  export type NftCollectionWhereInput = {
    AND?: NftCollectionWhereInput | NftCollectionWhereInput[]
    OR?: NftCollectionWhereInput[]
    NOT?: NftCollectionWhereInput | NftCollectionWhereInput[]
    id?: StringFilter<"NftCollection"> | string
    mintAddress?: StringFilter<"NftCollection"> | string
    name?: StringFilter<"NftCollection"> | string
    symbol?: StringFilter<"NftCollection"> | string
    description?: StringNullableFilter<"NftCollection"> | string | null
    uri?: StringFilter<"NftCollection"> | string
    supply?: IntFilter<"NftCollection"> | number
    createdBy?: StringFilter<"NftCollection"> | string
    metadata?: JsonNullableFilter<"NftCollection">
    createdAt?: DateTimeFilter<"NftCollection"> | Date | string
    updatedAt?: DateTimeFilter<"NftCollection"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    distributions?: NftDistributionListRelationFilter
  }

  export type NftCollectionOrderByWithRelationInput = {
    id?: SortOrder
    mintAddress?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrderInput | SortOrder
    uri?: SortOrder
    supply?: SortOrder
    createdBy?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    distributions?: NftDistributionOrderByRelationAggregateInput
  }

  export type NftCollectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    mintAddress?: string
    AND?: NftCollectionWhereInput | NftCollectionWhereInput[]
    OR?: NftCollectionWhereInput[]
    NOT?: NftCollectionWhereInput | NftCollectionWhereInput[]
    name?: StringFilter<"NftCollection"> | string
    symbol?: StringFilter<"NftCollection"> | string
    description?: StringNullableFilter<"NftCollection"> | string | null
    uri?: StringFilter<"NftCollection"> | string
    supply?: IntFilter<"NftCollection"> | number
    createdBy?: StringFilter<"NftCollection"> | string
    metadata?: JsonNullableFilter<"NftCollection">
    createdAt?: DateTimeFilter<"NftCollection"> | Date | string
    updatedAt?: DateTimeFilter<"NftCollection"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    distributions?: NftDistributionListRelationFilter
  }, "id" | "mintAddress">

  export type NftCollectionOrderByWithAggregationInput = {
    id?: SortOrder
    mintAddress?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrderInput | SortOrder
    uri?: SortOrder
    supply?: SortOrder
    createdBy?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NftCollectionCountOrderByAggregateInput
    _avg?: NftCollectionAvgOrderByAggregateInput
    _max?: NftCollectionMaxOrderByAggregateInput
    _min?: NftCollectionMinOrderByAggregateInput
    _sum?: NftCollectionSumOrderByAggregateInput
  }

  export type NftCollectionScalarWhereWithAggregatesInput = {
    AND?: NftCollectionScalarWhereWithAggregatesInput | NftCollectionScalarWhereWithAggregatesInput[]
    OR?: NftCollectionScalarWhereWithAggregatesInput[]
    NOT?: NftCollectionScalarWhereWithAggregatesInput | NftCollectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NftCollection"> | string
    mintAddress?: StringWithAggregatesFilter<"NftCollection"> | string
    name?: StringWithAggregatesFilter<"NftCollection"> | string
    symbol?: StringWithAggregatesFilter<"NftCollection"> | string
    description?: StringNullableWithAggregatesFilter<"NftCollection"> | string | null
    uri?: StringWithAggregatesFilter<"NftCollection"> | string
    supply?: IntWithAggregatesFilter<"NftCollection"> | number
    createdBy?: StringWithAggregatesFilter<"NftCollection"> | string
    metadata?: JsonNullableWithAggregatesFilter<"NftCollection">
    createdAt?: DateTimeWithAggregatesFilter<"NftCollection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NftCollection"> | Date | string
  }

  export type NftDistributionWhereInput = {
    AND?: NftDistributionWhereInput | NftDistributionWhereInput[]
    OR?: NftDistributionWhereInput[]
    NOT?: NftDistributionWhereInput | NftDistributionWhereInput[]
    id?: StringFilter<"NftDistribution"> | string
    mintAddress?: StringFilter<"NftDistribution"> | string
    distributedBy?: StringFilter<"NftDistribution"> | string
    recipientCount?: IntFilter<"NftDistribution"> | number
    nftsPerUser?: IntFilter<"NftDistribution"> | number
    results?: JsonFilter<"NftDistribution">
    success?: BoolFilter<"NftDistribution"> | boolean
    createdAt?: DateTimeFilter<"NftDistribution"> | Date | string
    updatedAt?: DateTimeFilter<"NftDistribution"> | Date | string
    collection?: XOR<NftCollectionScalarRelationFilter, NftCollectionWhereInput>
    distributor?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NftDistributionOrderByWithRelationInput = {
    id?: SortOrder
    mintAddress?: SortOrder
    distributedBy?: SortOrder
    recipientCount?: SortOrder
    nftsPerUser?: SortOrder
    results?: SortOrder
    success?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    collection?: NftCollectionOrderByWithRelationInput
    distributor?: UserOrderByWithRelationInput
  }

  export type NftDistributionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NftDistributionWhereInput | NftDistributionWhereInput[]
    OR?: NftDistributionWhereInput[]
    NOT?: NftDistributionWhereInput | NftDistributionWhereInput[]
    mintAddress?: StringFilter<"NftDistribution"> | string
    distributedBy?: StringFilter<"NftDistribution"> | string
    recipientCount?: IntFilter<"NftDistribution"> | number
    nftsPerUser?: IntFilter<"NftDistribution"> | number
    results?: JsonFilter<"NftDistribution">
    success?: BoolFilter<"NftDistribution"> | boolean
    createdAt?: DateTimeFilter<"NftDistribution"> | Date | string
    updatedAt?: DateTimeFilter<"NftDistribution"> | Date | string
    collection?: XOR<NftCollectionScalarRelationFilter, NftCollectionWhereInput>
    distributor?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NftDistributionOrderByWithAggregationInput = {
    id?: SortOrder
    mintAddress?: SortOrder
    distributedBy?: SortOrder
    recipientCount?: SortOrder
    nftsPerUser?: SortOrder
    results?: SortOrder
    success?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NftDistributionCountOrderByAggregateInput
    _avg?: NftDistributionAvgOrderByAggregateInput
    _max?: NftDistributionMaxOrderByAggregateInput
    _min?: NftDistributionMinOrderByAggregateInput
    _sum?: NftDistributionSumOrderByAggregateInput
  }

  export type NftDistributionScalarWhereWithAggregatesInput = {
    AND?: NftDistributionScalarWhereWithAggregatesInput | NftDistributionScalarWhereWithAggregatesInput[]
    OR?: NftDistributionScalarWhereWithAggregatesInput[]
    NOT?: NftDistributionScalarWhereWithAggregatesInput | NftDistributionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NftDistribution"> | string
    mintAddress?: StringWithAggregatesFilter<"NftDistribution"> | string
    distributedBy?: StringWithAggregatesFilter<"NftDistribution"> | string
    recipientCount?: IntWithAggregatesFilter<"NftDistribution"> | number
    nftsPerUser?: IntWithAggregatesFilter<"NftDistribution"> | number
    results?: JsonWithAggregatesFilter<"NftDistribution">
    success?: BoolWithAggregatesFilter<"NftDistribution"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"NftDistribution"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NftDistribution"> | Date | string
  }

  export type NftClaimApprovalWhereInput = {
    AND?: NftClaimApprovalWhereInput | NftClaimApprovalWhereInput[]
    OR?: NftClaimApprovalWhereInput[]
    NOT?: NftClaimApprovalWhereInput | NftClaimApprovalWhereInput[]
    id?: StringFilter<"NftClaimApproval"> | string
    userId?: StringFilter<"NftClaimApproval"> | string
    approved?: BoolFilter<"NftClaimApproval"> | boolean
    approvedBy?: StringNullableFilter<"NftClaimApproval"> | string | null
    approvedAt?: DateTimeNullableFilter<"NftClaimApproval"> | Date | string | null
    createdAt?: DateTimeFilter<"NftClaimApproval"> | Date | string
    updatedAt?: DateTimeFilter<"NftClaimApproval"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type NftClaimApprovalOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    approved?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
  }

  export type NftClaimApprovalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: NftClaimApprovalWhereInput | NftClaimApprovalWhereInput[]
    OR?: NftClaimApprovalWhereInput[]
    NOT?: NftClaimApprovalWhereInput | NftClaimApprovalWhereInput[]
    approved?: BoolFilter<"NftClaimApproval"> | boolean
    approvedBy?: StringNullableFilter<"NftClaimApproval"> | string | null
    approvedAt?: DateTimeNullableFilter<"NftClaimApproval"> | Date | string | null
    createdAt?: DateTimeFilter<"NftClaimApproval"> | Date | string
    updatedAt?: DateTimeFilter<"NftClaimApproval"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "userId">

  export type NftClaimApprovalOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    approved?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NftClaimApprovalCountOrderByAggregateInput
    _max?: NftClaimApprovalMaxOrderByAggregateInput
    _min?: NftClaimApprovalMinOrderByAggregateInput
  }

  export type NftClaimApprovalScalarWhereWithAggregatesInput = {
    AND?: NftClaimApprovalScalarWhereWithAggregatesInput | NftClaimApprovalScalarWhereWithAggregatesInput[]
    OR?: NftClaimApprovalScalarWhereWithAggregatesInput[]
    NOT?: NftClaimApprovalScalarWhereWithAggregatesInput | NftClaimApprovalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NftClaimApproval"> | string
    userId?: StringWithAggregatesFilter<"NftClaimApproval"> | string
    approved?: BoolWithAggregatesFilter<"NftClaimApproval"> | boolean
    approvedBy?: StringNullableWithAggregatesFilter<"NftClaimApproval"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"NftClaimApproval"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NftClaimApproval"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NftClaimApproval"> | Date | string
  }

  export type UserNftHoldingWhereInput = {
    AND?: UserNftHoldingWhereInput | UserNftHoldingWhereInput[]
    OR?: UserNftHoldingWhereInput[]
    NOT?: UserNftHoldingWhereInput | UserNftHoldingWhereInput[]
    id?: StringFilter<"UserNftHolding"> | string
    userId?: StringFilter<"UserNftHolding"> | string
    mintAddress?: StringFilter<"UserNftHolding"> | string
    tokenAccount?: StringFilter<"UserNftHolding"> | string
    amount?: IntFilter<"UserNftHolding"> | number
    metadata?: JsonNullableFilter<"UserNftHolding">
    acquiredAt?: DateTimeFilter<"UserNftHolding"> | Date | string
    createdAt?: DateTimeFilter<"UserNftHolding"> | Date | string
    updatedAt?: DateTimeFilter<"UserNftHolding"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserNftHoldingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    mintAddress?: SortOrder
    tokenAccount?: SortOrder
    amount?: SortOrder
    metadata?: SortOrderInput | SortOrder
    acquiredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserNftHoldingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_mintAddress_tokenAccount?: UserNftHoldingUserIdMintAddressTokenAccountCompoundUniqueInput
    AND?: UserNftHoldingWhereInput | UserNftHoldingWhereInput[]
    OR?: UserNftHoldingWhereInput[]
    NOT?: UserNftHoldingWhereInput | UserNftHoldingWhereInput[]
    userId?: StringFilter<"UserNftHolding"> | string
    mintAddress?: StringFilter<"UserNftHolding"> | string
    tokenAccount?: StringFilter<"UserNftHolding"> | string
    amount?: IntFilter<"UserNftHolding"> | number
    metadata?: JsonNullableFilter<"UserNftHolding">
    acquiredAt?: DateTimeFilter<"UserNftHolding"> | Date | string
    createdAt?: DateTimeFilter<"UserNftHolding"> | Date | string
    updatedAt?: DateTimeFilter<"UserNftHolding"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_mintAddress_tokenAccount">

  export type UserNftHoldingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    mintAddress?: SortOrder
    tokenAccount?: SortOrder
    amount?: SortOrder
    metadata?: SortOrderInput | SortOrder
    acquiredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserNftHoldingCountOrderByAggregateInput
    _avg?: UserNftHoldingAvgOrderByAggregateInput
    _max?: UserNftHoldingMaxOrderByAggregateInput
    _min?: UserNftHoldingMinOrderByAggregateInput
    _sum?: UserNftHoldingSumOrderByAggregateInput
  }

  export type UserNftHoldingScalarWhereWithAggregatesInput = {
    AND?: UserNftHoldingScalarWhereWithAggregatesInput | UserNftHoldingScalarWhereWithAggregatesInput[]
    OR?: UserNftHoldingScalarWhereWithAggregatesInput[]
    NOT?: UserNftHoldingScalarWhereWithAggregatesInput | UserNftHoldingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserNftHolding"> | string
    userId?: StringWithAggregatesFilter<"UserNftHolding"> | string
    mintAddress?: StringWithAggregatesFilter<"UserNftHolding"> | string
    tokenAccount?: StringWithAggregatesFilter<"UserNftHolding"> | string
    amount?: IntWithAggregatesFilter<"UserNftHolding"> | number
    metadata?: JsonNullableWithAggregatesFilter<"UserNftHolding">
    acquiredAt?: DateTimeWithAggregatesFilter<"UserNftHolding"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"UserNftHolding"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserNftHolding"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionCreateNestedManyWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningUncheckedCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimUncheckedCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionUncheckedCreateNestedManyWithoutUserInput
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigUncheckedCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionUncheckedCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionUncheckedCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingUncheckedCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalUncheckedCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalUncheckedCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUpdateManyWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUncheckedUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUncheckedUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUncheckedUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUncheckedUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUncheckedUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUncheckedUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUncheckedUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUncheckedUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type AchievementCreateInput = {
    id?: string
    name: string
    description: string
    icon: string
    requirements: JsonNullValueInput | InputJsonValue
    points: number
    isSecret?: boolean
    createdAt?: Date | string
    userAchievements?: UserAchievementCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    icon: string
    requirements: JsonNullValueInput | InputJsonValue
    points: number
    isSecret?: boolean
    createdAt?: Date | string
    userAchievements?: UserAchievementUncheckedCreateNestedManyWithoutAchievementInput
  }

  export type AchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    requirements?: JsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    isSecret?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAchievements?: UserAchievementUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    requirements?: JsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    isSecret?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userAchievements?: UserAchievementUncheckedUpdateManyWithoutAchievementNestedInput
  }

  export type AchievementCreateManyInput = {
    id?: string
    name: string
    description: string
    icon: string
    requirements: JsonNullValueInput | InputJsonValue
    points: number
    isSecret?: boolean
    createdAt?: Date | string
  }

  export type AchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    requirements?: JsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    isSecret?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    requirements?: JsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    isSecret?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateInput = {
    id?: string
    unlockedAt?: Date | string
    progress?: number
    user: UserCreateNestedOneWithoutAchievementsInput
    achievement: AchievementCreateNestedOneWithoutUserAchievementsInput
  }

  export type UserAchievementUncheckedCreateInput = {
    id?: string
    userId: string
    achievementId: string
    unlockedAt?: Date | string
    progress?: number
  }

  export type UserAchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
    achievement?: AchievementUpdateOneRequiredWithoutUserAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type UserAchievementCreateManyInput = {
    id?: string
    userId: string
    achievementId: string
    unlockedAt?: Date | string
    progress?: number
  }

  export type UserAchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type UserAchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type?: $Enums.NotificationType
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    message: string
    type?: $Enums.NotificationType
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    title: string
    message: string
    type?: $Enums.NotificationType
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterAnalyticsCreateInput = {
    id?: string
    userId?: string | null
    tweetId: string
    likes?: number
    retweets?: number
    comments?: number
    impressions?: number
    engagement_rate?: number
    calculatedAt?: Date | string
  }

  export type TwitterAnalyticsUncheckedCreateInput = {
    id?: string
    userId?: string | null
    tweetId: string
    likes?: number
    retweets?: number
    comments?: number
    impressions?: number
    engagement_rate?: number
    calculatedAt?: Date | string
  }

  export type TwitterAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tweetId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    retweets?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    engagement_rate?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tweetId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    retweets?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    engagement_rate?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterAnalyticsCreateManyInput = {
    id?: string
    userId?: string | null
    tweetId: string
    likes?: number
    retweets?: number
    comments?: number
    impressions?: number
    engagement_rate?: number
    calculatedAt?: Date | string
  }

  export type TwitterAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tweetId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    retweets?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    engagement_rate?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tweetId?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    retweets?: IntFieldUpdateOperationsInput | number
    comments?: IntFieldUpdateOperationsInput | number
    impressions?: IntFieldUpdateOperationsInput | number
    engagement_rate?: FloatFieldUpdateOperationsInput | number
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterEngagementCreateInput = {
    id?: string
    tweetId: string
    engagementType: $Enums.EngagementType
    points: number
    verified?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutEngagementsInput
  }

  export type TwitterEngagementUncheckedCreateInput = {
    id?: string
    userId: string
    tweetId: string
    engagementType: $Enums.EngagementType
    points: number
    verified?: boolean
    createdAt?: Date | string
  }

  export type TwitterEngagementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    engagementType?: EnumEngagementTypeFieldUpdateOperationsInput | $Enums.EngagementType
    points?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEngagementsNestedInput
  }

  export type TwitterEngagementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    engagementType?: EnumEngagementTypeFieldUpdateOperationsInput | $Enums.EngagementType
    points?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterEngagementCreateManyInput = {
    id?: string
    userId: string
    tweetId: string
    engagementType: $Enums.EngagementType
    points: number
    verified?: boolean
    createdAt?: Date | string
  }

  export type TwitterEngagementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    engagementType?: EnumEngagementTypeFieldUpdateOperationsInput | $Enums.EngagementType
    points?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterEngagementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    engagementType?: EnumEngagementTypeFieldUpdateOperationsInput | $Enums.EngagementType
    points?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    id?: string
    name: string
    description: string
    type: $Enums.TaskType
    points: number
    requirements: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completions?: TaskCompletionCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    type: $Enums.TaskType
    points: number
    requirements: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    completions?: TaskCompletionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    points?: IntFieldUpdateOperationsInput | number
    requirements?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completions?: TaskCompletionUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    points?: IntFieldUpdateOperationsInput | number
    requirements?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completions?: TaskCompletionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id?: string
    name: string
    description: string
    type: $Enums.TaskType
    points: number
    requirements: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    points?: IntFieldUpdateOperationsInput | number
    requirements?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    points?: IntFieldUpdateOperationsInput | number
    requirements?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSessionCreateInput = {
    id?: string
    ipAddress: string
    userAgent: string
    permissions: JsonNullValueInput | InputJsonValue
    expiresAt: Date | string
    lastActivity: Date | string
    createdAt?: Date | string
    admin: UserCreateNestedOneWithoutAdminSessionsInput
  }

  export type AdminSessionUncheckedCreateInput = {
    id?: string
    adminId: string
    ipAddress: string
    userAgent: string
    permissions: JsonNullValueInput | InputJsonValue
    expiresAt: Date | string
    lastActivity: Date | string
    createdAt?: Date | string
  }

  export type AdminSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: UserUpdateOneRequiredWithoutAdminSessionsNestedInput
  }

  export type AdminSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSessionCreateManyInput = {
    id?: string
    adminId: string
    ipAddress: string
    userAgent: string
    permissions: JsonNullValueInput | InputJsonValue
    expiresAt: Date | string
    lastActivity: Date | string
    createdAt?: Date | string
  }

  export type AdminSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogCreateInput = {
    id?: string
    action: string
    metadata: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    ipAddress: string
    admin: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AdminAuditLogUncheckedCreateInput = {
    id?: string
    adminId: string
    action: string
    metadata: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    ipAddress: string
  }

  export type AdminAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    admin?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AdminAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
  }

  export type AdminAuditLogCreateManyInput = {
    id?: string
    adminId: string
    action: string
    metadata: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    ipAddress: string
  }

  export type AdminAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
  }

  export type AdminAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
  }

  export type FraudAlertCreateInput = {
    id?: string
    type: string
    severity: string
    description: string
    evidence: JsonNullValueInput | InputJsonValue
    riskScore: number
    status?: string
    createdAt?: Date | string
    investigatedBy?: string | null
    resolvedAt?: Date | string | null
    user: UserCreateNestedOneWithoutFraudAlertsInput
  }

  export type FraudAlertUncheckedCreateInput = {
    id?: string
    type: string
    severity: string
    userId: string
    description: string
    evidence: JsonNullValueInput | InputJsonValue
    riskScore: number
    status?: string
    createdAt?: Date | string
    investigatedBy?: string | null
    resolvedAt?: Date | string | null
  }

  export type FraudAlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidence?: JsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investigatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutFraudAlertsNestedInput
  }

  export type FraudAlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidence?: JsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investigatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FraudAlertCreateManyInput = {
    id?: string
    type: string
    severity: string
    userId: string
    description: string
    evidence: JsonNullValueInput | InputJsonValue
    riskScore: number
    status?: string
    createdAt?: Date | string
    investigatedBy?: string | null
    resolvedAt?: Date | string | null
  }

  export type FraudAlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidence?: JsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investigatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FraudAlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidence?: JsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investigatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignConfigCreateInput = {
    id?: string
    name: string
    description?: string | null
    tokenMint: string
    totalAllocation: bigint | number
    startDate: Date | string
    endDate: Date | string
    eligibilityCriteria: JsonNullValueInput | InputJsonValue
    distributionRules: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCampaignsInput
  }

  export type CampaignConfigUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    tokenMint: string
    totalAllocation: bigint | number
    startDate: Date | string
    endDate: Date | string
    eligibilityCriteria: JsonNullValueInput | InputJsonValue
    distributionRules: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tokenMint?: StringFieldUpdateOperationsInput | string
    totalAllocation?: BigIntFieldUpdateOperationsInput | bigint | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eligibilityCriteria?: JsonNullValueInput | InputJsonValue
    distributionRules?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCampaignsNestedInput
  }

  export type CampaignConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tokenMint?: StringFieldUpdateOperationsInput | string
    totalAllocation?: BigIntFieldUpdateOperationsInput | bigint | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eligibilityCriteria?: JsonNullValueInput | InputJsonValue
    distributionRules?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignConfigCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    tokenMint: string
    totalAllocation: bigint | number
    startDate: Date | string
    endDate: Date | string
    eligibilityCriteria: JsonNullValueInput | InputJsonValue
    distributionRules: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tokenMint?: StringFieldUpdateOperationsInput | string
    totalAllocation?: BigIntFieldUpdateOperationsInput | bigint | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eligibilityCriteria?: JsonNullValueInput | InputJsonValue
    distributionRules?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tokenMint?: StringFieldUpdateOperationsInput | string
    totalAllocation?: BigIntFieldUpdateOperationsInput | bigint | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eligibilityCriteria?: JsonNullValueInput | InputJsonValue
    distributionRules?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCompletionCreateInput = {
    id?: string
    completed?: boolean
    points: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTasksInput
    task: TaskCreateNestedOneWithoutCompletionsInput
  }

  export type TaskCompletionUncheckedCreateInput = {
    id?: string
    userId: string
    taskId: string
    completed?: boolean
    points: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TaskCompletionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
    task?: TaskUpdateOneRequiredWithoutCompletionsNestedInput
  }

  export type TaskCompletionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCompletionCreateManyInput = {
    id?: string
    userId: string
    taskId: string
    completed?: boolean
    points: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TaskCompletionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCompletionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimCreateInput = {
    id?: string
    amount: number
    transactionHash?: string | null
    status?: $Enums.ClaimStatus
    paymentMethod?: $Enums.PaymentMethod
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    feesPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    type?: string | null
    nftPasses?: NullableJsonNullValueInput | InputJsonValue
    userTier?: string | null
    user: UserCreateNestedOneWithoutClaimsInput
  }

  export type ClaimUncheckedCreateInput = {
    id?: string
    userId: string
    amount: number
    transactionHash?: string | null
    status?: $Enums.ClaimStatus
    paymentMethod?: $Enums.PaymentMethod
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    feesPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    type?: string | null
    nftPasses?: NullableJsonNullValueInput | InputJsonValue
    userTier?: string | null
  }

  export type ClaimUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feesPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    nftPasses?: NullableJsonNullValueInput | InputJsonValue
    userTier?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutClaimsNestedInput
  }

  export type ClaimUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feesPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    nftPasses?: NullableJsonNullValueInput | InputJsonValue
    userTier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClaimCreateManyInput = {
    id?: string
    userId: string
    amount: number
    transactionHash?: string | null
    status?: $Enums.ClaimStatus
    paymentMethod?: $Enums.PaymentMethod
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    feesPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    type?: string | null
    nftPasses?: NullableJsonNullValueInput | InputJsonValue
    userTier?: string | null
  }

  export type ClaimUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feesPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    nftPasses?: NullableJsonNullValueInput | InputJsonValue
    userTier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClaimUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feesPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    nftPasses?: NullableJsonNullValueInput | InputJsonValue
    userTier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PointHistoryCreateInput = {
    id?: string
    points: number
    action: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPointHistoryInput
  }

  export type PointHistoryUncheckedCreateInput = {
    id?: string
    userId: string
    points: number
    action: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PointHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPointHistoryNestedInput
  }

  export type PointHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointHistoryCreateManyInput = {
    id?: string
    userId: string
    points: number
    action: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PointHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateInput = {
    id?: string
    points?: number
    completed?: boolean
    createdAt?: Date | string
    isActive?: boolean
    referrer: UserCreateNestedOneWithoutReferralsInput
    referred: UserCreateNestedOneWithoutReferredByInput
  }

  export type ReferralUncheckedCreateInput = {
    id?: string
    referrerId: string
    referredId: string
    points?: number
    completed?: boolean
    createdAt?: Date | string
    isActive?: boolean
  }

  export type ReferralUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    referrer?: UserUpdateOneRequiredWithoutReferralsNestedInput
    referred?: UserUpdateOneRequiredWithoutReferredByNestedInput
  }

  export type ReferralUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    referredId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReferralCreateManyInput = {
    id?: string
    referrerId: string
    referredId: string
    points?: number
    completed?: boolean
    createdAt?: Date | string
    isActive?: boolean
  }

  export type ReferralUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReferralUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    referredId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SystemConfigCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    description?: string | null
    updatedAt?: Date | string
  }

  export type SystemConfigUncheckedCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    description?: string | null
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigCreateManyInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    description?: string | null
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsCreateInput = {
    id?: string
    date?: Date | string
    totalUsers?: number
    activeUsers?: number
    totalClaims?: number
    totalPoints?: number
    totalEngagements?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsUncheckedCreateInput = {
    id?: string
    date?: Date | string
    totalUsers?: number
    activeUsers?: number
    totalClaims?: number
    totalPoints?: number
    totalEngagements?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalUsers?: IntFieldUpdateOperationsInput | number
    activeUsers?: IntFieldUpdateOperationsInput | number
    totalClaims?: IntFieldUpdateOperationsInput | number
    totalPoints?: IntFieldUpdateOperationsInput | number
    totalEngagements?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalUsers?: IntFieldUpdateOperationsInput | number
    activeUsers?: IntFieldUpdateOperationsInput | number
    totalClaims?: IntFieldUpdateOperationsInput | number
    totalPoints?: IntFieldUpdateOperationsInput | number
    totalEngagements?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsCreateManyInput = {
    id?: string
    date?: Date | string
    totalUsers?: number
    activeUsers?: number
    totalClaims?: number
    totalPoints?: number
    totalEngagements?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalUsers?: IntFieldUpdateOperationsInput | number
    activeUsers?: IntFieldUpdateOperationsInput | number
    totalClaims?: IntFieldUpdateOperationsInput | number
    totalPoints?: IntFieldUpdateOperationsInput | number
    totalEngagements?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalUsers?: IntFieldUpdateOperationsInput | number
    activeUsers?: IntFieldUpdateOperationsInput | number
    totalClaims?: IntFieldUpdateOperationsInput | number
    totalPoints?: IntFieldUpdateOperationsInput | number
    totalEngagements?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyEarningCreateInput = {
    id?: string
    tokens: number
    type: string
    claimedAt?: Date | string
    user: UserCreateNestedOneWithoutDailyEarningsInput
  }

  export type DailyEarningUncheckedCreateInput = {
    id?: string
    userId: string
    tokens: number
    type: string
    claimedAt?: Date | string
  }

  export type DailyEarningUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokens?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    claimedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDailyEarningsNestedInput
  }

  export type DailyEarningUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokens?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    claimedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyEarningCreateManyInput = {
    id?: string
    userId: string
    tokens: number
    type: string
    claimedAt?: Date | string
  }

  export type DailyEarningUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokens?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    claimedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyEarningUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokens?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    claimedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AirdropSeasonCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    totalAllocation: bigint | number
    claimedAmount?: bigint | number
    startDate?: Date | string
    endDate?: Date | string | null
    nftPassRequired?: boolean
    requireApproval?: boolean
    feeAmount?: Decimal | DecimalJsLike | number | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutAirdropSeasonsInput
    claims?: AirdropClaimCreateNestedManyWithoutSeasonInput
  }

  export type AirdropSeasonUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    totalAllocation: bigint | number
    claimedAmount?: bigint | number
    startDate?: Date | string
    endDate?: Date | string | null
    nftPassRequired?: boolean
    requireApproval?: boolean
    feeAmount?: Decimal | DecimalJsLike | number | string
    createdBy: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    claims?: AirdropClaimUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type AirdropSeasonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalAllocation?: BigIntFieldUpdateOperationsInput | bigint | number
    claimedAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nftPassRequired?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutAirdropSeasonsNestedInput
    claims?: AirdropClaimUpdateManyWithoutSeasonNestedInput
  }

  export type AirdropSeasonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalAllocation?: BigIntFieldUpdateOperationsInput | bigint | number
    claimedAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nftPassRequired?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdBy?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claims?: AirdropClaimUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type AirdropSeasonCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    totalAllocation: bigint | number
    claimedAmount?: bigint | number
    startDate?: Date | string
    endDate?: Date | string | null
    nftPassRequired?: boolean
    requireApproval?: boolean
    feeAmount?: Decimal | DecimalJsLike | number | string
    createdBy: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AirdropSeasonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalAllocation?: BigIntFieldUpdateOperationsInput | bigint | number
    claimedAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nftPassRequired?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AirdropSeasonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalAllocation?: BigIntFieldUpdateOperationsInput | bigint | number
    claimedAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nftPassRequired?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdBy?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AirdropClaimCreateInput = {
    id?: string
    tokens: number
    tier: string
    paymentSignature: string
    transactionSignature?: string | null
    status: string
    claimedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAirdropClaimsInput
    season: AirdropSeasonCreateNestedOneWithoutClaimsInput
  }

  export type AirdropClaimUncheckedCreateInput = {
    id?: string
    userId: string
    seasonId: string
    tokens: number
    tier: string
    paymentSignature: string
    transactionSignature?: string | null
    status: string
    claimedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AirdropClaimUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokens?: FloatFieldUpdateOperationsInput | number
    tier?: StringFieldUpdateOperationsInput | string
    paymentSignature?: StringFieldUpdateOperationsInput | string
    transactionSignature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    claimedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAirdropClaimsNestedInput
    season?: AirdropSeasonUpdateOneRequiredWithoutClaimsNestedInput
  }

  export type AirdropClaimUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    tokens?: FloatFieldUpdateOperationsInput | number
    tier?: StringFieldUpdateOperationsInput | string
    paymentSignature?: StringFieldUpdateOperationsInput | string
    transactionSignature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    claimedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AirdropClaimCreateManyInput = {
    id?: string
    userId: string
    seasonId: string
    tokens: number
    tier: string
    paymentSignature: string
    transactionSignature?: string | null
    status: string
    claimedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AirdropClaimUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokens?: FloatFieldUpdateOperationsInput | number
    tier?: StringFieldUpdateOperationsInput | string
    paymentSignature?: StringFieldUpdateOperationsInput | string
    transactionSignature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    claimedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AirdropClaimUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    tokens?: FloatFieldUpdateOperationsInput | number
    tier?: StringFieldUpdateOperationsInput | string
    paymentSignature?: StringFieldUpdateOperationsInput | string
    transactionSignature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    claimedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NftCollectionCreateInput = {
    id?: string
    mintAddress: string
    name: string
    symbol: string
    description?: string | null
    uri: string
    supply?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutNftCollectionsInput
    distributions?: NftDistributionCreateNestedManyWithoutCollectionInput
  }

  export type NftCollectionUncheckedCreateInput = {
    id?: string
    mintAddress: string
    name: string
    symbol: string
    description?: string | null
    uri: string
    supply?: number
    createdBy: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    distributions?: NftDistributionUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type NftCollectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mintAddress?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uri?: StringFieldUpdateOperationsInput | string
    supply?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutNftCollectionsNestedInput
    distributions?: NftDistributionUpdateManyWithoutCollectionNestedInput
  }

  export type NftCollectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mintAddress?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uri?: StringFieldUpdateOperationsInput | string
    supply?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributions?: NftDistributionUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type NftCollectionCreateManyInput = {
    id?: string
    mintAddress: string
    name: string
    symbol: string
    description?: string | null
    uri: string
    supply?: number
    createdBy: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NftCollectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mintAddress?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uri?: StringFieldUpdateOperationsInput | string
    supply?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NftCollectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mintAddress?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uri?: StringFieldUpdateOperationsInput | string
    supply?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NftDistributionCreateInput = {
    id?: string
    recipientCount: number
    nftsPerUser: number
    results: JsonNullValueInput | InputJsonValue
    success?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    collection: NftCollectionCreateNestedOneWithoutDistributionsInput
    distributor: UserCreateNestedOneWithoutNftDistributionsInput
  }

  export type NftDistributionUncheckedCreateInput = {
    id?: string
    mintAddress: string
    distributedBy: string
    recipientCount: number
    nftsPerUser: number
    results: JsonNullValueInput | InputJsonValue
    success?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NftDistributionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    nftsPerUser?: IntFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    success?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collection?: NftCollectionUpdateOneRequiredWithoutDistributionsNestedInput
    distributor?: UserUpdateOneRequiredWithoutNftDistributionsNestedInput
  }

  export type NftDistributionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mintAddress?: StringFieldUpdateOperationsInput | string
    distributedBy?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    nftsPerUser?: IntFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    success?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NftDistributionCreateManyInput = {
    id?: string
    mintAddress: string
    distributedBy: string
    recipientCount: number
    nftsPerUser: number
    results: JsonNullValueInput | InputJsonValue
    success?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NftDistributionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    nftsPerUser?: IntFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    success?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NftDistributionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mintAddress?: StringFieldUpdateOperationsInput | string
    distributedBy?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    nftsPerUser?: IntFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    success?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NftClaimApprovalCreateInput = {
    id?: string
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNftClaimApprovalInput
    approver?: UserCreateNestedOneWithoutApprovedClaimsInput
  }

  export type NftClaimApprovalUncheckedCreateInput = {
    id?: string
    userId: string
    approved?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NftClaimApprovalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNftClaimApprovalNestedInput
    approver?: UserUpdateOneWithoutApprovedClaimsNestedInput
  }

  export type NftClaimApprovalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NftClaimApprovalCreateManyInput = {
    id?: string
    userId: string
    approved?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NftClaimApprovalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NftClaimApprovalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNftHoldingCreateInput = {
    id?: string
    mintAddress: string
    tokenAccount: string
    amount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acquiredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNftHoldingsInput
  }

  export type UserNftHoldingUncheckedCreateInput = {
    id?: string
    userId: string
    mintAddress: string
    tokenAccount: string
    amount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acquiredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserNftHoldingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mintAddress?: StringFieldUpdateOperationsInput | string
    tokenAccount?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNftHoldingsNestedInput
  }

  export type UserNftHoldingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mintAddress?: StringFieldUpdateOperationsInput | string
    tokenAccount?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNftHoldingCreateManyInput = {
    id?: string
    userId: string
    mintAddress: string
    tokenAccount: string
    amount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acquiredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserNftHoldingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mintAddress?: StringFieldUpdateOperationsInput | string
    tokenAccount?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNftHoldingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    mintAddress?: StringFieldUpdateOperationsInput | string
    tokenAccount?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumTwitterActivityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TwitterActivity | EnumTwitterActivityFieldRefInput<$PrismaModel> | null
    in?: $Enums.TwitterActivity[] | ListEnumTwitterActivityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TwitterActivity[] | ListEnumTwitterActivityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTwitterActivityNullableFilter<$PrismaModel> | $Enums.TwitterActivity | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DailyEarningListRelationFilter = {
    every?: DailyEarningWhereInput
    some?: DailyEarningWhereInput
    none?: DailyEarningWhereInput
  }

  export type AirdropClaimListRelationFilter = {
    every?: AirdropClaimWhereInput
    some?: AirdropClaimWhereInput
    none?: AirdropClaimWhereInput
  }

  export type TwitterEngagementListRelationFilter = {
    every?: TwitterEngagementWhereInput
    some?: TwitterEngagementWhereInput
    none?: TwitterEngagementWhereInput
  }

  export type TaskCompletionListRelationFilter = {
    every?: TaskCompletionWhereInput
    some?: TaskCompletionWhereInput
    none?: TaskCompletionWhereInput
  }

  export type ClaimListRelationFilter = {
    every?: ClaimWhereInput
    some?: ClaimWhereInput
    none?: ClaimWhereInput
  }

  export type PointHistoryListRelationFilter = {
    every?: PointHistoryWhereInput
    some?: PointHistoryWhereInput
    none?: PointHistoryWhereInput
  }

  export type ReferralListRelationFilter = {
    every?: ReferralWhereInput
    some?: ReferralWhereInput
    none?: ReferralWhereInput
  }

  export type ReferralNullableScalarRelationFilter = {
    is?: ReferralWhereInput | null
    isNot?: ReferralWhereInput | null
  }

  export type UserAchievementListRelationFilter = {
    every?: UserAchievementWhereInput
    some?: UserAchievementWhereInput
    none?: UserAchievementWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type AdminSessionListRelationFilter = {
    every?: AdminSessionWhereInput
    some?: AdminSessionWhereInput
    none?: AdminSessionWhereInput
  }

  export type AdminAuditLogListRelationFilter = {
    every?: AdminAuditLogWhereInput
    some?: AdminAuditLogWhereInput
    none?: AdminAuditLogWhereInput
  }

  export type FraudAlertListRelationFilter = {
    every?: FraudAlertWhereInput
    some?: FraudAlertWhereInput
    none?: FraudAlertWhereInput
  }

  export type CampaignConfigListRelationFilter = {
    every?: CampaignConfigWhereInput
    some?: CampaignConfigWhereInput
    none?: CampaignConfigWhereInput
  }

  export type NftCollectionListRelationFilter = {
    every?: NftCollectionWhereInput
    some?: NftCollectionWhereInput
    none?: NftCollectionWhereInput
  }

  export type NftDistributionListRelationFilter = {
    every?: NftDistributionWhereInput
    some?: NftDistributionWhereInput
    none?: NftDistributionWhereInput
  }

  export type UserNftHoldingListRelationFilter = {
    every?: UserNftHoldingWhereInput
    some?: UserNftHoldingWhereInput
    none?: UserNftHoldingWhereInput
  }

  export type NftClaimApprovalNullableScalarRelationFilter = {
    is?: NftClaimApprovalWhereInput | null
    isNot?: NftClaimApprovalWhereInput | null
  }

  export type NftClaimApprovalListRelationFilter = {
    every?: NftClaimApprovalWhereInput
    some?: NftClaimApprovalWhereInput
    none?: NftClaimApprovalWhereInput
  }

  export type AirdropSeasonListRelationFilter = {
    every?: AirdropSeasonWhereInput
    some?: AirdropSeasonWhereInput
    none?: AirdropSeasonWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type DailyEarningOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AirdropClaimOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TwitterEngagementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskCompletionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClaimOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PointHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminAuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FraudAlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CampaignConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NftCollectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NftDistributionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserNftHoldingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NftClaimApprovalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AirdropSeasonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    walletAddress?: SortOrder
    twitterId?: SortOrder
    twitterUsername?: SortOrder
    twitterName?: SortOrder
    twitterImage?: SortOrder
    twitterFollowers?: SortOrder
    twitterActivity?: SortOrder
    level?: SortOrder
    streak?: SortOrder
    lastCheckIn?: SortOrder
    referralCode?: SortOrder
    email?: SortOrder
    totalPoints?: SortOrder
    rank?: SortOrder
    isAdmin?: SortOrder
    isActive?: SortOrder
    totalEarnedTokens?: SortOrder
    lastLoginReward?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    permissions?: SortOrder
    riskScore?: SortOrder
    suspiciousFlags?: SortOrder
    isBanned?: SortOrder
    bannedAt?: SortOrder
    lastActivity?: SortOrder
    claimsEnabled?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    twitterFollowers?: SortOrder
    level?: SortOrder
    streak?: SortOrder
    totalPoints?: SortOrder
    rank?: SortOrder
    totalEarnedTokens?: SortOrder
    riskScore?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    walletAddress?: SortOrder
    twitterId?: SortOrder
    twitterUsername?: SortOrder
    twitterName?: SortOrder
    twitterImage?: SortOrder
    twitterFollowers?: SortOrder
    twitterActivity?: SortOrder
    level?: SortOrder
    streak?: SortOrder
    lastCheckIn?: SortOrder
    referralCode?: SortOrder
    email?: SortOrder
    totalPoints?: SortOrder
    rank?: SortOrder
    isAdmin?: SortOrder
    isActive?: SortOrder
    totalEarnedTokens?: SortOrder
    lastLoginReward?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    riskScore?: SortOrder
    isBanned?: SortOrder
    bannedAt?: SortOrder
    lastActivity?: SortOrder
    claimsEnabled?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    walletAddress?: SortOrder
    twitterId?: SortOrder
    twitterUsername?: SortOrder
    twitterName?: SortOrder
    twitterImage?: SortOrder
    twitterFollowers?: SortOrder
    twitterActivity?: SortOrder
    level?: SortOrder
    streak?: SortOrder
    lastCheckIn?: SortOrder
    referralCode?: SortOrder
    email?: SortOrder
    totalPoints?: SortOrder
    rank?: SortOrder
    isAdmin?: SortOrder
    isActive?: SortOrder
    totalEarnedTokens?: SortOrder
    lastLoginReward?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    riskScore?: SortOrder
    isBanned?: SortOrder
    bannedAt?: SortOrder
    lastActivity?: SortOrder
    claimsEnabled?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    twitterFollowers?: SortOrder
    level?: SortOrder
    streak?: SortOrder
    totalPoints?: SortOrder
    rank?: SortOrder
    totalEarnedTokens?: SortOrder
    riskScore?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumTwitterActivityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TwitterActivity | EnumTwitterActivityFieldRefInput<$PrismaModel> | null
    in?: $Enums.TwitterActivity[] | ListEnumTwitterActivityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TwitterActivity[] | ListEnumTwitterActivityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTwitterActivityNullableWithAggregatesFilter<$PrismaModel> | $Enums.TwitterActivity | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTwitterActivityNullableFilter<$PrismaModel>
    _max?: NestedEnumTwitterActivityNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    requirements?: SortOrder
    points?: SortOrder
    isSecret?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    points?: SortOrder
    isSecret?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    points?: SortOrder
    isSecret?: SortOrder
    createdAt?: SortOrder
  }

  export type AchievementSumOrderByAggregateInput = {
    points?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AchievementScalarRelationFilter = {
    is?: AchievementWhereInput
    isNot?: AchievementWhereInput
  }

  export type UserAchievementUserIdAchievementIdCompoundUniqueInput = {
    userId: string
    achievementId: string
  }

  export type UserAchievementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    unlockedAt?: SortOrder
    progress?: SortOrder
  }

  export type UserAchievementAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type UserAchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    unlockedAt?: SortOrder
    progress?: SortOrder
  }

  export type UserAchievementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementId?: SortOrder
    unlockedAt?: SortOrder
    progress?: SortOrder
  }

  export type UserAchievementSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type TwitterAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tweetId?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    comments?: SortOrder
    impressions?: SortOrder
    engagement_rate?: SortOrder
    calculatedAt?: SortOrder
  }

  export type TwitterAnalyticsAvgOrderByAggregateInput = {
    likes?: SortOrder
    retweets?: SortOrder
    comments?: SortOrder
    impressions?: SortOrder
    engagement_rate?: SortOrder
  }

  export type TwitterAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tweetId?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    comments?: SortOrder
    impressions?: SortOrder
    engagement_rate?: SortOrder
    calculatedAt?: SortOrder
  }

  export type TwitterAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tweetId?: SortOrder
    likes?: SortOrder
    retweets?: SortOrder
    comments?: SortOrder
    impressions?: SortOrder
    engagement_rate?: SortOrder
    calculatedAt?: SortOrder
  }

  export type TwitterAnalyticsSumOrderByAggregateInput = {
    likes?: SortOrder
    retweets?: SortOrder
    comments?: SortOrder
    impressions?: SortOrder
    engagement_rate?: SortOrder
  }

  export type EnumEngagementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EngagementType | EnumEngagementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EngagementType[] | ListEnumEngagementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EngagementType[] | ListEnumEngagementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEngagementTypeFilter<$PrismaModel> | $Enums.EngagementType
  }

  export type TwitterEngagementUserIdTweetIdEngagementTypeCompoundUniqueInput = {
    userId: string
    tweetId: string
    engagementType: $Enums.EngagementType
  }

  export type TwitterEngagementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tweetId?: SortOrder
    engagementType?: SortOrder
    points?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type TwitterEngagementAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type TwitterEngagementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tweetId?: SortOrder
    engagementType?: SortOrder
    points?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type TwitterEngagementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tweetId?: SortOrder
    engagementType?: SortOrder
    points?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
  }

  export type TwitterEngagementSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type EnumEngagementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EngagementType | EnumEngagementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EngagementType[] | ListEnumEngagementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EngagementType[] | ListEnumEngagementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEngagementTypeWithAggregatesFilter<$PrismaModel> | $Enums.EngagementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEngagementTypeFilter<$PrismaModel>
    _max?: NestedEnumEngagementTypeFilter<$PrismaModel>
  }

  export type EnumTaskTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskTypeFilter<$PrismaModel> | $Enums.TaskType
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    points?: SortOrder
    requirements?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    points?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    points?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type EnumTaskTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaskType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskTypeFilter<$PrismaModel>
    _max?: NestedEnumTaskTypeFilter<$PrismaModel>
  }

  export type AdminSessionCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    permissions?: SortOrder
    expiresAt?: SortOrder
    lastActivity?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    lastActivity?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminSessionMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiresAt?: SortOrder
    lastActivity?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
  }

  export type AdminAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
  }

  export type AdminAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
  }

  export type FraudAlertCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    evidence?: SortOrder
    riskScore?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    investigatedBy?: SortOrder
    resolvedAt?: SortOrder
  }

  export type FraudAlertAvgOrderByAggregateInput = {
    riskScore?: SortOrder
  }

  export type FraudAlertMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    riskScore?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    investigatedBy?: SortOrder
    resolvedAt?: SortOrder
  }

  export type FraudAlertMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    userId?: SortOrder
    description?: SortOrder
    riskScore?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    investigatedBy?: SortOrder
    resolvedAt?: SortOrder
  }

  export type FraudAlertSumOrderByAggregateInput = {
    riskScore?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type CampaignConfigCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tokenMint?: SortOrder
    totalAllocation?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    eligibilityCriteria?: SortOrder
    distributionRules?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignConfigAvgOrderByAggregateInput = {
    totalAllocation?: SortOrder
  }

  export type CampaignConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tokenMint?: SortOrder
    totalAllocation?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignConfigMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tokenMint?: SortOrder
    totalAllocation?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CampaignConfigSumOrderByAggregateInput = {
    totalAllocation?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type TaskScalarRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type TaskCompletionUserIdTaskIdCompoundUniqueInput = {
    userId: string
    taskId: string
  }

  export type TaskCompletionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    completed?: SortOrder
    points?: SortOrder
    metadata?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskCompletionAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type TaskCompletionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    completed?: SortOrder
    points?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskCompletionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    taskId?: SortOrder
    completed?: SortOrder
    points?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TaskCompletionSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type EnumClaimStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusFilter<$PrismaModel> | $Enums.ClaimStatus
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ClaimCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    transactionHash?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    metadata?: SortOrder
    processedAt?: SortOrder
    feesPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    nftPasses?: SortOrder
    userTier?: SortOrder
  }

  export type ClaimAvgOrderByAggregateInput = {
    amount?: SortOrder
    feesPaid?: SortOrder
  }

  export type ClaimMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    transactionHash?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    processedAt?: SortOrder
    feesPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    userTier?: SortOrder
  }

  export type ClaimMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    transactionHash?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    processedAt?: SortOrder
    feesPaid?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    userTier?: SortOrder
  }

  export type ClaimSumOrderByAggregateInput = {
    amount?: SortOrder
    feesPaid?: SortOrder
  }

  export type EnumClaimStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClaimStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClaimStatusFilter<$PrismaModel>
    _max?: NestedEnumClaimStatusFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type PointHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    action?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type PointHistoryAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type PointHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    action?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PointHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    points?: SortOrder
    action?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type PointHistorySumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type ReferralCountOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    referredId?: SortOrder
    points?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
  }

  export type ReferralAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type ReferralMaxOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    referredId?: SortOrder
    points?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
  }

  export type ReferralMinOrderByAggregateInput = {
    id?: SortOrder
    referrerId?: SortOrder
    referredId?: SortOrder
    points?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    isActive?: SortOrder
  }

  export type ReferralSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type SystemConfigCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    description?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    totalUsers?: SortOrder
    activeUsers?: SortOrder
    totalClaims?: SortOrder
    totalPoints?: SortOrder
    totalEngagements?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsAvgOrderByAggregateInput = {
    totalUsers?: SortOrder
    activeUsers?: SortOrder
    totalClaims?: SortOrder
    totalPoints?: SortOrder
    totalEngagements?: SortOrder
  }

  export type AnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    totalUsers?: SortOrder
    activeUsers?: SortOrder
    totalClaims?: SortOrder
    totalPoints?: SortOrder
    totalEngagements?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    totalUsers?: SortOrder
    activeUsers?: SortOrder
    totalClaims?: SortOrder
    totalPoints?: SortOrder
    totalEngagements?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsSumOrderByAggregateInput = {
    totalUsers?: SortOrder
    activeUsers?: SortOrder
    totalClaims?: SortOrder
    totalPoints?: SortOrder
    totalEngagements?: SortOrder
  }

  export type DailyEarningCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokens?: SortOrder
    type?: SortOrder
    claimedAt?: SortOrder
  }

  export type DailyEarningAvgOrderByAggregateInput = {
    tokens?: SortOrder
  }

  export type DailyEarningMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokens?: SortOrder
    type?: SortOrder
    claimedAt?: SortOrder
  }

  export type DailyEarningMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokens?: SortOrder
    type?: SortOrder
    claimedAt?: SortOrder
  }

  export type DailyEarningSumOrderByAggregateInput = {
    tokens?: SortOrder
  }

  export type AirdropSeasonCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    totalAllocation?: SortOrder
    claimedAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    nftPassRequired?: SortOrder
    requireApproval?: SortOrder
    feeAmount?: SortOrder
    createdBy?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AirdropSeasonAvgOrderByAggregateInput = {
    totalAllocation?: SortOrder
    claimedAmount?: SortOrder
    feeAmount?: SortOrder
  }

  export type AirdropSeasonMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    totalAllocation?: SortOrder
    claimedAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    nftPassRequired?: SortOrder
    requireApproval?: SortOrder
    feeAmount?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AirdropSeasonMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    totalAllocation?: SortOrder
    claimedAmount?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    nftPassRequired?: SortOrder
    requireApproval?: SortOrder
    feeAmount?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AirdropSeasonSumOrderByAggregateInput = {
    totalAllocation?: SortOrder
    claimedAmount?: SortOrder
    feeAmount?: SortOrder
  }

  export type AirdropSeasonScalarRelationFilter = {
    is?: AirdropSeasonWhereInput
    isNot?: AirdropSeasonWhereInput
  }

  export type AirdropClaimUserIdSeasonIdCompoundUniqueInput = {
    userId: string
    seasonId: string
  }

  export type AirdropClaimCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    seasonId?: SortOrder
    tokens?: SortOrder
    tier?: SortOrder
    paymentSignature?: SortOrder
    transactionSignature?: SortOrder
    status?: SortOrder
    claimedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AirdropClaimAvgOrderByAggregateInput = {
    tokens?: SortOrder
  }

  export type AirdropClaimMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    seasonId?: SortOrder
    tokens?: SortOrder
    tier?: SortOrder
    paymentSignature?: SortOrder
    transactionSignature?: SortOrder
    status?: SortOrder
    claimedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AirdropClaimMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    seasonId?: SortOrder
    tokens?: SortOrder
    tier?: SortOrder
    paymentSignature?: SortOrder
    transactionSignature?: SortOrder
    status?: SortOrder
    claimedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AirdropClaimSumOrderByAggregateInput = {
    tokens?: SortOrder
  }

  export type NftCollectionCountOrderByAggregateInput = {
    id?: SortOrder
    mintAddress?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrder
    uri?: SortOrder
    supply?: SortOrder
    createdBy?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NftCollectionAvgOrderByAggregateInput = {
    supply?: SortOrder
  }

  export type NftCollectionMaxOrderByAggregateInput = {
    id?: SortOrder
    mintAddress?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrder
    uri?: SortOrder
    supply?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NftCollectionMinOrderByAggregateInput = {
    id?: SortOrder
    mintAddress?: SortOrder
    name?: SortOrder
    symbol?: SortOrder
    description?: SortOrder
    uri?: SortOrder
    supply?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NftCollectionSumOrderByAggregateInput = {
    supply?: SortOrder
  }

  export type NftCollectionScalarRelationFilter = {
    is?: NftCollectionWhereInput
    isNot?: NftCollectionWhereInput
  }

  export type NftDistributionCountOrderByAggregateInput = {
    id?: SortOrder
    mintAddress?: SortOrder
    distributedBy?: SortOrder
    recipientCount?: SortOrder
    nftsPerUser?: SortOrder
    results?: SortOrder
    success?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NftDistributionAvgOrderByAggregateInput = {
    recipientCount?: SortOrder
    nftsPerUser?: SortOrder
  }

  export type NftDistributionMaxOrderByAggregateInput = {
    id?: SortOrder
    mintAddress?: SortOrder
    distributedBy?: SortOrder
    recipientCount?: SortOrder
    nftsPerUser?: SortOrder
    success?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NftDistributionMinOrderByAggregateInput = {
    id?: SortOrder
    mintAddress?: SortOrder
    distributedBy?: SortOrder
    recipientCount?: SortOrder
    nftsPerUser?: SortOrder
    success?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NftDistributionSumOrderByAggregateInput = {
    recipientCount?: SortOrder
    nftsPerUser?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type NftClaimApprovalCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    approved?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NftClaimApprovalMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    approved?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NftClaimApprovalMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    approved?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNftHoldingUserIdMintAddressTokenAccountCompoundUniqueInput = {
    userId: string
    mintAddress: string
    tokenAccount: string
  }

  export type UserNftHoldingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mintAddress?: SortOrder
    tokenAccount?: SortOrder
    amount?: SortOrder
    metadata?: SortOrder
    acquiredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNftHoldingAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type UserNftHoldingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mintAddress?: SortOrder
    tokenAccount?: SortOrder
    amount?: SortOrder
    acquiredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNftHoldingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    mintAddress?: SortOrder
    tokenAccount?: SortOrder
    amount?: SortOrder
    acquiredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNftHoldingSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type UserCreatesuspiciousFlagsInput = {
    set: string[]
  }

  export type DailyEarningCreateNestedManyWithoutUserInput = {
    create?: XOR<DailyEarningCreateWithoutUserInput, DailyEarningUncheckedCreateWithoutUserInput> | DailyEarningCreateWithoutUserInput[] | DailyEarningUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyEarningCreateOrConnectWithoutUserInput | DailyEarningCreateOrConnectWithoutUserInput[]
    createMany?: DailyEarningCreateManyUserInputEnvelope
    connect?: DailyEarningWhereUniqueInput | DailyEarningWhereUniqueInput[]
  }

  export type AirdropClaimCreateNestedManyWithoutUserInput = {
    create?: XOR<AirdropClaimCreateWithoutUserInput, AirdropClaimUncheckedCreateWithoutUserInput> | AirdropClaimCreateWithoutUserInput[] | AirdropClaimUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AirdropClaimCreateOrConnectWithoutUserInput | AirdropClaimCreateOrConnectWithoutUserInput[]
    createMany?: AirdropClaimCreateManyUserInputEnvelope
    connect?: AirdropClaimWhereUniqueInput | AirdropClaimWhereUniqueInput[]
  }

  export type TwitterEngagementCreateNestedManyWithoutUserInput = {
    create?: XOR<TwitterEngagementCreateWithoutUserInput, TwitterEngagementUncheckedCreateWithoutUserInput> | TwitterEngagementCreateWithoutUserInput[] | TwitterEngagementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwitterEngagementCreateOrConnectWithoutUserInput | TwitterEngagementCreateOrConnectWithoutUserInput[]
    createMany?: TwitterEngagementCreateManyUserInputEnvelope
    connect?: TwitterEngagementWhereUniqueInput | TwitterEngagementWhereUniqueInput[]
  }

  export type TaskCompletionCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskCompletionCreateWithoutUserInput, TaskCompletionUncheckedCreateWithoutUserInput> | TaskCompletionCreateWithoutUserInput[] | TaskCompletionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCompletionCreateOrConnectWithoutUserInput | TaskCompletionCreateOrConnectWithoutUserInput[]
    createMany?: TaskCompletionCreateManyUserInputEnvelope
    connect?: TaskCompletionWhereUniqueInput | TaskCompletionWhereUniqueInput[]
  }

  export type ClaimCreateNestedManyWithoutUserInput = {
    create?: XOR<ClaimCreateWithoutUserInput, ClaimUncheckedCreateWithoutUserInput> | ClaimCreateWithoutUserInput[] | ClaimUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutUserInput | ClaimCreateOrConnectWithoutUserInput[]
    createMany?: ClaimCreateManyUserInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type PointHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<PointHistoryCreateWithoutUserInput, PointHistoryUncheckedCreateWithoutUserInput> | PointHistoryCreateWithoutUserInput[] | PointHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointHistoryCreateOrConnectWithoutUserInput | PointHistoryCreateOrConnectWithoutUserInput[]
    createMany?: PointHistoryCreateManyUserInputEnvelope
    connect?: PointHistoryWhereUniqueInput | PointHistoryWhereUniqueInput[]
  }

  export type ReferralCreateNestedManyWithoutReferrerInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralCreateNestedOneWithoutReferredInput = {
    create?: XOR<ReferralCreateWithoutReferredInput, ReferralUncheckedCreateWithoutReferredInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredInput
    connect?: ReferralWhereUniqueInput
  }

  export type UserAchievementCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AdminSessionCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminSessionCreateWithoutAdminInput, AdminSessionUncheckedCreateWithoutAdminInput> | AdminSessionCreateWithoutAdminInput[] | AdminSessionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminSessionCreateOrConnectWithoutAdminInput | AdminSessionCreateOrConnectWithoutAdminInput[]
    createMany?: AdminSessionCreateManyAdminInputEnvelope
    connect?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
  }

  export type AdminAuditLogCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput> | AdminAuditLogCreateWithoutAdminInput[] | AdminAuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminInput | AdminAuditLogCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAuditLogCreateManyAdminInputEnvelope
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
  }

  export type FraudAlertCreateNestedManyWithoutUserInput = {
    create?: XOR<FraudAlertCreateWithoutUserInput, FraudAlertUncheckedCreateWithoutUserInput> | FraudAlertCreateWithoutUserInput[] | FraudAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FraudAlertCreateOrConnectWithoutUserInput | FraudAlertCreateOrConnectWithoutUserInput[]
    createMany?: FraudAlertCreateManyUserInputEnvelope
    connect?: FraudAlertWhereUniqueInput | FraudAlertWhereUniqueInput[]
  }

  export type CampaignConfigCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CampaignConfigCreateWithoutCreatorInput, CampaignConfigUncheckedCreateWithoutCreatorInput> | CampaignConfigCreateWithoutCreatorInput[] | CampaignConfigUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CampaignConfigCreateOrConnectWithoutCreatorInput | CampaignConfigCreateOrConnectWithoutCreatorInput[]
    createMany?: CampaignConfigCreateManyCreatorInputEnvelope
    connect?: CampaignConfigWhereUniqueInput | CampaignConfigWhereUniqueInput[]
  }

  export type NftCollectionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<NftCollectionCreateWithoutCreatorInput, NftCollectionUncheckedCreateWithoutCreatorInput> | NftCollectionCreateWithoutCreatorInput[] | NftCollectionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: NftCollectionCreateOrConnectWithoutCreatorInput | NftCollectionCreateOrConnectWithoutCreatorInput[]
    createMany?: NftCollectionCreateManyCreatorInputEnvelope
    connect?: NftCollectionWhereUniqueInput | NftCollectionWhereUniqueInput[]
  }

  export type NftDistributionCreateNestedManyWithoutDistributorInput = {
    create?: XOR<NftDistributionCreateWithoutDistributorInput, NftDistributionUncheckedCreateWithoutDistributorInput> | NftDistributionCreateWithoutDistributorInput[] | NftDistributionUncheckedCreateWithoutDistributorInput[]
    connectOrCreate?: NftDistributionCreateOrConnectWithoutDistributorInput | NftDistributionCreateOrConnectWithoutDistributorInput[]
    createMany?: NftDistributionCreateManyDistributorInputEnvelope
    connect?: NftDistributionWhereUniqueInput | NftDistributionWhereUniqueInput[]
  }

  export type UserNftHoldingCreateNestedManyWithoutUserInput = {
    create?: XOR<UserNftHoldingCreateWithoutUserInput, UserNftHoldingUncheckedCreateWithoutUserInput> | UserNftHoldingCreateWithoutUserInput[] | UserNftHoldingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserNftHoldingCreateOrConnectWithoutUserInput | UserNftHoldingCreateOrConnectWithoutUserInput[]
    createMany?: UserNftHoldingCreateManyUserInputEnvelope
    connect?: UserNftHoldingWhereUniqueInput | UserNftHoldingWhereUniqueInput[]
  }

  export type NftClaimApprovalCreateNestedOneWithoutUserInput = {
    create?: XOR<NftClaimApprovalCreateWithoutUserInput, NftClaimApprovalUncheckedCreateWithoutUserInput>
    connectOrCreate?: NftClaimApprovalCreateOrConnectWithoutUserInput
    connect?: NftClaimApprovalWhereUniqueInput
  }

  export type NftClaimApprovalCreateNestedManyWithoutApproverInput = {
    create?: XOR<NftClaimApprovalCreateWithoutApproverInput, NftClaimApprovalUncheckedCreateWithoutApproverInput> | NftClaimApprovalCreateWithoutApproverInput[] | NftClaimApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: NftClaimApprovalCreateOrConnectWithoutApproverInput | NftClaimApprovalCreateOrConnectWithoutApproverInput[]
    createMany?: NftClaimApprovalCreateManyApproverInputEnvelope
    connect?: NftClaimApprovalWhereUniqueInput | NftClaimApprovalWhereUniqueInput[]
  }

  export type AirdropSeasonCreateNestedManyWithoutCreatorInput = {
    create?: XOR<AirdropSeasonCreateWithoutCreatorInput, AirdropSeasonUncheckedCreateWithoutCreatorInput> | AirdropSeasonCreateWithoutCreatorInput[] | AirdropSeasonUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AirdropSeasonCreateOrConnectWithoutCreatorInput | AirdropSeasonCreateOrConnectWithoutCreatorInput[]
    createMany?: AirdropSeasonCreateManyCreatorInputEnvelope
    connect?: AirdropSeasonWhereUniqueInput | AirdropSeasonWhereUniqueInput[]
  }

  export type DailyEarningUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DailyEarningCreateWithoutUserInput, DailyEarningUncheckedCreateWithoutUserInput> | DailyEarningCreateWithoutUserInput[] | DailyEarningUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyEarningCreateOrConnectWithoutUserInput | DailyEarningCreateOrConnectWithoutUserInput[]
    createMany?: DailyEarningCreateManyUserInputEnvelope
    connect?: DailyEarningWhereUniqueInput | DailyEarningWhereUniqueInput[]
  }

  export type AirdropClaimUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AirdropClaimCreateWithoutUserInput, AirdropClaimUncheckedCreateWithoutUserInput> | AirdropClaimCreateWithoutUserInput[] | AirdropClaimUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AirdropClaimCreateOrConnectWithoutUserInput | AirdropClaimCreateOrConnectWithoutUserInput[]
    createMany?: AirdropClaimCreateManyUserInputEnvelope
    connect?: AirdropClaimWhereUniqueInput | AirdropClaimWhereUniqueInput[]
  }

  export type TwitterEngagementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TwitterEngagementCreateWithoutUserInput, TwitterEngagementUncheckedCreateWithoutUserInput> | TwitterEngagementCreateWithoutUserInput[] | TwitterEngagementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwitterEngagementCreateOrConnectWithoutUserInput | TwitterEngagementCreateOrConnectWithoutUserInput[]
    createMany?: TwitterEngagementCreateManyUserInputEnvelope
    connect?: TwitterEngagementWhereUniqueInput | TwitterEngagementWhereUniqueInput[]
  }

  export type TaskCompletionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskCompletionCreateWithoutUserInput, TaskCompletionUncheckedCreateWithoutUserInput> | TaskCompletionCreateWithoutUserInput[] | TaskCompletionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCompletionCreateOrConnectWithoutUserInput | TaskCompletionCreateOrConnectWithoutUserInput[]
    createMany?: TaskCompletionCreateManyUserInputEnvelope
    connect?: TaskCompletionWhereUniqueInput | TaskCompletionWhereUniqueInput[]
  }

  export type ClaimUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ClaimCreateWithoutUserInput, ClaimUncheckedCreateWithoutUserInput> | ClaimCreateWithoutUserInput[] | ClaimUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutUserInput | ClaimCreateOrConnectWithoutUserInput[]
    createMany?: ClaimCreateManyUserInputEnvelope
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
  }

  export type PointHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PointHistoryCreateWithoutUserInput, PointHistoryUncheckedCreateWithoutUserInput> | PointHistoryCreateWithoutUserInput[] | PointHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointHistoryCreateOrConnectWithoutUserInput | PointHistoryCreateOrConnectWithoutUserInput[]
    createMany?: PointHistoryCreateManyUserInputEnvelope
    connect?: PointHistoryWhereUniqueInput | PointHistoryWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutReferrerInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedOneWithoutReferredInput = {
    create?: XOR<ReferralCreateWithoutReferredInput, ReferralUncheckedCreateWithoutReferredInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredInput
    connect?: ReferralWhereUniqueInput
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AdminSessionUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminSessionCreateWithoutAdminInput, AdminSessionUncheckedCreateWithoutAdminInput> | AdminSessionCreateWithoutAdminInput[] | AdminSessionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminSessionCreateOrConnectWithoutAdminInput | AdminSessionCreateOrConnectWithoutAdminInput[]
    createMany?: AdminSessionCreateManyAdminInputEnvelope
    connect?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
  }

  export type AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput> | AdminAuditLogCreateWithoutAdminInput[] | AdminAuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminInput | AdminAuditLogCreateOrConnectWithoutAdminInput[]
    createMany?: AdminAuditLogCreateManyAdminInputEnvelope
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
  }

  export type FraudAlertUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FraudAlertCreateWithoutUserInput, FraudAlertUncheckedCreateWithoutUserInput> | FraudAlertCreateWithoutUserInput[] | FraudAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FraudAlertCreateOrConnectWithoutUserInput | FraudAlertCreateOrConnectWithoutUserInput[]
    createMany?: FraudAlertCreateManyUserInputEnvelope
    connect?: FraudAlertWhereUniqueInput | FraudAlertWhereUniqueInput[]
  }

  export type CampaignConfigUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CampaignConfigCreateWithoutCreatorInput, CampaignConfigUncheckedCreateWithoutCreatorInput> | CampaignConfigCreateWithoutCreatorInput[] | CampaignConfigUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CampaignConfigCreateOrConnectWithoutCreatorInput | CampaignConfigCreateOrConnectWithoutCreatorInput[]
    createMany?: CampaignConfigCreateManyCreatorInputEnvelope
    connect?: CampaignConfigWhereUniqueInput | CampaignConfigWhereUniqueInput[]
  }

  export type NftCollectionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<NftCollectionCreateWithoutCreatorInput, NftCollectionUncheckedCreateWithoutCreatorInput> | NftCollectionCreateWithoutCreatorInput[] | NftCollectionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: NftCollectionCreateOrConnectWithoutCreatorInput | NftCollectionCreateOrConnectWithoutCreatorInput[]
    createMany?: NftCollectionCreateManyCreatorInputEnvelope
    connect?: NftCollectionWhereUniqueInput | NftCollectionWhereUniqueInput[]
  }

  export type NftDistributionUncheckedCreateNestedManyWithoutDistributorInput = {
    create?: XOR<NftDistributionCreateWithoutDistributorInput, NftDistributionUncheckedCreateWithoutDistributorInput> | NftDistributionCreateWithoutDistributorInput[] | NftDistributionUncheckedCreateWithoutDistributorInput[]
    connectOrCreate?: NftDistributionCreateOrConnectWithoutDistributorInput | NftDistributionCreateOrConnectWithoutDistributorInput[]
    createMany?: NftDistributionCreateManyDistributorInputEnvelope
    connect?: NftDistributionWhereUniqueInput | NftDistributionWhereUniqueInput[]
  }

  export type UserNftHoldingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserNftHoldingCreateWithoutUserInput, UserNftHoldingUncheckedCreateWithoutUserInput> | UserNftHoldingCreateWithoutUserInput[] | UserNftHoldingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserNftHoldingCreateOrConnectWithoutUserInput | UserNftHoldingCreateOrConnectWithoutUserInput[]
    createMany?: UserNftHoldingCreateManyUserInputEnvelope
    connect?: UserNftHoldingWhereUniqueInput | UserNftHoldingWhereUniqueInput[]
  }

  export type NftClaimApprovalUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<NftClaimApprovalCreateWithoutUserInput, NftClaimApprovalUncheckedCreateWithoutUserInput>
    connectOrCreate?: NftClaimApprovalCreateOrConnectWithoutUserInput
    connect?: NftClaimApprovalWhereUniqueInput
  }

  export type NftClaimApprovalUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<NftClaimApprovalCreateWithoutApproverInput, NftClaimApprovalUncheckedCreateWithoutApproverInput> | NftClaimApprovalCreateWithoutApproverInput[] | NftClaimApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: NftClaimApprovalCreateOrConnectWithoutApproverInput | NftClaimApprovalCreateOrConnectWithoutApproverInput[]
    createMany?: NftClaimApprovalCreateManyApproverInputEnvelope
    connect?: NftClaimApprovalWhereUniqueInput | NftClaimApprovalWhereUniqueInput[]
  }

  export type AirdropSeasonUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<AirdropSeasonCreateWithoutCreatorInput, AirdropSeasonUncheckedCreateWithoutCreatorInput> | AirdropSeasonCreateWithoutCreatorInput[] | AirdropSeasonUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AirdropSeasonCreateOrConnectWithoutCreatorInput | AirdropSeasonCreateOrConnectWithoutCreatorInput[]
    createMany?: AirdropSeasonCreateManyCreatorInputEnvelope
    connect?: AirdropSeasonWhereUniqueInput | AirdropSeasonWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumTwitterActivityFieldUpdateOperationsInput = {
    set?: $Enums.TwitterActivity | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdatesuspiciousFlagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type DailyEarningUpdateManyWithoutUserNestedInput = {
    create?: XOR<DailyEarningCreateWithoutUserInput, DailyEarningUncheckedCreateWithoutUserInput> | DailyEarningCreateWithoutUserInput[] | DailyEarningUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyEarningCreateOrConnectWithoutUserInput | DailyEarningCreateOrConnectWithoutUserInput[]
    upsert?: DailyEarningUpsertWithWhereUniqueWithoutUserInput | DailyEarningUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DailyEarningCreateManyUserInputEnvelope
    set?: DailyEarningWhereUniqueInput | DailyEarningWhereUniqueInput[]
    disconnect?: DailyEarningWhereUniqueInput | DailyEarningWhereUniqueInput[]
    delete?: DailyEarningWhereUniqueInput | DailyEarningWhereUniqueInput[]
    connect?: DailyEarningWhereUniqueInput | DailyEarningWhereUniqueInput[]
    update?: DailyEarningUpdateWithWhereUniqueWithoutUserInput | DailyEarningUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DailyEarningUpdateManyWithWhereWithoutUserInput | DailyEarningUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DailyEarningScalarWhereInput | DailyEarningScalarWhereInput[]
  }

  export type AirdropClaimUpdateManyWithoutUserNestedInput = {
    create?: XOR<AirdropClaimCreateWithoutUserInput, AirdropClaimUncheckedCreateWithoutUserInput> | AirdropClaimCreateWithoutUserInput[] | AirdropClaimUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AirdropClaimCreateOrConnectWithoutUserInput | AirdropClaimCreateOrConnectWithoutUserInput[]
    upsert?: AirdropClaimUpsertWithWhereUniqueWithoutUserInput | AirdropClaimUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AirdropClaimCreateManyUserInputEnvelope
    set?: AirdropClaimWhereUniqueInput | AirdropClaimWhereUniqueInput[]
    disconnect?: AirdropClaimWhereUniqueInput | AirdropClaimWhereUniqueInput[]
    delete?: AirdropClaimWhereUniqueInput | AirdropClaimWhereUniqueInput[]
    connect?: AirdropClaimWhereUniqueInput | AirdropClaimWhereUniqueInput[]
    update?: AirdropClaimUpdateWithWhereUniqueWithoutUserInput | AirdropClaimUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AirdropClaimUpdateManyWithWhereWithoutUserInput | AirdropClaimUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AirdropClaimScalarWhereInput | AirdropClaimScalarWhereInput[]
  }

  export type TwitterEngagementUpdateManyWithoutUserNestedInput = {
    create?: XOR<TwitterEngagementCreateWithoutUserInput, TwitterEngagementUncheckedCreateWithoutUserInput> | TwitterEngagementCreateWithoutUserInput[] | TwitterEngagementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwitterEngagementCreateOrConnectWithoutUserInput | TwitterEngagementCreateOrConnectWithoutUserInput[]
    upsert?: TwitterEngagementUpsertWithWhereUniqueWithoutUserInput | TwitterEngagementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TwitterEngagementCreateManyUserInputEnvelope
    set?: TwitterEngagementWhereUniqueInput | TwitterEngagementWhereUniqueInput[]
    disconnect?: TwitterEngagementWhereUniqueInput | TwitterEngagementWhereUniqueInput[]
    delete?: TwitterEngagementWhereUniqueInput | TwitterEngagementWhereUniqueInput[]
    connect?: TwitterEngagementWhereUniqueInput | TwitterEngagementWhereUniqueInput[]
    update?: TwitterEngagementUpdateWithWhereUniqueWithoutUserInput | TwitterEngagementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TwitterEngagementUpdateManyWithWhereWithoutUserInput | TwitterEngagementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TwitterEngagementScalarWhereInput | TwitterEngagementScalarWhereInput[]
  }

  export type TaskCompletionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskCompletionCreateWithoutUserInput, TaskCompletionUncheckedCreateWithoutUserInput> | TaskCompletionCreateWithoutUserInput[] | TaskCompletionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCompletionCreateOrConnectWithoutUserInput | TaskCompletionCreateOrConnectWithoutUserInput[]
    upsert?: TaskCompletionUpsertWithWhereUniqueWithoutUserInput | TaskCompletionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskCompletionCreateManyUserInputEnvelope
    set?: TaskCompletionWhereUniqueInput | TaskCompletionWhereUniqueInput[]
    disconnect?: TaskCompletionWhereUniqueInput | TaskCompletionWhereUniqueInput[]
    delete?: TaskCompletionWhereUniqueInput | TaskCompletionWhereUniqueInput[]
    connect?: TaskCompletionWhereUniqueInput | TaskCompletionWhereUniqueInput[]
    update?: TaskCompletionUpdateWithWhereUniqueWithoutUserInput | TaskCompletionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskCompletionUpdateManyWithWhereWithoutUserInput | TaskCompletionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskCompletionScalarWhereInput | TaskCompletionScalarWhereInput[]
  }

  export type ClaimUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClaimCreateWithoutUserInput, ClaimUncheckedCreateWithoutUserInput> | ClaimCreateWithoutUserInput[] | ClaimUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutUserInput | ClaimCreateOrConnectWithoutUserInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutUserInput | ClaimUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClaimCreateManyUserInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutUserInput | ClaimUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutUserInput | ClaimUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type PointHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<PointHistoryCreateWithoutUserInput, PointHistoryUncheckedCreateWithoutUserInput> | PointHistoryCreateWithoutUserInput[] | PointHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointHistoryCreateOrConnectWithoutUserInput | PointHistoryCreateOrConnectWithoutUserInput[]
    upsert?: PointHistoryUpsertWithWhereUniqueWithoutUserInput | PointHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PointHistoryCreateManyUserInputEnvelope
    set?: PointHistoryWhereUniqueInput | PointHistoryWhereUniqueInput[]
    disconnect?: PointHistoryWhereUniqueInput | PointHistoryWhereUniqueInput[]
    delete?: PointHistoryWhereUniqueInput | PointHistoryWhereUniqueInput[]
    connect?: PointHistoryWhereUniqueInput | PointHistoryWhereUniqueInput[]
    update?: PointHistoryUpdateWithWhereUniqueWithoutUserInput | PointHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PointHistoryUpdateManyWithWhereWithoutUserInput | PointHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PointHistoryScalarWhereInput | PointHistoryScalarWhereInput[]
  }

  export type ReferralUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferrerInput | ReferralUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferrerInput | ReferralUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferrerInput | ReferralUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUpdateOneWithoutReferredNestedInput = {
    create?: XOR<ReferralCreateWithoutReferredInput, ReferralUncheckedCreateWithoutReferredInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredInput
    upsert?: ReferralUpsertWithoutReferredInput
    disconnect?: ReferralWhereInput | boolean
    delete?: ReferralWhereInput | boolean
    connect?: ReferralWhereUniqueInput
    update?: XOR<XOR<ReferralUpdateToOneWithWhereWithoutReferredInput, ReferralUpdateWithoutReferredInput>, ReferralUncheckedUpdateWithoutReferredInput>
  }

  export type UserAchievementUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AdminSessionUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminSessionCreateWithoutAdminInput, AdminSessionUncheckedCreateWithoutAdminInput> | AdminSessionCreateWithoutAdminInput[] | AdminSessionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminSessionCreateOrConnectWithoutAdminInput | AdminSessionCreateOrConnectWithoutAdminInput[]
    upsert?: AdminSessionUpsertWithWhereUniqueWithoutAdminInput | AdminSessionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminSessionCreateManyAdminInputEnvelope
    set?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    disconnect?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    delete?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    connect?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    update?: AdminSessionUpdateWithWhereUniqueWithoutAdminInput | AdminSessionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminSessionUpdateManyWithWhereWithoutAdminInput | AdminSessionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminSessionScalarWhereInput | AdminSessionScalarWhereInput[]
  }

  export type AdminAuditLogUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput> | AdminAuditLogCreateWithoutAdminInput[] | AdminAuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminInput | AdminAuditLogCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput | AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAuditLogCreateManyAdminInputEnvelope
    set?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    disconnect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    delete?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    update?: AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput | AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAuditLogUpdateManyWithWhereWithoutAdminInput | AdminAuditLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
  }

  export type FraudAlertUpdateManyWithoutUserNestedInput = {
    create?: XOR<FraudAlertCreateWithoutUserInput, FraudAlertUncheckedCreateWithoutUserInput> | FraudAlertCreateWithoutUserInput[] | FraudAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FraudAlertCreateOrConnectWithoutUserInput | FraudAlertCreateOrConnectWithoutUserInput[]
    upsert?: FraudAlertUpsertWithWhereUniqueWithoutUserInput | FraudAlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FraudAlertCreateManyUserInputEnvelope
    set?: FraudAlertWhereUniqueInput | FraudAlertWhereUniqueInput[]
    disconnect?: FraudAlertWhereUniqueInput | FraudAlertWhereUniqueInput[]
    delete?: FraudAlertWhereUniqueInput | FraudAlertWhereUniqueInput[]
    connect?: FraudAlertWhereUniqueInput | FraudAlertWhereUniqueInput[]
    update?: FraudAlertUpdateWithWhereUniqueWithoutUserInput | FraudAlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FraudAlertUpdateManyWithWhereWithoutUserInput | FraudAlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FraudAlertScalarWhereInput | FraudAlertScalarWhereInput[]
  }

  export type CampaignConfigUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CampaignConfigCreateWithoutCreatorInput, CampaignConfigUncheckedCreateWithoutCreatorInput> | CampaignConfigCreateWithoutCreatorInput[] | CampaignConfigUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CampaignConfigCreateOrConnectWithoutCreatorInput | CampaignConfigCreateOrConnectWithoutCreatorInput[]
    upsert?: CampaignConfigUpsertWithWhereUniqueWithoutCreatorInput | CampaignConfigUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CampaignConfigCreateManyCreatorInputEnvelope
    set?: CampaignConfigWhereUniqueInput | CampaignConfigWhereUniqueInput[]
    disconnect?: CampaignConfigWhereUniqueInput | CampaignConfigWhereUniqueInput[]
    delete?: CampaignConfigWhereUniqueInput | CampaignConfigWhereUniqueInput[]
    connect?: CampaignConfigWhereUniqueInput | CampaignConfigWhereUniqueInput[]
    update?: CampaignConfigUpdateWithWhereUniqueWithoutCreatorInput | CampaignConfigUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CampaignConfigUpdateManyWithWhereWithoutCreatorInput | CampaignConfigUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CampaignConfigScalarWhereInput | CampaignConfigScalarWhereInput[]
  }

  export type NftCollectionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<NftCollectionCreateWithoutCreatorInput, NftCollectionUncheckedCreateWithoutCreatorInput> | NftCollectionCreateWithoutCreatorInput[] | NftCollectionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: NftCollectionCreateOrConnectWithoutCreatorInput | NftCollectionCreateOrConnectWithoutCreatorInput[]
    upsert?: NftCollectionUpsertWithWhereUniqueWithoutCreatorInput | NftCollectionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: NftCollectionCreateManyCreatorInputEnvelope
    set?: NftCollectionWhereUniqueInput | NftCollectionWhereUniqueInput[]
    disconnect?: NftCollectionWhereUniqueInput | NftCollectionWhereUniqueInput[]
    delete?: NftCollectionWhereUniqueInput | NftCollectionWhereUniqueInput[]
    connect?: NftCollectionWhereUniqueInput | NftCollectionWhereUniqueInput[]
    update?: NftCollectionUpdateWithWhereUniqueWithoutCreatorInput | NftCollectionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: NftCollectionUpdateManyWithWhereWithoutCreatorInput | NftCollectionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: NftCollectionScalarWhereInput | NftCollectionScalarWhereInput[]
  }

  export type NftDistributionUpdateManyWithoutDistributorNestedInput = {
    create?: XOR<NftDistributionCreateWithoutDistributorInput, NftDistributionUncheckedCreateWithoutDistributorInput> | NftDistributionCreateWithoutDistributorInput[] | NftDistributionUncheckedCreateWithoutDistributorInput[]
    connectOrCreate?: NftDistributionCreateOrConnectWithoutDistributorInput | NftDistributionCreateOrConnectWithoutDistributorInput[]
    upsert?: NftDistributionUpsertWithWhereUniqueWithoutDistributorInput | NftDistributionUpsertWithWhereUniqueWithoutDistributorInput[]
    createMany?: NftDistributionCreateManyDistributorInputEnvelope
    set?: NftDistributionWhereUniqueInput | NftDistributionWhereUniqueInput[]
    disconnect?: NftDistributionWhereUniqueInput | NftDistributionWhereUniqueInput[]
    delete?: NftDistributionWhereUniqueInput | NftDistributionWhereUniqueInput[]
    connect?: NftDistributionWhereUniqueInput | NftDistributionWhereUniqueInput[]
    update?: NftDistributionUpdateWithWhereUniqueWithoutDistributorInput | NftDistributionUpdateWithWhereUniqueWithoutDistributorInput[]
    updateMany?: NftDistributionUpdateManyWithWhereWithoutDistributorInput | NftDistributionUpdateManyWithWhereWithoutDistributorInput[]
    deleteMany?: NftDistributionScalarWhereInput | NftDistributionScalarWhereInput[]
  }

  export type UserNftHoldingUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserNftHoldingCreateWithoutUserInput, UserNftHoldingUncheckedCreateWithoutUserInput> | UserNftHoldingCreateWithoutUserInput[] | UserNftHoldingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserNftHoldingCreateOrConnectWithoutUserInput | UserNftHoldingCreateOrConnectWithoutUserInput[]
    upsert?: UserNftHoldingUpsertWithWhereUniqueWithoutUserInput | UserNftHoldingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserNftHoldingCreateManyUserInputEnvelope
    set?: UserNftHoldingWhereUniqueInput | UserNftHoldingWhereUniqueInput[]
    disconnect?: UserNftHoldingWhereUniqueInput | UserNftHoldingWhereUniqueInput[]
    delete?: UserNftHoldingWhereUniqueInput | UserNftHoldingWhereUniqueInput[]
    connect?: UserNftHoldingWhereUniqueInput | UserNftHoldingWhereUniqueInput[]
    update?: UserNftHoldingUpdateWithWhereUniqueWithoutUserInput | UserNftHoldingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserNftHoldingUpdateManyWithWhereWithoutUserInput | UserNftHoldingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserNftHoldingScalarWhereInput | UserNftHoldingScalarWhereInput[]
  }

  export type NftClaimApprovalUpdateOneWithoutUserNestedInput = {
    create?: XOR<NftClaimApprovalCreateWithoutUserInput, NftClaimApprovalUncheckedCreateWithoutUserInput>
    connectOrCreate?: NftClaimApprovalCreateOrConnectWithoutUserInput
    upsert?: NftClaimApprovalUpsertWithoutUserInput
    disconnect?: NftClaimApprovalWhereInput | boolean
    delete?: NftClaimApprovalWhereInput | boolean
    connect?: NftClaimApprovalWhereUniqueInput
    update?: XOR<XOR<NftClaimApprovalUpdateToOneWithWhereWithoutUserInput, NftClaimApprovalUpdateWithoutUserInput>, NftClaimApprovalUncheckedUpdateWithoutUserInput>
  }

  export type NftClaimApprovalUpdateManyWithoutApproverNestedInput = {
    create?: XOR<NftClaimApprovalCreateWithoutApproverInput, NftClaimApprovalUncheckedCreateWithoutApproverInput> | NftClaimApprovalCreateWithoutApproverInput[] | NftClaimApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: NftClaimApprovalCreateOrConnectWithoutApproverInput | NftClaimApprovalCreateOrConnectWithoutApproverInput[]
    upsert?: NftClaimApprovalUpsertWithWhereUniqueWithoutApproverInput | NftClaimApprovalUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: NftClaimApprovalCreateManyApproverInputEnvelope
    set?: NftClaimApprovalWhereUniqueInput | NftClaimApprovalWhereUniqueInput[]
    disconnect?: NftClaimApprovalWhereUniqueInput | NftClaimApprovalWhereUniqueInput[]
    delete?: NftClaimApprovalWhereUniqueInput | NftClaimApprovalWhereUniqueInput[]
    connect?: NftClaimApprovalWhereUniqueInput | NftClaimApprovalWhereUniqueInput[]
    update?: NftClaimApprovalUpdateWithWhereUniqueWithoutApproverInput | NftClaimApprovalUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: NftClaimApprovalUpdateManyWithWhereWithoutApproverInput | NftClaimApprovalUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: NftClaimApprovalScalarWhereInput | NftClaimApprovalScalarWhereInput[]
  }

  export type AirdropSeasonUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<AirdropSeasonCreateWithoutCreatorInput, AirdropSeasonUncheckedCreateWithoutCreatorInput> | AirdropSeasonCreateWithoutCreatorInput[] | AirdropSeasonUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AirdropSeasonCreateOrConnectWithoutCreatorInput | AirdropSeasonCreateOrConnectWithoutCreatorInput[]
    upsert?: AirdropSeasonUpsertWithWhereUniqueWithoutCreatorInput | AirdropSeasonUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: AirdropSeasonCreateManyCreatorInputEnvelope
    set?: AirdropSeasonWhereUniqueInput | AirdropSeasonWhereUniqueInput[]
    disconnect?: AirdropSeasonWhereUniqueInput | AirdropSeasonWhereUniqueInput[]
    delete?: AirdropSeasonWhereUniqueInput | AirdropSeasonWhereUniqueInput[]
    connect?: AirdropSeasonWhereUniqueInput | AirdropSeasonWhereUniqueInput[]
    update?: AirdropSeasonUpdateWithWhereUniqueWithoutCreatorInput | AirdropSeasonUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: AirdropSeasonUpdateManyWithWhereWithoutCreatorInput | AirdropSeasonUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: AirdropSeasonScalarWhereInput | AirdropSeasonScalarWhereInput[]
  }

  export type DailyEarningUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DailyEarningCreateWithoutUserInput, DailyEarningUncheckedCreateWithoutUserInput> | DailyEarningCreateWithoutUserInput[] | DailyEarningUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DailyEarningCreateOrConnectWithoutUserInput | DailyEarningCreateOrConnectWithoutUserInput[]
    upsert?: DailyEarningUpsertWithWhereUniqueWithoutUserInput | DailyEarningUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DailyEarningCreateManyUserInputEnvelope
    set?: DailyEarningWhereUniqueInput | DailyEarningWhereUniqueInput[]
    disconnect?: DailyEarningWhereUniqueInput | DailyEarningWhereUniqueInput[]
    delete?: DailyEarningWhereUniqueInput | DailyEarningWhereUniqueInput[]
    connect?: DailyEarningWhereUniqueInput | DailyEarningWhereUniqueInput[]
    update?: DailyEarningUpdateWithWhereUniqueWithoutUserInput | DailyEarningUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DailyEarningUpdateManyWithWhereWithoutUserInput | DailyEarningUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DailyEarningScalarWhereInput | DailyEarningScalarWhereInput[]
  }

  export type AirdropClaimUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AirdropClaimCreateWithoutUserInput, AirdropClaimUncheckedCreateWithoutUserInput> | AirdropClaimCreateWithoutUserInput[] | AirdropClaimUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AirdropClaimCreateOrConnectWithoutUserInput | AirdropClaimCreateOrConnectWithoutUserInput[]
    upsert?: AirdropClaimUpsertWithWhereUniqueWithoutUserInput | AirdropClaimUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AirdropClaimCreateManyUserInputEnvelope
    set?: AirdropClaimWhereUniqueInput | AirdropClaimWhereUniqueInput[]
    disconnect?: AirdropClaimWhereUniqueInput | AirdropClaimWhereUniqueInput[]
    delete?: AirdropClaimWhereUniqueInput | AirdropClaimWhereUniqueInput[]
    connect?: AirdropClaimWhereUniqueInput | AirdropClaimWhereUniqueInput[]
    update?: AirdropClaimUpdateWithWhereUniqueWithoutUserInput | AirdropClaimUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AirdropClaimUpdateManyWithWhereWithoutUserInput | AirdropClaimUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AirdropClaimScalarWhereInput | AirdropClaimScalarWhereInput[]
  }

  export type TwitterEngagementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TwitterEngagementCreateWithoutUserInput, TwitterEngagementUncheckedCreateWithoutUserInput> | TwitterEngagementCreateWithoutUserInput[] | TwitterEngagementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TwitterEngagementCreateOrConnectWithoutUserInput | TwitterEngagementCreateOrConnectWithoutUserInput[]
    upsert?: TwitterEngagementUpsertWithWhereUniqueWithoutUserInput | TwitterEngagementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TwitterEngagementCreateManyUserInputEnvelope
    set?: TwitterEngagementWhereUniqueInput | TwitterEngagementWhereUniqueInput[]
    disconnect?: TwitterEngagementWhereUniqueInput | TwitterEngagementWhereUniqueInput[]
    delete?: TwitterEngagementWhereUniqueInput | TwitterEngagementWhereUniqueInput[]
    connect?: TwitterEngagementWhereUniqueInput | TwitterEngagementWhereUniqueInput[]
    update?: TwitterEngagementUpdateWithWhereUniqueWithoutUserInput | TwitterEngagementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TwitterEngagementUpdateManyWithWhereWithoutUserInput | TwitterEngagementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TwitterEngagementScalarWhereInput | TwitterEngagementScalarWhereInput[]
  }

  export type TaskCompletionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskCompletionCreateWithoutUserInput, TaskCompletionUncheckedCreateWithoutUserInput> | TaskCompletionCreateWithoutUserInput[] | TaskCompletionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCompletionCreateOrConnectWithoutUserInput | TaskCompletionCreateOrConnectWithoutUserInput[]
    upsert?: TaskCompletionUpsertWithWhereUniqueWithoutUserInput | TaskCompletionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskCompletionCreateManyUserInputEnvelope
    set?: TaskCompletionWhereUniqueInput | TaskCompletionWhereUniqueInput[]
    disconnect?: TaskCompletionWhereUniqueInput | TaskCompletionWhereUniqueInput[]
    delete?: TaskCompletionWhereUniqueInput | TaskCompletionWhereUniqueInput[]
    connect?: TaskCompletionWhereUniqueInput | TaskCompletionWhereUniqueInput[]
    update?: TaskCompletionUpdateWithWhereUniqueWithoutUserInput | TaskCompletionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskCompletionUpdateManyWithWhereWithoutUserInput | TaskCompletionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskCompletionScalarWhereInput | TaskCompletionScalarWhereInput[]
  }

  export type ClaimUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ClaimCreateWithoutUserInput, ClaimUncheckedCreateWithoutUserInput> | ClaimCreateWithoutUserInput[] | ClaimUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ClaimCreateOrConnectWithoutUserInput | ClaimCreateOrConnectWithoutUserInput[]
    upsert?: ClaimUpsertWithWhereUniqueWithoutUserInput | ClaimUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ClaimCreateManyUserInputEnvelope
    set?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    disconnect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    delete?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    connect?: ClaimWhereUniqueInput | ClaimWhereUniqueInput[]
    update?: ClaimUpdateWithWhereUniqueWithoutUserInput | ClaimUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ClaimUpdateManyWithWhereWithoutUserInput | ClaimUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
  }

  export type PointHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PointHistoryCreateWithoutUserInput, PointHistoryUncheckedCreateWithoutUserInput> | PointHistoryCreateWithoutUserInput[] | PointHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PointHistoryCreateOrConnectWithoutUserInput | PointHistoryCreateOrConnectWithoutUserInput[]
    upsert?: PointHistoryUpsertWithWhereUniqueWithoutUserInput | PointHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PointHistoryCreateManyUserInputEnvelope
    set?: PointHistoryWhereUniqueInput | PointHistoryWhereUniqueInput[]
    disconnect?: PointHistoryWhereUniqueInput | PointHistoryWhereUniqueInput[]
    delete?: PointHistoryWhereUniqueInput | PointHistoryWhereUniqueInput[]
    connect?: PointHistoryWhereUniqueInput | PointHistoryWhereUniqueInput[]
    update?: PointHistoryUpdateWithWhereUniqueWithoutUserInput | PointHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PointHistoryUpdateManyWithWhereWithoutUserInput | PointHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PointHistoryScalarWhereInput | PointHistoryScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutReferrerNestedInput = {
    create?: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput> | ReferralCreateWithoutReferrerInput[] | ReferralUncheckedCreateWithoutReferrerInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferrerInput | ReferralCreateOrConnectWithoutReferrerInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferrerInput | ReferralUpsertWithWhereUniqueWithoutReferrerInput[]
    createMany?: ReferralCreateManyReferrerInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferrerInput | ReferralUpdateWithWhereUniqueWithoutReferrerInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferrerInput | ReferralUpdateManyWithWhereWithoutReferrerInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateOneWithoutReferredNestedInput = {
    create?: XOR<ReferralCreateWithoutReferredInput, ReferralUncheckedCreateWithoutReferredInput>
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredInput
    upsert?: ReferralUpsertWithoutReferredInput
    disconnect?: ReferralWhereInput | boolean
    delete?: ReferralWhereInput | boolean
    connect?: ReferralWhereUniqueInput
    update?: XOR<XOR<ReferralUpdateToOneWithWhereWithoutReferredInput, ReferralUpdateWithoutReferredInput>, ReferralUncheckedUpdateWithoutReferredInput>
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AdminSessionUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminSessionCreateWithoutAdminInput, AdminSessionUncheckedCreateWithoutAdminInput> | AdminSessionCreateWithoutAdminInput[] | AdminSessionUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminSessionCreateOrConnectWithoutAdminInput | AdminSessionCreateOrConnectWithoutAdminInput[]
    upsert?: AdminSessionUpsertWithWhereUniqueWithoutAdminInput | AdminSessionUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminSessionCreateManyAdminInputEnvelope
    set?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    disconnect?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    delete?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    connect?: AdminSessionWhereUniqueInput | AdminSessionWhereUniqueInput[]
    update?: AdminSessionUpdateWithWhereUniqueWithoutAdminInput | AdminSessionUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminSessionUpdateManyWithWhereWithoutAdminInput | AdminSessionUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminSessionScalarWhereInput | AdminSessionScalarWhereInput[]
  }

  export type AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput> | AdminAuditLogCreateWithoutAdminInput[] | AdminAuditLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutAdminInput | AdminAuditLogCreateOrConnectWithoutAdminInput[]
    upsert?: AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput | AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminAuditLogCreateManyAdminInputEnvelope
    set?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    disconnect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    delete?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    update?: AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput | AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminAuditLogUpdateManyWithWhereWithoutAdminInput | AdminAuditLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
  }

  export type FraudAlertUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FraudAlertCreateWithoutUserInput, FraudAlertUncheckedCreateWithoutUserInput> | FraudAlertCreateWithoutUserInput[] | FraudAlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FraudAlertCreateOrConnectWithoutUserInput | FraudAlertCreateOrConnectWithoutUserInput[]
    upsert?: FraudAlertUpsertWithWhereUniqueWithoutUserInput | FraudAlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FraudAlertCreateManyUserInputEnvelope
    set?: FraudAlertWhereUniqueInput | FraudAlertWhereUniqueInput[]
    disconnect?: FraudAlertWhereUniqueInput | FraudAlertWhereUniqueInput[]
    delete?: FraudAlertWhereUniqueInput | FraudAlertWhereUniqueInput[]
    connect?: FraudAlertWhereUniqueInput | FraudAlertWhereUniqueInput[]
    update?: FraudAlertUpdateWithWhereUniqueWithoutUserInput | FraudAlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FraudAlertUpdateManyWithWhereWithoutUserInput | FraudAlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FraudAlertScalarWhereInput | FraudAlertScalarWhereInput[]
  }

  export type CampaignConfigUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CampaignConfigCreateWithoutCreatorInput, CampaignConfigUncheckedCreateWithoutCreatorInput> | CampaignConfigCreateWithoutCreatorInput[] | CampaignConfigUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CampaignConfigCreateOrConnectWithoutCreatorInput | CampaignConfigCreateOrConnectWithoutCreatorInput[]
    upsert?: CampaignConfigUpsertWithWhereUniqueWithoutCreatorInput | CampaignConfigUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CampaignConfigCreateManyCreatorInputEnvelope
    set?: CampaignConfigWhereUniqueInput | CampaignConfigWhereUniqueInput[]
    disconnect?: CampaignConfigWhereUniqueInput | CampaignConfigWhereUniqueInput[]
    delete?: CampaignConfigWhereUniqueInput | CampaignConfigWhereUniqueInput[]
    connect?: CampaignConfigWhereUniqueInput | CampaignConfigWhereUniqueInput[]
    update?: CampaignConfigUpdateWithWhereUniqueWithoutCreatorInput | CampaignConfigUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CampaignConfigUpdateManyWithWhereWithoutCreatorInput | CampaignConfigUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CampaignConfigScalarWhereInput | CampaignConfigScalarWhereInput[]
  }

  export type NftCollectionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<NftCollectionCreateWithoutCreatorInput, NftCollectionUncheckedCreateWithoutCreatorInput> | NftCollectionCreateWithoutCreatorInput[] | NftCollectionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: NftCollectionCreateOrConnectWithoutCreatorInput | NftCollectionCreateOrConnectWithoutCreatorInput[]
    upsert?: NftCollectionUpsertWithWhereUniqueWithoutCreatorInput | NftCollectionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: NftCollectionCreateManyCreatorInputEnvelope
    set?: NftCollectionWhereUniqueInput | NftCollectionWhereUniqueInput[]
    disconnect?: NftCollectionWhereUniqueInput | NftCollectionWhereUniqueInput[]
    delete?: NftCollectionWhereUniqueInput | NftCollectionWhereUniqueInput[]
    connect?: NftCollectionWhereUniqueInput | NftCollectionWhereUniqueInput[]
    update?: NftCollectionUpdateWithWhereUniqueWithoutCreatorInput | NftCollectionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: NftCollectionUpdateManyWithWhereWithoutCreatorInput | NftCollectionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: NftCollectionScalarWhereInput | NftCollectionScalarWhereInput[]
  }

  export type NftDistributionUncheckedUpdateManyWithoutDistributorNestedInput = {
    create?: XOR<NftDistributionCreateWithoutDistributorInput, NftDistributionUncheckedCreateWithoutDistributorInput> | NftDistributionCreateWithoutDistributorInput[] | NftDistributionUncheckedCreateWithoutDistributorInput[]
    connectOrCreate?: NftDistributionCreateOrConnectWithoutDistributorInput | NftDistributionCreateOrConnectWithoutDistributorInput[]
    upsert?: NftDistributionUpsertWithWhereUniqueWithoutDistributorInput | NftDistributionUpsertWithWhereUniqueWithoutDistributorInput[]
    createMany?: NftDistributionCreateManyDistributorInputEnvelope
    set?: NftDistributionWhereUniqueInput | NftDistributionWhereUniqueInput[]
    disconnect?: NftDistributionWhereUniqueInput | NftDistributionWhereUniqueInput[]
    delete?: NftDistributionWhereUniqueInput | NftDistributionWhereUniqueInput[]
    connect?: NftDistributionWhereUniqueInput | NftDistributionWhereUniqueInput[]
    update?: NftDistributionUpdateWithWhereUniqueWithoutDistributorInput | NftDistributionUpdateWithWhereUniqueWithoutDistributorInput[]
    updateMany?: NftDistributionUpdateManyWithWhereWithoutDistributorInput | NftDistributionUpdateManyWithWhereWithoutDistributorInput[]
    deleteMany?: NftDistributionScalarWhereInput | NftDistributionScalarWhereInput[]
  }

  export type UserNftHoldingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserNftHoldingCreateWithoutUserInput, UserNftHoldingUncheckedCreateWithoutUserInput> | UserNftHoldingCreateWithoutUserInput[] | UserNftHoldingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserNftHoldingCreateOrConnectWithoutUserInput | UserNftHoldingCreateOrConnectWithoutUserInput[]
    upsert?: UserNftHoldingUpsertWithWhereUniqueWithoutUserInput | UserNftHoldingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserNftHoldingCreateManyUserInputEnvelope
    set?: UserNftHoldingWhereUniqueInput | UserNftHoldingWhereUniqueInput[]
    disconnect?: UserNftHoldingWhereUniqueInput | UserNftHoldingWhereUniqueInput[]
    delete?: UserNftHoldingWhereUniqueInput | UserNftHoldingWhereUniqueInput[]
    connect?: UserNftHoldingWhereUniqueInput | UserNftHoldingWhereUniqueInput[]
    update?: UserNftHoldingUpdateWithWhereUniqueWithoutUserInput | UserNftHoldingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserNftHoldingUpdateManyWithWhereWithoutUserInput | UserNftHoldingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserNftHoldingScalarWhereInput | UserNftHoldingScalarWhereInput[]
  }

  export type NftClaimApprovalUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<NftClaimApprovalCreateWithoutUserInput, NftClaimApprovalUncheckedCreateWithoutUserInput>
    connectOrCreate?: NftClaimApprovalCreateOrConnectWithoutUserInput
    upsert?: NftClaimApprovalUpsertWithoutUserInput
    disconnect?: NftClaimApprovalWhereInput | boolean
    delete?: NftClaimApprovalWhereInput | boolean
    connect?: NftClaimApprovalWhereUniqueInput
    update?: XOR<XOR<NftClaimApprovalUpdateToOneWithWhereWithoutUserInput, NftClaimApprovalUpdateWithoutUserInput>, NftClaimApprovalUncheckedUpdateWithoutUserInput>
  }

  export type NftClaimApprovalUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<NftClaimApprovalCreateWithoutApproverInput, NftClaimApprovalUncheckedCreateWithoutApproverInput> | NftClaimApprovalCreateWithoutApproverInput[] | NftClaimApprovalUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: NftClaimApprovalCreateOrConnectWithoutApproverInput | NftClaimApprovalCreateOrConnectWithoutApproverInput[]
    upsert?: NftClaimApprovalUpsertWithWhereUniqueWithoutApproverInput | NftClaimApprovalUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: NftClaimApprovalCreateManyApproverInputEnvelope
    set?: NftClaimApprovalWhereUniqueInput | NftClaimApprovalWhereUniqueInput[]
    disconnect?: NftClaimApprovalWhereUniqueInput | NftClaimApprovalWhereUniqueInput[]
    delete?: NftClaimApprovalWhereUniqueInput | NftClaimApprovalWhereUniqueInput[]
    connect?: NftClaimApprovalWhereUniqueInput | NftClaimApprovalWhereUniqueInput[]
    update?: NftClaimApprovalUpdateWithWhereUniqueWithoutApproverInput | NftClaimApprovalUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: NftClaimApprovalUpdateManyWithWhereWithoutApproverInput | NftClaimApprovalUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: NftClaimApprovalScalarWhereInput | NftClaimApprovalScalarWhereInput[]
  }

  export type AirdropSeasonUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<AirdropSeasonCreateWithoutCreatorInput, AirdropSeasonUncheckedCreateWithoutCreatorInput> | AirdropSeasonCreateWithoutCreatorInput[] | AirdropSeasonUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: AirdropSeasonCreateOrConnectWithoutCreatorInput | AirdropSeasonCreateOrConnectWithoutCreatorInput[]
    upsert?: AirdropSeasonUpsertWithWhereUniqueWithoutCreatorInput | AirdropSeasonUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: AirdropSeasonCreateManyCreatorInputEnvelope
    set?: AirdropSeasonWhereUniqueInput | AirdropSeasonWhereUniqueInput[]
    disconnect?: AirdropSeasonWhereUniqueInput | AirdropSeasonWhereUniqueInput[]
    delete?: AirdropSeasonWhereUniqueInput | AirdropSeasonWhereUniqueInput[]
    connect?: AirdropSeasonWhereUniqueInput | AirdropSeasonWhereUniqueInput[]
    update?: AirdropSeasonUpdateWithWhereUniqueWithoutCreatorInput | AirdropSeasonUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: AirdropSeasonUpdateManyWithWhereWithoutCreatorInput | AirdropSeasonUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: AirdropSeasonScalarWhereInput | AirdropSeasonScalarWhereInput[]
  }

  export type UserAchievementCreateNestedManyWithoutAchievementInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutAchievementInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type UserAchievementUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutAchievementInput | UserAchievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutAchievementInput | UserAchievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutAchievementInput | UserAchievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserAchievementUncheckedUpdateManyWithoutAchievementNestedInput = {
    create?: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput> | UserAchievementCreateWithoutAchievementInput[] | UserAchievementUncheckedCreateWithoutAchievementInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutAchievementInput | UserAchievementCreateOrConnectWithoutAchievementInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutAchievementInput | UserAchievementUpsertWithWhereUniqueWithoutAchievementInput[]
    createMany?: UserAchievementCreateManyAchievementInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutAchievementInput | UserAchievementUpdateWithWhereUniqueWithoutAchievementInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutAchievementInput | UserAchievementUpdateManyWithWhereWithoutAchievementInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    connect?: UserWhereUniqueInput
  }

  export type AchievementCreateNestedOneWithoutUserAchievementsInput = {
    create?: XOR<AchievementCreateWithoutUserAchievementsInput, AchievementUncheckedCreateWithoutUserAchievementsInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUserAchievementsInput
    connect?: AchievementWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    upsert?: UserUpsertWithoutAchievementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAchievementsInput, UserUpdateWithoutAchievementsInput>, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type AchievementUpdateOneRequiredWithoutUserAchievementsNestedInput = {
    create?: XOR<AchievementCreateWithoutUserAchievementsInput, AchievementUncheckedCreateWithoutUserAchievementsInput>
    connectOrCreate?: AchievementCreateOrConnectWithoutUserAchievementsInput
    upsert?: AchievementUpsertWithoutUserAchievementsInput
    connect?: AchievementWhereUniqueInput
    update?: XOR<XOR<AchievementUpdateToOneWithWhereWithoutUserAchievementsInput, AchievementUpdateWithoutUserAchievementsInput>, AchievementUncheckedUpdateWithoutUserAchievementsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutEngagementsInput = {
    create?: XOR<UserCreateWithoutEngagementsInput, UserUncheckedCreateWithoutEngagementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEngagementsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumEngagementTypeFieldUpdateOperationsInput = {
    set?: $Enums.EngagementType
  }

  export type UserUpdateOneRequiredWithoutEngagementsNestedInput = {
    create?: XOR<UserCreateWithoutEngagementsInput, UserUncheckedCreateWithoutEngagementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEngagementsInput
    upsert?: UserUpsertWithoutEngagementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEngagementsInput, UserUpdateWithoutEngagementsInput>, UserUncheckedUpdateWithoutEngagementsInput>
  }

  export type TaskCompletionCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskCompletionCreateWithoutTaskInput, TaskCompletionUncheckedCreateWithoutTaskInput> | TaskCompletionCreateWithoutTaskInput[] | TaskCompletionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCompletionCreateOrConnectWithoutTaskInput | TaskCompletionCreateOrConnectWithoutTaskInput[]
    createMany?: TaskCompletionCreateManyTaskInputEnvelope
    connect?: TaskCompletionWhereUniqueInput | TaskCompletionWhereUniqueInput[]
  }

  export type TaskCompletionUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskCompletionCreateWithoutTaskInput, TaskCompletionUncheckedCreateWithoutTaskInput> | TaskCompletionCreateWithoutTaskInput[] | TaskCompletionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCompletionCreateOrConnectWithoutTaskInput | TaskCompletionCreateOrConnectWithoutTaskInput[]
    createMany?: TaskCompletionCreateManyTaskInputEnvelope
    connect?: TaskCompletionWhereUniqueInput | TaskCompletionWhereUniqueInput[]
  }

  export type EnumTaskTypeFieldUpdateOperationsInput = {
    set?: $Enums.TaskType
  }

  export type TaskCompletionUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskCompletionCreateWithoutTaskInput, TaskCompletionUncheckedCreateWithoutTaskInput> | TaskCompletionCreateWithoutTaskInput[] | TaskCompletionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCompletionCreateOrConnectWithoutTaskInput | TaskCompletionCreateOrConnectWithoutTaskInput[]
    upsert?: TaskCompletionUpsertWithWhereUniqueWithoutTaskInput | TaskCompletionUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskCompletionCreateManyTaskInputEnvelope
    set?: TaskCompletionWhereUniqueInput | TaskCompletionWhereUniqueInput[]
    disconnect?: TaskCompletionWhereUniqueInput | TaskCompletionWhereUniqueInput[]
    delete?: TaskCompletionWhereUniqueInput | TaskCompletionWhereUniqueInput[]
    connect?: TaskCompletionWhereUniqueInput | TaskCompletionWhereUniqueInput[]
    update?: TaskCompletionUpdateWithWhereUniqueWithoutTaskInput | TaskCompletionUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskCompletionUpdateManyWithWhereWithoutTaskInput | TaskCompletionUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskCompletionScalarWhereInput | TaskCompletionScalarWhereInput[]
  }

  export type TaskCompletionUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskCompletionCreateWithoutTaskInput, TaskCompletionUncheckedCreateWithoutTaskInput> | TaskCompletionCreateWithoutTaskInput[] | TaskCompletionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskCompletionCreateOrConnectWithoutTaskInput | TaskCompletionCreateOrConnectWithoutTaskInput[]
    upsert?: TaskCompletionUpsertWithWhereUniqueWithoutTaskInput | TaskCompletionUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskCompletionCreateManyTaskInputEnvelope
    set?: TaskCompletionWhereUniqueInput | TaskCompletionWhereUniqueInput[]
    disconnect?: TaskCompletionWhereUniqueInput | TaskCompletionWhereUniqueInput[]
    delete?: TaskCompletionWhereUniqueInput | TaskCompletionWhereUniqueInput[]
    connect?: TaskCompletionWhereUniqueInput | TaskCompletionWhereUniqueInput[]
    update?: TaskCompletionUpdateWithWhereUniqueWithoutTaskInput | TaskCompletionUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskCompletionUpdateManyWithWhereWithoutTaskInput | TaskCompletionUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskCompletionScalarWhereInput | TaskCompletionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAdminSessionsInput = {
    create?: XOR<UserCreateWithoutAdminSessionsInput, UserUncheckedCreateWithoutAdminSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdminSessionsNestedInput = {
    create?: XOR<UserCreateWithoutAdminSessionsInput, UserUncheckedCreateWithoutAdminSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminSessionsInput
    upsert?: UserUpsertWithoutAdminSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminSessionsInput, UserUpdateWithoutAdminSessionsInput>, UserUncheckedUpdateWithoutAdminSessionsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserCreateNestedOneWithoutFraudAlertsInput = {
    create?: XOR<UserCreateWithoutFraudAlertsInput, UserUncheckedCreateWithoutFraudAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFraudAlertsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFraudAlertsNestedInput = {
    create?: XOR<UserCreateWithoutFraudAlertsInput, UserUncheckedCreateWithoutFraudAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFraudAlertsInput
    upsert?: UserUpsertWithoutFraudAlertsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFraudAlertsInput, UserUpdateWithoutFraudAlertsInput>, UserUncheckedUpdateWithoutFraudAlertsInput>
  }

  export type UserCreateNestedOneWithoutCampaignsInput = {
    create?: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignsInput
    connect?: UserWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type UserUpdateOneRequiredWithoutCampaignsNestedInput = {
    create?: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCampaignsInput
    upsert?: UserUpsertWithoutCampaignsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCampaignsInput, UserUpdateWithoutCampaignsInput>, UserUncheckedUpdateWithoutCampaignsInput>
  }

  export type UserCreateNestedOneWithoutTasksInput = {
    create?: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput
    connect?: UserWhereUniqueInput
  }

  export type TaskCreateNestedOneWithoutCompletionsInput = {
    create?: XOR<TaskCreateWithoutCompletionsInput, TaskUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCompletionsInput
    connect?: TaskWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput
    upsert?: UserUpsertWithoutTasksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksInput, UserUpdateWithoutTasksInput>, UserUncheckedUpdateWithoutTasksInput>
  }

  export type TaskUpdateOneRequiredWithoutCompletionsNestedInput = {
    create?: XOR<TaskCreateWithoutCompletionsInput, TaskUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutCompletionsInput
    upsert?: TaskUpsertWithoutCompletionsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutCompletionsInput, TaskUpdateWithoutCompletionsInput>, TaskUncheckedUpdateWithoutCompletionsInput>
  }

  export type UserCreateNestedOneWithoutClaimsInput = {
    create?: XOR<UserCreateWithoutClaimsInput, UserUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClaimsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumClaimStatusFieldUpdateOperationsInput = {
    set?: $Enums.ClaimStatus
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutClaimsNestedInput = {
    create?: XOR<UserCreateWithoutClaimsInput, UserUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: UserCreateOrConnectWithoutClaimsInput
    upsert?: UserUpsertWithoutClaimsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutClaimsInput, UserUpdateWithoutClaimsInput>, UserUncheckedUpdateWithoutClaimsInput>
  }

  export type UserCreateNestedOneWithoutPointHistoryInput = {
    create?: XOR<UserCreateWithoutPointHistoryInput, UserUncheckedCreateWithoutPointHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutPointHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPointHistoryNestedInput = {
    create?: XOR<UserCreateWithoutPointHistoryInput, UserUncheckedCreateWithoutPointHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutPointHistoryInput
    upsert?: UserUpsertWithoutPointHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPointHistoryInput, UserUpdateWithoutPointHistoryInput>, UserUncheckedUpdateWithoutPointHistoryInput>
  }

  export type UserCreateNestedOneWithoutReferralsInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReferredByInput = {
    create?: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferredByInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutReferralsNestedInput = {
    create?: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferralsInput
    upsert?: UserUpsertWithoutReferralsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferralsInput, UserUpdateWithoutReferralsInput>, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateOneRequiredWithoutReferredByNestedInput = {
    create?: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput>
    connectOrCreate?: UserCreateOrConnectWithoutReferredByInput
    upsert?: UserUpsertWithoutReferredByInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReferredByInput, UserUpdateWithoutReferredByInput>, UserUncheckedUpdateWithoutReferredByInput>
  }

  export type UserCreateNestedOneWithoutDailyEarningsInput = {
    create?: XOR<UserCreateWithoutDailyEarningsInput, UserUncheckedCreateWithoutDailyEarningsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyEarningsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutDailyEarningsNestedInput = {
    create?: XOR<UserCreateWithoutDailyEarningsInput, UserUncheckedCreateWithoutDailyEarningsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDailyEarningsInput
    upsert?: UserUpsertWithoutDailyEarningsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDailyEarningsInput, UserUpdateWithoutDailyEarningsInput>, UserUncheckedUpdateWithoutDailyEarningsInput>
  }

  export type UserCreateNestedOneWithoutAirdropSeasonsInput = {
    create?: XOR<UserCreateWithoutAirdropSeasonsInput, UserUncheckedCreateWithoutAirdropSeasonsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAirdropSeasonsInput
    connect?: UserWhereUniqueInput
  }

  export type AirdropClaimCreateNestedManyWithoutSeasonInput = {
    create?: XOR<AirdropClaimCreateWithoutSeasonInput, AirdropClaimUncheckedCreateWithoutSeasonInput> | AirdropClaimCreateWithoutSeasonInput[] | AirdropClaimUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: AirdropClaimCreateOrConnectWithoutSeasonInput | AirdropClaimCreateOrConnectWithoutSeasonInput[]
    createMany?: AirdropClaimCreateManySeasonInputEnvelope
    connect?: AirdropClaimWhereUniqueInput | AirdropClaimWhereUniqueInput[]
  }

  export type AirdropClaimUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<AirdropClaimCreateWithoutSeasonInput, AirdropClaimUncheckedCreateWithoutSeasonInput> | AirdropClaimCreateWithoutSeasonInput[] | AirdropClaimUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: AirdropClaimCreateOrConnectWithoutSeasonInput | AirdropClaimCreateOrConnectWithoutSeasonInput[]
    createMany?: AirdropClaimCreateManySeasonInputEnvelope
    connect?: AirdropClaimWhereUniqueInput | AirdropClaimWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutAirdropSeasonsNestedInput = {
    create?: XOR<UserCreateWithoutAirdropSeasonsInput, UserUncheckedCreateWithoutAirdropSeasonsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAirdropSeasonsInput
    upsert?: UserUpsertWithoutAirdropSeasonsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAirdropSeasonsInput, UserUpdateWithoutAirdropSeasonsInput>, UserUncheckedUpdateWithoutAirdropSeasonsInput>
  }

  export type AirdropClaimUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<AirdropClaimCreateWithoutSeasonInput, AirdropClaimUncheckedCreateWithoutSeasonInput> | AirdropClaimCreateWithoutSeasonInput[] | AirdropClaimUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: AirdropClaimCreateOrConnectWithoutSeasonInput | AirdropClaimCreateOrConnectWithoutSeasonInput[]
    upsert?: AirdropClaimUpsertWithWhereUniqueWithoutSeasonInput | AirdropClaimUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: AirdropClaimCreateManySeasonInputEnvelope
    set?: AirdropClaimWhereUniqueInput | AirdropClaimWhereUniqueInput[]
    disconnect?: AirdropClaimWhereUniqueInput | AirdropClaimWhereUniqueInput[]
    delete?: AirdropClaimWhereUniqueInput | AirdropClaimWhereUniqueInput[]
    connect?: AirdropClaimWhereUniqueInput | AirdropClaimWhereUniqueInput[]
    update?: AirdropClaimUpdateWithWhereUniqueWithoutSeasonInput | AirdropClaimUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: AirdropClaimUpdateManyWithWhereWithoutSeasonInput | AirdropClaimUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: AirdropClaimScalarWhereInput | AirdropClaimScalarWhereInput[]
  }

  export type AirdropClaimUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<AirdropClaimCreateWithoutSeasonInput, AirdropClaimUncheckedCreateWithoutSeasonInput> | AirdropClaimCreateWithoutSeasonInput[] | AirdropClaimUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: AirdropClaimCreateOrConnectWithoutSeasonInput | AirdropClaimCreateOrConnectWithoutSeasonInput[]
    upsert?: AirdropClaimUpsertWithWhereUniqueWithoutSeasonInput | AirdropClaimUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: AirdropClaimCreateManySeasonInputEnvelope
    set?: AirdropClaimWhereUniqueInput | AirdropClaimWhereUniqueInput[]
    disconnect?: AirdropClaimWhereUniqueInput | AirdropClaimWhereUniqueInput[]
    delete?: AirdropClaimWhereUniqueInput | AirdropClaimWhereUniqueInput[]
    connect?: AirdropClaimWhereUniqueInput | AirdropClaimWhereUniqueInput[]
    update?: AirdropClaimUpdateWithWhereUniqueWithoutSeasonInput | AirdropClaimUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: AirdropClaimUpdateManyWithWhereWithoutSeasonInput | AirdropClaimUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: AirdropClaimScalarWhereInput | AirdropClaimScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAirdropClaimsInput = {
    create?: XOR<UserCreateWithoutAirdropClaimsInput, UserUncheckedCreateWithoutAirdropClaimsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAirdropClaimsInput
    connect?: UserWhereUniqueInput
  }

  export type AirdropSeasonCreateNestedOneWithoutClaimsInput = {
    create?: XOR<AirdropSeasonCreateWithoutClaimsInput, AirdropSeasonUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: AirdropSeasonCreateOrConnectWithoutClaimsInput
    connect?: AirdropSeasonWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAirdropClaimsNestedInput = {
    create?: XOR<UserCreateWithoutAirdropClaimsInput, UserUncheckedCreateWithoutAirdropClaimsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAirdropClaimsInput
    upsert?: UserUpsertWithoutAirdropClaimsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAirdropClaimsInput, UserUpdateWithoutAirdropClaimsInput>, UserUncheckedUpdateWithoutAirdropClaimsInput>
  }

  export type AirdropSeasonUpdateOneRequiredWithoutClaimsNestedInput = {
    create?: XOR<AirdropSeasonCreateWithoutClaimsInput, AirdropSeasonUncheckedCreateWithoutClaimsInput>
    connectOrCreate?: AirdropSeasonCreateOrConnectWithoutClaimsInput
    upsert?: AirdropSeasonUpsertWithoutClaimsInput
    connect?: AirdropSeasonWhereUniqueInput
    update?: XOR<XOR<AirdropSeasonUpdateToOneWithWhereWithoutClaimsInput, AirdropSeasonUpdateWithoutClaimsInput>, AirdropSeasonUncheckedUpdateWithoutClaimsInput>
  }

  export type UserCreateNestedOneWithoutNftCollectionsInput = {
    create?: XOR<UserCreateWithoutNftCollectionsInput, UserUncheckedCreateWithoutNftCollectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNftCollectionsInput
    connect?: UserWhereUniqueInput
  }

  export type NftDistributionCreateNestedManyWithoutCollectionInput = {
    create?: XOR<NftDistributionCreateWithoutCollectionInput, NftDistributionUncheckedCreateWithoutCollectionInput> | NftDistributionCreateWithoutCollectionInput[] | NftDistributionUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: NftDistributionCreateOrConnectWithoutCollectionInput | NftDistributionCreateOrConnectWithoutCollectionInput[]
    createMany?: NftDistributionCreateManyCollectionInputEnvelope
    connect?: NftDistributionWhereUniqueInput | NftDistributionWhereUniqueInput[]
  }

  export type NftDistributionUncheckedCreateNestedManyWithoutCollectionInput = {
    create?: XOR<NftDistributionCreateWithoutCollectionInput, NftDistributionUncheckedCreateWithoutCollectionInput> | NftDistributionCreateWithoutCollectionInput[] | NftDistributionUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: NftDistributionCreateOrConnectWithoutCollectionInput | NftDistributionCreateOrConnectWithoutCollectionInput[]
    createMany?: NftDistributionCreateManyCollectionInputEnvelope
    connect?: NftDistributionWhereUniqueInput | NftDistributionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutNftCollectionsNestedInput = {
    create?: XOR<UserCreateWithoutNftCollectionsInput, UserUncheckedCreateWithoutNftCollectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNftCollectionsInput
    upsert?: UserUpsertWithoutNftCollectionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNftCollectionsInput, UserUpdateWithoutNftCollectionsInput>, UserUncheckedUpdateWithoutNftCollectionsInput>
  }

  export type NftDistributionUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<NftDistributionCreateWithoutCollectionInput, NftDistributionUncheckedCreateWithoutCollectionInput> | NftDistributionCreateWithoutCollectionInput[] | NftDistributionUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: NftDistributionCreateOrConnectWithoutCollectionInput | NftDistributionCreateOrConnectWithoutCollectionInput[]
    upsert?: NftDistributionUpsertWithWhereUniqueWithoutCollectionInput | NftDistributionUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: NftDistributionCreateManyCollectionInputEnvelope
    set?: NftDistributionWhereUniqueInput | NftDistributionWhereUniqueInput[]
    disconnect?: NftDistributionWhereUniqueInput | NftDistributionWhereUniqueInput[]
    delete?: NftDistributionWhereUniqueInput | NftDistributionWhereUniqueInput[]
    connect?: NftDistributionWhereUniqueInput | NftDistributionWhereUniqueInput[]
    update?: NftDistributionUpdateWithWhereUniqueWithoutCollectionInput | NftDistributionUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: NftDistributionUpdateManyWithWhereWithoutCollectionInput | NftDistributionUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: NftDistributionScalarWhereInput | NftDistributionScalarWhereInput[]
  }

  export type NftDistributionUncheckedUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<NftDistributionCreateWithoutCollectionInput, NftDistributionUncheckedCreateWithoutCollectionInput> | NftDistributionCreateWithoutCollectionInput[] | NftDistributionUncheckedCreateWithoutCollectionInput[]
    connectOrCreate?: NftDistributionCreateOrConnectWithoutCollectionInput | NftDistributionCreateOrConnectWithoutCollectionInput[]
    upsert?: NftDistributionUpsertWithWhereUniqueWithoutCollectionInput | NftDistributionUpsertWithWhereUniqueWithoutCollectionInput[]
    createMany?: NftDistributionCreateManyCollectionInputEnvelope
    set?: NftDistributionWhereUniqueInput | NftDistributionWhereUniqueInput[]
    disconnect?: NftDistributionWhereUniqueInput | NftDistributionWhereUniqueInput[]
    delete?: NftDistributionWhereUniqueInput | NftDistributionWhereUniqueInput[]
    connect?: NftDistributionWhereUniqueInput | NftDistributionWhereUniqueInput[]
    update?: NftDistributionUpdateWithWhereUniqueWithoutCollectionInput | NftDistributionUpdateWithWhereUniqueWithoutCollectionInput[]
    updateMany?: NftDistributionUpdateManyWithWhereWithoutCollectionInput | NftDistributionUpdateManyWithWhereWithoutCollectionInput[]
    deleteMany?: NftDistributionScalarWhereInput | NftDistributionScalarWhereInput[]
  }

  export type NftCollectionCreateNestedOneWithoutDistributionsInput = {
    create?: XOR<NftCollectionCreateWithoutDistributionsInput, NftCollectionUncheckedCreateWithoutDistributionsInput>
    connectOrCreate?: NftCollectionCreateOrConnectWithoutDistributionsInput
    connect?: NftCollectionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNftDistributionsInput = {
    create?: XOR<UserCreateWithoutNftDistributionsInput, UserUncheckedCreateWithoutNftDistributionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNftDistributionsInput
    connect?: UserWhereUniqueInput
  }

  export type NftCollectionUpdateOneRequiredWithoutDistributionsNestedInput = {
    create?: XOR<NftCollectionCreateWithoutDistributionsInput, NftCollectionUncheckedCreateWithoutDistributionsInput>
    connectOrCreate?: NftCollectionCreateOrConnectWithoutDistributionsInput
    upsert?: NftCollectionUpsertWithoutDistributionsInput
    connect?: NftCollectionWhereUniqueInput
    update?: XOR<XOR<NftCollectionUpdateToOneWithWhereWithoutDistributionsInput, NftCollectionUpdateWithoutDistributionsInput>, NftCollectionUncheckedUpdateWithoutDistributionsInput>
  }

  export type UserUpdateOneRequiredWithoutNftDistributionsNestedInput = {
    create?: XOR<UserCreateWithoutNftDistributionsInput, UserUncheckedCreateWithoutNftDistributionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNftDistributionsInput
    upsert?: UserUpsertWithoutNftDistributionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNftDistributionsInput, UserUpdateWithoutNftDistributionsInput>, UserUncheckedUpdateWithoutNftDistributionsInput>
  }

  export type UserCreateNestedOneWithoutNftClaimApprovalInput = {
    create?: XOR<UserCreateWithoutNftClaimApprovalInput, UserUncheckedCreateWithoutNftClaimApprovalInput>
    connectOrCreate?: UserCreateOrConnectWithoutNftClaimApprovalInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedClaimsInput = {
    create?: XOR<UserCreateWithoutApprovedClaimsInput, UserUncheckedCreateWithoutApprovedClaimsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedClaimsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNftClaimApprovalNestedInput = {
    create?: XOR<UserCreateWithoutNftClaimApprovalInput, UserUncheckedCreateWithoutNftClaimApprovalInput>
    connectOrCreate?: UserCreateOrConnectWithoutNftClaimApprovalInput
    upsert?: UserUpsertWithoutNftClaimApprovalInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNftClaimApprovalInput, UserUpdateWithoutNftClaimApprovalInput>, UserUncheckedUpdateWithoutNftClaimApprovalInput>
  }

  export type UserUpdateOneWithoutApprovedClaimsNestedInput = {
    create?: XOR<UserCreateWithoutApprovedClaimsInput, UserUncheckedCreateWithoutApprovedClaimsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedClaimsInput
    upsert?: UserUpsertWithoutApprovedClaimsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedClaimsInput, UserUpdateWithoutApprovedClaimsInput>, UserUncheckedUpdateWithoutApprovedClaimsInput>
  }

  export type UserCreateNestedOneWithoutNftHoldingsInput = {
    create?: XOR<UserCreateWithoutNftHoldingsInput, UserUncheckedCreateWithoutNftHoldingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNftHoldingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNftHoldingsNestedInput = {
    create?: XOR<UserCreateWithoutNftHoldingsInput, UserUncheckedCreateWithoutNftHoldingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNftHoldingsInput
    upsert?: UserUpsertWithoutNftHoldingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNftHoldingsInput, UserUpdateWithoutNftHoldingsInput>, UserUncheckedUpdateWithoutNftHoldingsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTwitterActivityNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TwitterActivity | EnumTwitterActivityFieldRefInput<$PrismaModel> | null
    in?: $Enums.TwitterActivity[] | ListEnumTwitterActivityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TwitterActivity[] | ListEnumTwitterActivityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTwitterActivityNullableFilter<$PrismaModel> | $Enums.TwitterActivity | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTwitterActivityNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TwitterActivity | EnumTwitterActivityFieldRefInput<$PrismaModel> | null
    in?: $Enums.TwitterActivity[] | ListEnumTwitterActivityFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TwitterActivity[] | ListEnumTwitterActivityFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTwitterActivityNullableWithAggregatesFilter<$PrismaModel> | $Enums.TwitterActivity | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTwitterActivityNullableFilter<$PrismaModel>
    _max?: NestedEnumTwitterActivityNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumEngagementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EngagementType | EnumEngagementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EngagementType[] | ListEnumEngagementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EngagementType[] | ListEnumEngagementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEngagementTypeFilter<$PrismaModel> | $Enums.EngagementType
  }

  export type NestedEnumEngagementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EngagementType | EnumEngagementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EngagementType[] | ListEnumEngagementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EngagementType[] | ListEnumEngagementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEngagementTypeWithAggregatesFilter<$PrismaModel> | $Enums.EngagementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEngagementTypeFilter<$PrismaModel>
    _max?: NestedEnumEngagementTypeFilter<$PrismaModel>
  }

  export type NestedEnumTaskTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskTypeFilter<$PrismaModel> | $Enums.TaskType
  }

  export type NestedEnumTaskTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaskType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskTypeFilter<$PrismaModel>
    _max?: NestedEnumTaskTypeFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumClaimStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusFilter<$PrismaModel> | $Enums.ClaimStatus
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumClaimStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClaimStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClaimStatusFilter<$PrismaModel>
    _max?: NestedEnumClaimStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DailyEarningCreateWithoutUserInput = {
    id?: string
    tokens: number
    type: string
    claimedAt?: Date | string
  }

  export type DailyEarningUncheckedCreateWithoutUserInput = {
    id?: string
    tokens: number
    type: string
    claimedAt?: Date | string
  }

  export type DailyEarningCreateOrConnectWithoutUserInput = {
    where: DailyEarningWhereUniqueInput
    create: XOR<DailyEarningCreateWithoutUserInput, DailyEarningUncheckedCreateWithoutUserInput>
  }

  export type DailyEarningCreateManyUserInputEnvelope = {
    data: DailyEarningCreateManyUserInput | DailyEarningCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AirdropClaimCreateWithoutUserInput = {
    id?: string
    tokens: number
    tier: string
    paymentSignature: string
    transactionSignature?: string | null
    status: string
    claimedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    season: AirdropSeasonCreateNestedOneWithoutClaimsInput
  }

  export type AirdropClaimUncheckedCreateWithoutUserInput = {
    id?: string
    seasonId: string
    tokens: number
    tier: string
    paymentSignature: string
    transactionSignature?: string | null
    status: string
    claimedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AirdropClaimCreateOrConnectWithoutUserInput = {
    where: AirdropClaimWhereUniqueInput
    create: XOR<AirdropClaimCreateWithoutUserInput, AirdropClaimUncheckedCreateWithoutUserInput>
  }

  export type AirdropClaimCreateManyUserInputEnvelope = {
    data: AirdropClaimCreateManyUserInput | AirdropClaimCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TwitterEngagementCreateWithoutUserInput = {
    id?: string
    tweetId: string
    engagementType: $Enums.EngagementType
    points: number
    verified?: boolean
    createdAt?: Date | string
  }

  export type TwitterEngagementUncheckedCreateWithoutUserInput = {
    id?: string
    tweetId: string
    engagementType: $Enums.EngagementType
    points: number
    verified?: boolean
    createdAt?: Date | string
  }

  export type TwitterEngagementCreateOrConnectWithoutUserInput = {
    where: TwitterEngagementWhereUniqueInput
    create: XOR<TwitterEngagementCreateWithoutUserInput, TwitterEngagementUncheckedCreateWithoutUserInput>
  }

  export type TwitterEngagementCreateManyUserInputEnvelope = {
    data: TwitterEngagementCreateManyUserInput | TwitterEngagementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TaskCompletionCreateWithoutUserInput = {
    id?: string
    completed?: boolean
    points: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
    createdAt?: Date | string
    task: TaskCreateNestedOneWithoutCompletionsInput
  }

  export type TaskCompletionUncheckedCreateWithoutUserInput = {
    id?: string
    taskId: string
    completed?: boolean
    points: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TaskCompletionCreateOrConnectWithoutUserInput = {
    where: TaskCompletionWhereUniqueInput
    create: XOR<TaskCompletionCreateWithoutUserInput, TaskCompletionUncheckedCreateWithoutUserInput>
  }

  export type TaskCompletionCreateManyUserInputEnvelope = {
    data: TaskCompletionCreateManyUserInput | TaskCompletionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClaimCreateWithoutUserInput = {
    id?: string
    amount: number
    transactionHash?: string | null
    status?: $Enums.ClaimStatus
    paymentMethod?: $Enums.PaymentMethod
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    feesPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    type?: string | null
    nftPasses?: NullableJsonNullValueInput | InputJsonValue
    userTier?: string | null
  }

  export type ClaimUncheckedCreateWithoutUserInput = {
    id?: string
    amount: number
    transactionHash?: string | null
    status?: $Enums.ClaimStatus
    paymentMethod?: $Enums.PaymentMethod
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    feesPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    type?: string | null
    nftPasses?: NullableJsonNullValueInput | InputJsonValue
    userTier?: string | null
  }

  export type ClaimCreateOrConnectWithoutUserInput = {
    where: ClaimWhereUniqueInput
    create: XOR<ClaimCreateWithoutUserInput, ClaimUncheckedCreateWithoutUserInput>
  }

  export type ClaimCreateManyUserInputEnvelope = {
    data: ClaimCreateManyUserInput | ClaimCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PointHistoryCreateWithoutUserInput = {
    id?: string
    points: number
    action: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PointHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    points: number
    action: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PointHistoryCreateOrConnectWithoutUserInput = {
    where: PointHistoryWhereUniqueInput
    create: XOR<PointHistoryCreateWithoutUserInput, PointHistoryUncheckedCreateWithoutUserInput>
  }

  export type PointHistoryCreateManyUserInputEnvelope = {
    data: PointHistoryCreateManyUserInput | PointHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutReferrerInput = {
    id?: string
    points?: number
    completed?: boolean
    createdAt?: Date | string
    isActive?: boolean
    referred: UserCreateNestedOneWithoutReferredByInput
  }

  export type ReferralUncheckedCreateWithoutReferrerInput = {
    id?: string
    referredId: string
    points?: number
    completed?: boolean
    createdAt?: Date | string
    isActive?: boolean
  }

  export type ReferralCreateOrConnectWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput>
  }

  export type ReferralCreateManyReferrerInputEnvelope = {
    data: ReferralCreateManyReferrerInput | ReferralCreateManyReferrerInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutReferredInput = {
    id?: string
    points?: number
    completed?: boolean
    createdAt?: Date | string
    isActive?: boolean
    referrer: UserCreateNestedOneWithoutReferralsInput
  }

  export type ReferralUncheckedCreateWithoutReferredInput = {
    id?: string
    referrerId: string
    points?: number
    completed?: boolean
    createdAt?: Date | string
    isActive?: boolean
  }

  export type ReferralCreateOrConnectWithoutReferredInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutReferredInput, ReferralUncheckedCreateWithoutReferredInput>
  }

  export type UserAchievementCreateWithoutUserInput = {
    id?: string
    unlockedAt?: Date | string
    progress?: number
    achievement: AchievementCreateNestedOneWithoutUserAchievementsInput
  }

  export type UserAchievementUncheckedCreateWithoutUserInput = {
    id?: string
    achievementId: string
    unlockedAt?: Date | string
    progress?: number
  }

  export type UserAchievementCreateOrConnectWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementCreateManyUserInputEnvelope = {
    data: UserAchievementCreateManyUserInput | UserAchievementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type?: $Enums.NotificationType
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type?: $Enums.NotificationType
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AdminSessionCreateWithoutAdminInput = {
    id?: string
    ipAddress: string
    userAgent: string
    permissions: JsonNullValueInput | InputJsonValue
    expiresAt: Date | string
    lastActivity: Date | string
    createdAt?: Date | string
  }

  export type AdminSessionUncheckedCreateWithoutAdminInput = {
    id?: string
    ipAddress: string
    userAgent: string
    permissions: JsonNullValueInput | InputJsonValue
    expiresAt: Date | string
    lastActivity: Date | string
    createdAt?: Date | string
  }

  export type AdminSessionCreateOrConnectWithoutAdminInput = {
    where: AdminSessionWhereUniqueInput
    create: XOR<AdminSessionCreateWithoutAdminInput, AdminSessionUncheckedCreateWithoutAdminInput>
  }

  export type AdminSessionCreateManyAdminInputEnvelope = {
    data: AdminSessionCreateManyAdminInput | AdminSessionCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type AdminAuditLogCreateWithoutAdminInput = {
    id?: string
    action: string
    metadata: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    ipAddress: string
  }

  export type AdminAuditLogUncheckedCreateWithoutAdminInput = {
    id?: string
    action: string
    metadata: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    ipAddress: string
  }

  export type AdminAuditLogCreateOrConnectWithoutAdminInput = {
    where: AdminAuditLogWhereUniqueInput
    create: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput>
  }

  export type AdminAuditLogCreateManyAdminInputEnvelope = {
    data: AdminAuditLogCreateManyAdminInput | AdminAuditLogCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type FraudAlertCreateWithoutUserInput = {
    id?: string
    type: string
    severity: string
    description: string
    evidence: JsonNullValueInput | InputJsonValue
    riskScore: number
    status?: string
    createdAt?: Date | string
    investigatedBy?: string | null
    resolvedAt?: Date | string | null
  }

  export type FraudAlertUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    severity: string
    description: string
    evidence: JsonNullValueInput | InputJsonValue
    riskScore: number
    status?: string
    createdAt?: Date | string
    investigatedBy?: string | null
    resolvedAt?: Date | string | null
  }

  export type FraudAlertCreateOrConnectWithoutUserInput = {
    where: FraudAlertWhereUniqueInput
    create: XOR<FraudAlertCreateWithoutUserInput, FraudAlertUncheckedCreateWithoutUserInput>
  }

  export type FraudAlertCreateManyUserInputEnvelope = {
    data: FraudAlertCreateManyUserInput | FraudAlertCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CampaignConfigCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    tokenMint: string
    totalAllocation: bigint | number
    startDate: Date | string
    endDate: Date | string
    eligibilityCriteria: JsonNullValueInput | InputJsonValue
    distributionRules: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignConfigUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    tokenMint: string
    totalAllocation: bigint | number
    startDate: Date | string
    endDate: Date | string
    eligibilityCriteria: JsonNullValueInput | InputJsonValue
    distributionRules: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CampaignConfigCreateOrConnectWithoutCreatorInput = {
    where: CampaignConfigWhereUniqueInput
    create: XOR<CampaignConfigCreateWithoutCreatorInput, CampaignConfigUncheckedCreateWithoutCreatorInput>
  }

  export type CampaignConfigCreateManyCreatorInputEnvelope = {
    data: CampaignConfigCreateManyCreatorInput | CampaignConfigCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type NftCollectionCreateWithoutCreatorInput = {
    id?: string
    mintAddress: string
    name: string
    symbol: string
    description?: string | null
    uri: string
    supply?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    distributions?: NftDistributionCreateNestedManyWithoutCollectionInput
  }

  export type NftCollectionUncheckedCreateWithoutCreatorInput = {
    id?: string
    mintAddress: string
    name: string
    symbol: string
    description?: string | null
    uri: string
    supply?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    distributions?: NftDistributionUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type NftCollectionCreateOrConnectWithoutCreatorInput = {
    where: NftCollectionWhereUniqueInput
    create: XOR<NftCollectionCreateWithoutCreatorInput, NftCollectionUncheckedCreateWithoutCreatorInput>
  }

  export type NftCollectionCreateManyCreatorInputEnvelope = {
    data: NftCollectionCreateManyCreatorInput | NftCollectionCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type NftDistributionCreateWithoutDistributorInput = {
    id?: string
    recipientCount: number
    nftsPerUser: number
    results: JsonNullValueInput | InputJsonValue
    success?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    collection: NftCollectionCreateNestedOneWithoutDistributionsInput
  }

  export type NftDistributionUncheckedCreateWithoutDistributorInput = {
    id?: string
    mintAddress: string
    recipientCount: number
    nftsPerUser: number
    results: JsonNullValueInput | InputJsonValue
    success?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NftDistributionCreateOrConnectWithoutDistributorInput = {
    where: NftDistributionWhereUniqueInput
    create: XOR<NftDistributionCreateWithoutDistributorInput, NftDistributionUncheckedCreateWithoutDistributorInput>
  }

  export type NftDistributionCreateManyDistributorInputEnvelope = {
    data: NftDistributionCreateManyDistributorInput | NftDistributionCreateManyDistributorInput[]
    skipDuplicates?: boolean
  }

  export type UserNftHoldingCreateWithoutUserInput = {
    id?: string
    mintAddress: string
    tokenAccount: string
    amount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acquiredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserNftHoldingUncheckedCreateWithoutUserInput = {
    id?: string
    mintAddress: string
    tokenAccount: string
    amount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acquiredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserNftHoldingCreateOrConnectWithoutUserInput = {
    where: UserNftHoldingWhereUniqueInput
    create: XOR<UserNftHoldingCreateWithoutUserInput, UserNftHoldingUncheckedCreateWithoutUserInput>
  }

  export type UserNftHoldingCreateManyUserInputEnvelope = {
    data: UserNftHoldingCreateManyUserInput | UserNftHoldingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NftClaimApprovalCreateWithoutUserInput = {
    id?: string
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approver?: UserCreateNestedOneWithoutApprovedClaimsInput
  }

  export type NftClaimApprovalUncheckedCreateWithoutUserInput = {
    id?: string
    approved?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NftClaimApprovalCreateOrConnectWithoutUserInput = {
    where: NftClaimApprovalWhereUniqueInput
    create: XOR<NftClaimApprovalCreateWithoutUserInput, NftClaimApprovalUncheckedCreateWithoutUserInput>
  }

  export type NftClaimApprovalCreateWithoutApproverInput = {
    id?: string
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutNftClaimApprovalInput
  }

  export type NftClaimApprovalUncheckedCreateWithoutApproverInput = {
    id?: string
    userId: string
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NftClaimApprovalCreateOrConnectWithoutApproverInput = {
    where: NftClaimApprovalWhereUniqueInput
    create: XOR<NftClaimApprovalCreateWithoutApproverInput, NftClaimApprovalUncheckedCreateWithoutApproverInput>
  }

  export type NftClaimApprovalCreateManyApproverInputEnvelope = {
    data: NftClaimApprovalCreateManyApproverInput | NftClaimApprovalCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type AirdropSeasonCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    totalAllocation: bigint | number
    claimedAmount?: bigint | number
    startDate?: Date | string
    endDate?: Date | string | null
    nftPassRequired?: boolean
    requireApproval?: boolean
    feeAmount?: Decimal | DecimalJsLike | number | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    claims?: AirdropClaimCreateNestedManyWithoutSeasonInput
  }

  export type AirdropSeasonUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    totalAllocation: bigint | number
    claimedAmount?: bigint | number
    startDate?: Date | string
    endDate?: Date | string | null
    nftPassRequired?: boolean
    requireApproval?: boolean
    feeAmount?: Decimal | DecimalJsLike | number | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    claims?: AirdropClaimUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type AirdropSeasonCreateOrConnectWithoutCreatorInput = {
    where: AirdropSeasonWhereUniqueInput
    create: XOR<AirdropSeasonCreateWithoutCreatorInput, AirdropSeasonUncheckedCreateWithoutCreatorInput>
  }

  export type AirdropSeasonCreateManyCreatorInputEnvelope = {
    data: AirdropSeasonCreateManyCreatorInput | AirdropSeasonCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type DailyEarningUpsertWithWhereUniqueWithoutUserInput = {
    where: DailyEarningWhereUniqueInput
    update: XOR<DailyEarningUpdateWithoutUserInput, DailyEarningUncheckedUpdateWithoutUserInput>
    create: XOR<DailyEarningCreateWithoutUserInput, DailyEarningUncheckedCreateWithoutUserInput>
  }

  export type DailyEarningUpdateWithWhereUniqueWithoutUserInput = {
    where: DailyEarningWhereUniqueInput
    data: XOR<DailyEarningUpdateWithoutUserInput, DailyEarningUncheckedUpdateWithoutUserInput>
  }

  export type DailyEarningUpdateManyWithWhereWithoutUserInput = {
    where: DailyEarningScalarWhereInput
    data: XOR<DailyEarningUpdateManyMutationInput, DailyEarningUncheckedUpdateManyWithoutUserInput>
  }

  export type DailyEarningScalarWhereInput = {
    AND?: DailyEarningScalarWhereInput | DailyEarningScalarWhereInput[]
    OR?: DailyEarningScalarWhereInput[]
    NOT?: DailyEarningScalarWhereInput | DailyEarningScalarWhereInput[]
    id?: StringFilter<"DailyEarning"> | string
    userId?: StringFilter<"DailyEarning"> | string
    tokens?: FloatFilter<"DailyEarning"> | number
    type?: StringFilter<"DailyEarning"> | string
    claimedAt?: DateTimeFilter<"DailyEarning"> | Date | string
  }

  export type AirdropClaimUpsertWithWhereUniqueWithoutUserInput = {
    where: AirdropClaimWhereUniqueInput
    update: XOR<AirdropClaimUpdateWithoutUserInput, AirdropClaimUncheckedUpdateWithoutUserInput>
    create: XOR<AirdropClaimCreateWithoutUserInput, AirdropClaimUncheckedCreateWithoutUserInput>
  }

  export type AirdropClaimUpdateWithWhereUniqueWithoutUserInput = {
    where: AirdropClaimWhereUniqueInput
    data: XOR<AirdropClaimUpdateWithoutUserInput, AirdropClaimUncheckedUpdateWithoutUserInput>
  }

  export type AirdropClaimUpdateManyWithWhereWithoutUserInput = {
    where: AirdropClaimScalarWhereInput
    data: XOR<AirdropClaimUpdateManyMutationInput, AirdropClaimUncheckedUpdateManyWithoutUserInput>
  }

  export type AirdropClaimScalarWhereInput = {
    AND?: AirdropClaimScalarWhereInput | AirdropClaimScalarWhereInput[]
    OR?: AirdropClaimScalarWhereInput[]
    NOT?: AirdropClaimScalarWhereInput | AirdropClaimScalarWhereInput[]
    id?: StringFilter<"AirdropClaim"> | string
    userId?: StringFilter<"AirdropClaim"> | string
    seasonId?: StringFilter<"AirdropClaim"> | string
    tokens?: FloatFilter<"AirdropClaim"> | number
    tier?: StringFilter<"AirdropClaim"> | string
    paymentSignature?: StringFilter<"AirdropClaim"> | string
    transactionSignature?: StringNullableFilter<"AirdropClaim"> | string | null
    status?: StringFilter<"AirdropClaim"> | string
    claimedAt?: DateTimeFilter<"AirdropClaim"> | Date | string
    createdAt?: DateTimeFilter<"AirdropClaim"> | Date | string
    updatedAt?: DateTimeFilter<"AirdropClaim"> | Date | string
  }

  export type TwitterEngagementUpsertWithWhereUniqueWithoutUserInput = {
    where: TwitterEngagementWhereUniqueInput
    update: XOR<TwitterEngagementUpdateWithoutUserInput, TwitterEngagementUncheckedUpdateWithoutUserInput>
    create: XOR<TwitterEngagementCreateWithoutUserInput, TwitterEngagementUncheckedCreateWithoutUserInput>
  }

  export type TwitterEngagementUpdateWithWhereUniqueWithoutUserInput = {
    where: TwitterEngagementWhereUniqueInput
    data: XOR<TwitterEngagementUpdateWithoutUserInput, TwitterEngagementUncheckedUpdateWithoutUserInput>
  }

  export type TwitterEngagementUpdateManyWithWhereWithoutUserInput = {
    where: TwitterEngagementScalarWhereInput
    data: XOR<TwitterEngagementUpdateManyMutationInput, TwitterEngagementUncheckedUpdateManyWithoutUserInput>
  }

  export type TwitterEngagementScalarWhereInput = {
    AND?: TwitterEngagementScalarWhereInput | TwitterEngagementScalarWhereInput[]
    OR?: TwitterEngagementScalarWhereInput[]
    NOT?: TwitterEngagementScalarWhereInput | TwitterEngagementScalarWhereInput[]
    id?: StringFilter<"TwitterEngagement"> | string
    userId?: StringFilter<"TwitterEngagement"> | string
    tweetId?: StringFilter<"TwitterEngagement"> | string
    engagementType?: EnumEngagementTypeFilter<"TwitterEngagement"> | $Enums.EngagementType
    points?: IntFilter<"TwitterEngagement"> | number
    verified?: BoolFilter<"TwitterEngagement"> | boolean
    createdAt?: DateTimeFilter<"TwitterEngagement"> | Date | string
  }

  export type TaskCompletionUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskCompletionWhereUniqueInput
    update: XOR<TaskCompletionUpdateWithoutUserInput, TaskCompletionUncheckedUpdateWithoutUserInput>
    create: XOR<TaskCompletionCreateWithoutUserInput, TaskCompletionUncheckedCreateWithoutUserInput>
  }

  export type TaskCompletionUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskCompletionWhereUniqueInput
    data: XOR<TaskCompletionUpdateWithoutUserInput, TaskCompletionUncheckedUpdateWithoutUserInput>
  }

  export type TaskCompletionUpdateManyWithWhereWithoutUserInput = {
    where: TaskCompletionScalarWhereInput
    data: XOR<TaskCompletionUpdateManyMutationInput, TaskCompletionUncheckedUpdateManyWithoutUserInput>
  }

  export type TaskCompletionScalarWhereInput = {
    AND?: TaskCompletionScalarWhereInput | TaskCompletionScalarWhereInput[]
    OR?: TaskCompletionScalarWhereInput[]
    NOT?: TaskCompletionScalarWhereInput | TaskCompletionScalarWhereInput[]
    id?: StringFilter<"TaskCompletion"> | string
    userId?: StringFilter<"TaskCompletion"> | string
    taskId?: StringFilter<"TaskCompletion"> | string
    completed?: BoolFilter<"TaskCompletion"> | boolean
    points?: IntFilter<"TaskCompletion"> | number
    metadata?: JsonNullableFilter<"TaskCompletion">
    completedAt?: DateTimeNullableFilter<"TaskCompletion"> | Date | string | null
    createdAt?: DateTimeFilter<"TaskCompletion"> | Date | string
  }

  export type ClaimUpsertWithWhereUniqueWithoutUserInput = {
    where: ClaimWhereUniqueInput
    update: XOR<ClaimUpdateWithoutUserInput, ClaimUncheckedUpdateWithoutUserInput>
    create: XOR<ClaimCreateWithoutUserInput, ClaimUncheckedCreateWithoutUserInput>
  }

  export type ClaimUpdateWithWhereUniqueWithoutUserInput = {
    where: ClaimWhereUniqueInput
    data: XOR<ClaimUpdateWithoutUserInput, ClaimUncheckedUpdateWithoutUserInput>
  }

  export type ClaimUpdateManyWithWhereWithoutUserInput = {
    where: ClaimScalarWhereInput
    data: XOR<ClaimUpdateManyMutationInput, ClaimUncheckedUpdateManyWithoutUserInput>
  }

  export type ClaimScalarWhereInput = {
    AND?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
    OR?: ClaimScalarWhereInput[]
    NOT?: ClaimScalarWhereInput | ClaimScalarWhereInput[]
    id?: StringFilter<"Claim"> | string
    userId?: StringFilter<"Claim"> | string
    amount?: FloatFilter<"Claim"> | number
    transactionHash?: StringNullableFilter<"Claim"> | string | null
    status?: EnumClaimStatusFilter<"Claim"> | $Enums.ClaimStatus
    paymentMethod?: EnumPaymentMethodFilter<"Claim"> | $Enums.PaymentMethod
    metadata?: JsonNullableFilter<"Claim">
    processedAt?: DateTimeNullableFilter<"Claim"> | Date | string | null
    feesPaid?: DecimalFilter<"Claim"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Claim"> | Date | string
    updatedAt?: DateTimeFilter<"Claim"> | Date | string
    type?: StringNullableFilter<"Claim"> | string | null
    nftPasses?: JsonNullableFilter<"Claim">
    userTier?: StringNullableFilter<"Claim"> | string | null
  }

  export type PointHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: PointHistoryWhereUniqueInput
    update: XOR<PointHistoryUpdateWithoutUserInput, PointHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<PointHistoryCreateWithoutUserInput, PointHistoryUncheckedCreateWithoutUserInput>
  }

  export type PointHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: PointHistoryWhereUniqueInput
    data: XOR<PointHistoryUpdateWithoutUserInput, PointHistoryUncheckedUpdateWithoutUserInput>
  }

  export type PointHistoryUpdateManyWithWhereWithoutUserInput = {
    where: PointHistoryScalarWhereInput
    data: XOR<PointHistoryUpdateManyMutationInput, PointHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type PointHistoryScalarWhereInput = {
    AND?: PointHistoryScalarWhereInput | PointHistoryScalarWhereInput[]
    OR?: PointHistoryScalarWhereInput[]
    NOT?: PointHistoryScalarWhereInput | PointHistoryScalarWhereInput[]
    id?: StringFilter<"PointHistory"> | string
    userId?: StringFilter<"PointHistory"> | string
    points?: IntFilter<"PointHistory"> | number
    action?: StringFilter<"PointHistory"> | string
    description?: StringNullableFilter<"PointHistory"> | string | null
    metadata?: JsonNullableFilter<"PointHistory">
    createdAt?: DateTimeFilter<"PointHistory"> | Date | string
  }

  export type ReferralUpsertWithWhereUniqueWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutReferrerInput, ReferralUncheckedUpdateWithoutReferrerInput>
    create: XOR<ReferralCreateWithoutReferrerInput, ReferralUncheckedCreateWithoutReferrerInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutReferrerInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutReferrerInput, ReferralUncheckedUpdateWithoutReferrerInput>
  }

  export type ReferralUpdateManyWithWhereWithoutReferrerInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutReferrerInput>
  }

  export type ReferralScalarWhereInput = {
    AND?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    OR?: ReferralScalarWhereInput[]
    NOT?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    id?: StringFilter<"Referral"> | string
    referrerId?: StringFilter<"Referral"> | string
    referredId?: StringFilter<"Referral"> | string
    points?: IntFilter<"Referral"> | number
    completed?: BoolFilter<"Referral"> | boolean
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    isActive?: BoolFilter<"Referral"> | boolean
  }

  export type ReferralUpsertWithoutReferredInput = {
    update: XOR<ReferralUpdateWithoutReferredInput, ReferralUncheckedUpdateWithoutReferredInput>
    create: XOR<ReferralCreateWithoutReferredInput, ReferralUncheckedCreateWithoutReferredInput>
    where?: ReferralWhereInput
  }

  export type ReferralUpdateToOneWithWhereWithoutReferredInput = {
    where?: ReferralWhereInput
    data: XOR<ReferralUpdateWithoutReferredInput, ReferralUncheckedUpdateWithoutReferredInput>
  }

  export type ReferralUpdateWithoutReferredInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    referrer?: UserUpdateOneRequiredWithoutReferralsNestedInput
  }

  export type ReferralUncheckedUpdateWithoutReferredInput = {
    id?: StringFieldUpdateOperationsInput | string
    referrerId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutUserInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAchievementScalarWhereInput = {
    AND?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    OR?: UserAchievementScalarWhereInput[]
    NOT?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    userId?: StringFilter<"UserAchievement"> | string
    achievementId?: StringFilter<"UserAchievement"> | string
    unlockedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    progress?: IntFilter<"UserAchievement"> | number
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    read?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type AdminSessionUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminSessionWhereUniqueInput
    update: XOR<AdminSessionUpdateWithoutAdminInput, AdminSessionUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminSessionCreateWithoutAdminInput, AdminSessionUncheckedCreateWithoutAdminInput>
  }

  export type AdminSessionUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminSessionWhereUniqueInput
    data: XOR<AdminSessionUpdateWithoutAdminInput, AdminSessionUncheckedUpdateWithoutAdminInput>
  }

  export type AdminSessionUpdateManyWithWhereWithoutAdminInput = {
    where: AdminSessionScalarWhereInput
    data: XOR<AdminSessionUpdateManyMutationInput, AdminSessionUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminSessionScalarWhereInput = {
    AND?: AdminSessionScalarWhereInput | AdminSessionScalarWhereInput[]
    OR?: AdminSessionScalarWhereInput[]
    NOT?: AdminSessionScalarWhereInput | AdminSessionScalarWhereInput[]
    id?: StringFilter<"AdminSession"> | string
    adminId?: StringFilter<"AdminSession"> | string
    ipAddress?: StringFilter<"AdminSession"> | string
    userAgent?: StringFilter<"AdminSession"> | string
    permissions?: JsonFilter<"AdminSession">
    expiresAt?: DateTimeFilter<"AdminSession"> | Date | string
    lastActivity?: DateTimeFilter<"AdminSession"> | Date | string
    createdAt?: DateTimeFilter<"AdminSession"> | Date | string
  }

  export type AdminAuditLogUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminAuditLogWhereUniqueInput
    update: XOR<AdminAuditLogUpdateWithoutAdminInput, AdminAuditLogUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminAuditLogCreateWithoutAdminInput, AdminAuditLogUncheckedCreateWithoutAdminInput>
  }

  export type AdminAuditLogUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminAuditLogWhereUniqueInput
    data: XOR<AdminAuditLogUpdateWithoutAdminInput, AdminAuditLogUncheckedUpdateWithoutAdminInput>
  }

  export type AdminAuditLogUpdateManyWithWhereWithoutAdminInput = {
    where: AdminAuditLogScalarWhereInput
    data: XOR<AdminAuditLogUpdateManyMutationInput, AdminAuditLogUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminAuditLogScalarWhereInput = {
    AND?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
    OR?: AdminAuditLogScalarWhereInput[]
    NOT?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
    id?: StringFilter<"AdminAuditLog"> | string
    adminId?: StringFilter<"AdminAuditLog"> | string
    action?: StringFilter<"AdminAuditLog"> | string
    metadata?: JsonFilter<"AdminAuditLog">
    timestamp?: DateTimeFilter<"AdminAuditLog"> | Date | string
    ipAddress?: StringFilter<"AdminAuditLog"> | string
  }

  export type FraudAlertUpsertWithWhereUniqueWithoutUserInput = {
    where: FraudAlertWhereUniqueInput
    update: XOR<FraudAlertUpdateWithoutUserInput, FraudAlertUncheckedUpdateWithoutUserInput>
    create: XOR<FraudAlertCreateWithoutUserInput, FraudAlertUncheckedCreateWithoutUserInput>
  }

  export type FraudAlertUpdateWithWhereUniqueWithoutUserInput = {
    where: FraudAlertWhereUniqueInput
    data: XOR<FraudAlertUpdateWithoutUserInput, FraudAlertUncheckedUpdateWithoutUserInput>
  }

  export type FraudAlertUpdateManyWithWhereWithoutUserInput = {
    where: FraudAlertScalarWhereInput
    data: XOR<FraudAlertUpdateManyMutationInput, FraudAlertUncheckedUpdateManyWithoutUserInput>
  }

  export type FraudAlertScalarWhereInput = {
    AND?: FraudAlertScalarWhereInput | FraudAlertScalarWhereInput[]
    OR?: FraudAlertScalarWhereInput[]
    NOT?: FraudAlertScalarWhereInput | FraudAlertScalarWhereInput[]
    id?: StringFilter<"FraudAlert"> | string
    type?: StringFilter<"FraudAlert"> | string
    severity?: StringFilter<"FraudAlert"> | string
    userId?: StringFilter<"FraudAlert"> | string
    description?: StringFilter<"FraudAlert"> | string
    evidence?: JsonFilter<"FraudAlert">
    riskScore?: IntFilter<"FraudAlert"> | number
    status?: StringFilter<"FraudAlert"> | string
    createdAt?: DateTimeFilter<"FraudAlert"> | Date | string
    investigatedBy?: StringNullableFilter<"FraudAlert"> | string | null
    resolvedAt?: DateTimeNullableFilter<"FraudAlert"> | Date | string | null
  }

  export type CampaignConfigUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CampaignConfigWhereUniqueInput
    update: XOR<CampaignConfigUpdateWithoutCreatorInput, CampaignConfigUncheckedUpdateWithoutCreatorInput>
    create: XOR<CampaignConfigCreateWithoutCreatorInput, CampaignConfigUncheckedCreateWithoutCreatorInput>
  }

  export type CampaignConfigUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CampaignConfigWhereUniqueInput
    data: XOR<CampaignConfigUpdateWithoutCreatorInput, CampaignConfigUncheckedUpdateWithoutCreatorInput>
  }

  export type CampaignConfigUpdateManyWithWhereWithoutCreatorInput = {
    where: CampaignConfigScalarWhereInput
    data: XOR<CampaignConfigUpdateManyMutationInput, CampaignConfigUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CampaignConfigScalarWhereInput = {
    AND?: CampaignConfigScalarWhereInput | CampaignConfigScalarWhereInput[]
    OR?: CampaignConfigScalarWhereInput[]
    NOT?: CampaignConfigScalarWhereInput | CampaignConfigScalarWhereInput[]
    id?: StringFilter<"CampaignConfig"> | string
    name?: StringFilter<"CampaignConfig"> | string
    description?: StringNullableFilter<"CampaignConfig"> | string | null
    tokenMint?: StringFilter<"CampaignConfig"> | string
    totalAllocation?: BigIntFilter<"CampaignConfig"> | bigint | number
    startDate?: DateTimeFilter<"CampaignConfig"> | Date | string
    endDate?: DateTimeFilter<"CampaignConfig"> | Date | string
    eligibilityCriteria?: JsonFilter<"CampaignConfig">
    distributionRules?: JsonFilter<"CampaignConfig">
    isActive?: BoolFilter<"CampaignConfig"> | boolean
    createdBy?: StringFilter<"CampaignConfig"> | string
    createdAt?: DateTimeFilter<"CampaignConfig"> | Date | string
    updatedAt?: DateTimeFilter<"CampaignConfig"> | Date | string
  }

  export type NftCollectionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: NftCollectionWhereUniqueInput
    update: XOR<NftCollectionUpdateWithoutCreatorInput, NftCollectionUncheckedUpdateWithoutCreatorInput>
    create: XOR<NftCollectionCreateWithoutCreatorInput, NftCollectionUncheckedCreateWithoutCreatorInput>
  }

  export type NftCollectionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: NftCollectionWhereUniqueInput
    data: XOR<NftCollectionUpdateWithoutCreatorInput, NftCollectionUncheckedUpdateWithoutCreatorInput>
  }

  export type NftCollectionUpdateManyWithWhereWithoutCreatorInput = {
    where: NftCollectionScalarWhereInput
    data: XOR<NftCollectionUpdateManyMutationInput, NftCollectionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type NftCollectionScalarWhereInput = {
    AND?: NftCollectionScalarWhereInput | NftCollectionScalarWhereInput[]
    OR?: NftCollectionScalarWhereInput[]
    NOT?: NftCollectionScalarWhereInput | NftCollectionScalarWhereInput[]
    id?: StringFilter<"NftCollection"> | string
    mintAddress?: StringFilter<"NftCollection"> | string
    name?: StringFilter<"NftCollection"> | string
    symbol?: StringFilter<"NftCollection"> | string
    description?: StringNullableFilter<"NftCollection"> | string | null
    uri?: StringFilter<"NftCollection"> | string
    supply?: IntFilter<"NftCollection"> | number
    createdBy?: StringFilter<"NftCollection"> | string
    metadata?: JsonNullableFilter<"NftCollection">
    createdAt?: DateTimeFilter<"NftCollection"> | Date | string
    updatedAt?: DateTimeFilter<"NftCollection"> | Date | string
  }

  export type NftDistributionUpsertWithWhereUniqueWithoutDistributorInput = {
    where: NftDistributionWhereUniqueInput
    update: XOR<NftDistributionUpdateWithoutDistributorInput, NftDistributionUncheckedUpdateWithoutDistributorInput>
    create: XOR<NftDistributionCreateWithoutDistributorInput, NftDistributionUncheckedCreateWithoutDistributorInput>
  }

  export type NftDistributionUpdateWithWhereUniqueWithoutDistributorInput = {
    where: NftDistributionWhereUniqueInput
    data: XOR<NftDistributionUpdateWithoutDistributorInput, NftDistributionUncheckedUpdateWithoutDistributorInput>
  }

  export type NftDistributionUpdateManyWithWhereWithoutDistributorInput = {
    where: NftDistributionScalarWhereInput
    data: XOR<NftDistributionUpdateManyMutationInput, NftDistributionUncheckedUpdateManyWithoutDistributorInput>
  }

  export type NftDistributionScalarWhereInput = {
    AND?: NftDistributionScalarWhereInput | NftDistributionScalarWhereInput[]
    OR?: NftDistributionScalarWhereInput[]
    NOT?: NftDistributionScalarWhereInput | NftDistributionScalarWhereInput[]
    id?: StringFilter<"NftDistribution"> | string
    mintAddress?: StringFilter<"NftDistribution"> | string
    distributedBy?: StringFilter<"NftDistribution"> | string
    recipientCount?: IntFilter<"NftDistribution"> | number
    nftsPerUser?: IntFilter<"NftDistribution"> | number
    results?: JsonFilter<"NftDistribution">
    success?: BoolFilter<"NftDistribution"> | boolean
    createdAt?: DateTimeFilter<"NftDistribution"> | Date | string
    updatedAt?: DateTimeFilter<"NftDistribution"> | Date | string
  }

  export type UserNftHoldingUpsertWithWhereUniqueWithoutUserInput = {
    where: UserNftHoldingWhereUniqueInput
    update: XOR<UserNftHoldingUpdateWithoutUserInput, UserNftHoldingUncheckedUpdateWithoutUserInput>
    create: XOR<UserNftHoldingCreateWithoutUserInput, UserNftHoldingUncheckedCreateWithoutUserInput>
  }

  export type UserNftHoldingUpdateWithWhereUniqueWithoutUserInput = {
    where: UserNftHoldingWhereUniqueInput
    data: XOR<UserNftHoldingUpdateWithoutUserInput, UserNftHoldingUncheckedUpdateWithoutUserInput>
  }

  export type UserNftHoldingUpdateManyWithWhereWithoutUserInput = {
    where: UserNftHoldingScalarWhereInput
    data: XOR<UserNftHoldingUpdateManyMutationInput, UserNftHoldingUncheckedUpdateManyWithoutUserInput>
  }

  export type UserNftHoldingScalarWhereInput = {
    AND?: UserNftHoldingScalarWhereInput | UserNftHoldingScalarWhereInput[]
    OR?: UserNftHoldingScalarWhereInput[]
    NOT?: UserNftHoldingScalarWhereInput | UserNftHoldingScalarWhereInput[]
    id?: StringFilter<"UserNftHolding"> | string
    userId?: StringFilter<"UserNftHolding"> | string
    mintAddress?: StringFilter<"UserNftHolding"> | string
    tokenAccount?: StringFilter<"UserNftHolding"> | string
    amount?: IntFilter<"UserNftHolding"> | number
    metadata?: JsonNullableFilter<"UserNftHolding">
    acquiredAt?: DateTimeFilter<"UserNftHolding"> | Date | string
    createdAt?: DateTimeFilter<"UserNftHolding"> | Date | string
    updatedAt?: DateTimeFilter<"UserNftHolding"> | Date | string
  }

  export type NftClaimApprovalUpsertWithoutUserInput = {
    update: XOR<NftClaimApprovalUpdateWithoutUserInput, NftClaimApprovalUncheckedUpdateWithoutUserInput>
    create: XOR<NftClaimApprovalCreateWithoutUserInput, NftClaimApprovalUncheckedCreateWithoutUserInput>
    where?: NftClaimApprovalWhereInput
  }

  export type NftClaimApprovalUpdateToOneWithWhereWithoutUserInput = {
    where?: NftClaimApprovalWhereInput
    data: XOR<NftClaimApprovalUpdateWithoutUserInput, NftClaimApprovalUncheckedUpdateWithoutUserInput>
  }

  export type NftClaimApprovalUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approver?: UserUpdateOneWithoutApprovedClaimsNestedInput
  }

  export type NftClaimApprovalUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NftClaimApprovalUpsertWithWhereUniqueWithoutApproverInput = {
    where: NftClaimApprovalWhereUniqueInput
    update: XOR<NftClaimApprovalUpdateWithoutApproverInput, NftClaimApprovalUncheckedUpdateWithoutApproverInput>
    create: XOR<NftClaimApprovalCreateWithoutApproverInput, NftClaimApprovalUncheckedCreateWithoutApproverInput>
  }

  export type NftClaimApprovalUpdateWithWhereUniqueWithoutApproverInput = {
    where: NftClaimApprovalWhereUniqueInput
    data: XOR<NftClaimApprovalUpdateWithoutApproverInput, NftClaimApprovalUncheckedUpdateWithoutApproverInput>
  }

  export type NftClaimApprovalUpdateManyWithWhereWithoutApproverInput = {
    where: NftClaimApprovalScalarWhereInput
    data: XOR<NftClaimApprovalUpdateManyMutationInput, NftClaimApprovalUncheckedUpdateManyWithoutApproverInput>
  }

  export type NftClaimApprovalScalarWhereInput = {
    AND?: NftClaimApprovalScalarWhereInput | NftClaimApprovalScalarWhereInput[]
    OR?: NftClaimApprovalScalarWhereInput[]
    NOT?: NftClaimApprovalScalarWhereInput | NftClaimApprovalScalarWhereInput[]
    id?: StringFilter<"NftClaimApproval"> | string
    userId?: StringFilter<"NftClaimApproval"> | string
    approved?: BoolFilter<"NftClaimApproval"> | boolean
    approvedBy?: StringNullableFilter<"NftClaimApproval"> | string | null
    approvedAt?: DateTimeNullableFilter<"NftClaimApproval"> | Date | string | null
    createdAt?: DateTimeFilter<"NftClaimApproval"> | Date | string
    updatedAt?: DateTimeFilter<"NftClaimApproval"> | Date | string
  }

  export type AirdropSeasonUpsertWithWhereUniqueWithoutCreatorInput = {
    where: AirdropSeasonWhereUniqueInput
    update: XOR<AirdropSeasonUpdateWithoutCreatorInput, AirdropSeasonUncheckedUpdateWithoutCreatorInput>
    create: XOR<AirdropSeasonCreateWithoutCreatorInput, AirdropSeasonUncheckedCreateWithoutCreatorInput>
  }

  export type AirdropSeasonUpdateWithWhereUniqueWithoutCreatorInput = {
    where: AirdropSeasonWhereUniqueInput
    data: XOR<AirdropSeasonUpdateWithoutCreatorInput, AirdropSeasonUncheckedUpdateWithoutCreatorInput>
  }

  export type AirdropSeasonUpdateManyWithWhereWithoutCreatorInput = {
    where: AirdropSeasonScalarWhereInput
    data: XOR<AirdropSeasonUpdateManyMutationInput, AirdropSeasonUncheckedUpdateManyWithoutCreatorInput>
  }

  export type AirdropSeasonScalarWhereInput = {
    AND?: AirdropSeasonScalarWhereInput | AirdropSeasonScalarWhereInput[]
    OR?: AirdropSeasonScalarWhereInput[]
    NOT?: AirdropSeasonScalarWhereInput | AirdropSeasonScalarWhereInput[]
    id?: StringFilter<"AirdropSeason"> | string
    name?: StringFilter<"AirdropSeason"> | string
    description?: StringNullableFilter<"AirdropSeason"> | string | null
    status?: StringFilter<"AirdropSeason"> | string
    totalAllocation?: BigIntFilter<"AirdropSeason"> | bigint | number
    claimedAmount?: BigIntFilter<"AirdropSeason"> | bigint | number
    startDate?: DateTimeFilter<"AirdropSeason"> | Date | string
    endDate?: DateTimeNullableFilter<"AirdropSeason"> | Date | string | null
    nftPassRequired?: BoolFilter<"AirdropSeason"> | boolean
    requireApproval?: BoolFilter<"AirdropSeason"> | boolean
    feeAmount?: DecimalFilter<"AirdropSeason"> | Decimal | DecimalJsLike | number | string
    createdBy?: StringFilter<"AirdropSeason"> | string
    metadata?: JsonNullableFilter<"AirdropSeason">
    createdAt?: DateTimeFilter<"AirdropSeason"> | Date | string
    updatedAt?: DateTimeFilter<"AirdropSeason"> | Date | string
  }

  export type UserAchievementCreateWithoutAchievementInput = {
    id?: string
    unlockedAt?: Date | string
    progress?: number
    user: UserCreateNestedOneWithoutAchievementsInput
  }

  export type UserAchievementUncheckedCreateWithoutAchievementInput = {
    id?: string
    userId: string
    unlockedAt?: Date | string
    progress?: number
  }

  export type UserAchievementCreateOrConnectWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput>
  }

  export type UserAchievementCreateManyAchievementInputEnvelope = {
    data: UserAchievementCreateManyAchievementInput | UserAchievementCreateManyAchievementInput[]
    skipDuplicates?: boolean
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutAchievementInput, UserAchievementUncheckedUpdateWithoutAchievementInput>
    create: XOR<UserAchievementCreateWithoutAchievementInput, UserAchievementUncheckedCreateWithoutAchievementInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutAchievementInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutAchievementInput, UserAchievementUncheckedUpdateWithoutAchievementInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutAchievementInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutAchievementInput>
  }

  export type UserCreateWithoutAchievementsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionCreateNestedManyWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutReferredInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutAchievementsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningUncheckedCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimUncheckedCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionUncheckedCreateNestedManyWithoutUserInput
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigUncheckedCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionUncheckedCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionUncheckedCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingUncheckedCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalUncheckedCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalUncheckedCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAchievementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
  }

  export type AchievementCreateWithoutUserAchievementsInput = {
    id?: string
    name: string
    description: string
    icon: string
    requirements: JsonNullValueInput | InputJsonValue
    points: number
    isSecret?: boolean
    createdAt?: Date | string
  }

  export type AchievementUncheckedCreateWithoutUserAchievementsInput = {
    id?: string
    name: string
    description: string
    icon: string
    requirements: JsonNullValueInput | InputJsonValue
    points: number
    isSecret?: boolean
    createdAt?: Date | string
  }

  export type AchievementCreateOrConnectWithoutUserAchievementsInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutUserAchievementsInput, AchievementUncheckedCreateWithoutUserAchievementsInput>
  }

  export type UserUpsertWithoutAchievementsInput = {
    update: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUpdateManyWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUncheckedUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUncheckedUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUncheckedUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUncheckedUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUncheckedUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUncheckedUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUncheckedUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUncheckedUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AchievementUpsertWithoutUserAchievementsInput = {
    update: XOR<AchievementUpdateWithoutUserAchievementsInput, AchievementUncheckedUpdateWithoutUserAchievementsInput>
    create: XOR<AchievementCreateWithoutUserAchievementsInput, AchievementUncheckedCreateWithoutUserAchievementsInput>
    where?: AchievementWhereInput
  }

  export type AchievementUpdateToOneWithWhereWithoutUserAchievementsInput = {
    where?: AchievementWhereInput
    data: XOR<AchievementUpdateWithoutUserAchievementsInput, AchievementUncheckedUpdateWithoutUserAchievementsInput>
  }

  export type AchievementUpdateWithoutUserAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    requirements?: JsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    isSecret?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AchievementUncheckedUpdateWithoutUserAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    requirements?: JsonNullValueInput | InputJsonValue
    points?: IntFieldUpdateOperationsInput | number
    isSecret?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionCreateNestedManyWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningUncheckedCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimUncheckedCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionUncheckedCreateNestedManyWithoutUserInput
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigUncheckedCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionUncheckedCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionUncheckedCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingUncheckedCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalUncheckedCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalUncheckedCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUpdateManyWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUncheckedUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUncheckedUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUncheckedUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUncheckedUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUncheckedUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUncheckedUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUncheckedUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUncheckedUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutEngagementsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionCreateNestedManyWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutEngagementsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningUncheckedCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionUncheckedCreateNestedManyWithoutUserInput
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigUncheckedCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionUncheckedCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionUncheckedCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingUncheckedCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalUncheckedCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalUncheckedCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutEngagementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEngagementsInput, UserUncheckedCreateWithoutEngagementsInput>
  }

  export type UserUpsertWithoutEngagementsInput = {
    update: XOR<UserUpdateWithoutEngagementsInput, UserUncheckedUpdateWithoutEngagementsInput>
    create: XOR<UserCreateWithoutEngagementsInput, UserUncheckedCreateWithoutEngagementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEngagementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEngagementsInput, UserUncheckedUpdateWithoutEngagementsInput>
  }

  export type UserUpdateWithoutEngagementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUpdateManyWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutEngagementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUncheckedUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUncheckedUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUncheckedUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUncheckedUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUncheckedUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUncheckedUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUncheckedUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type TaskCompletionCreateWithoutTaskInput = {
    id?: string
    completed?: boolean
    points: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTasksInput
  }

  export type TaskCompletionUncheckedCreateWithoutTaskInput = {
    id?: string
    userId: string
    completed?: boolean
    points: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TaskCompletionCreateOrConnectWithoutTaskInput = {
    where: TaskCompletionWhereUniqueInput
    create: XOR<TaskCompletionCreateWithoutTaskInput, TaskCompletionUncheckedCreateWithoutTaskInput>
  }

  export type TaskCompletionCreateManyTaskInputEnvelope = {
    data: TaskCompletionCreateManyTaskInput | TaskCompletionCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type TaskCompletionUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskCompletionWhereUniqueInput
    update: XOR<TaskCompletionUpdateWithoutTaskInput, TaskCompletionUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskCompletionCreateWithoutTaskInput, TaskCompletionUncheckedCreateWithoutTaskInput>
  }

  export type TaskCompletionUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskCompletionWhereUniqueInput
    data: XOR<TaskCompletionUpdateWithoutTaskInput, TaskCompletionUncheckedUpdateWithoutTaskInput>
  }

  export type TaskCompletionUpdateManyWithWhereWithoutTaskInput = {
    where: TaskCompletionScalarWhereInput
    data: XOR<TaskCompletionUpdateManyMutationInput, TaskCompletionUncheckedUpdateManyWithoutTaskInput>
  }

  export type UserCreateWithoutAdminSessionsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionCreateNestedManyWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutAdminSessionsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningUncheckedCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimUncheckedCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionUncheckedCreateNestedManyWithoutUserInput
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigUncheckedCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionUncheckedCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionUncheckedCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingUncheckedCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalUncheckedCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalUncheckedCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAdminSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminSessionsInput, UserUncheckedCreateWithoutAdminSessionsInput>
  }

  export type UserUpsertWithoutAdminSessionsInput = {
    update: XOR<UserUpdateWithoutAdminSessionsInput, UserUncheckedUpdateWithoutAdminSessionsInput>
    create: XOR<UserCreateWithoutAdminSessionsInput, UserUncheckedCreateWithoutAdminSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminSessionsInput, UserUncheckedUpdateWithoutAdminSessionsInput>
  }

  export type UserUpdateWithoutAdminSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUpdateManyWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUncheckedUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUncheckedUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUncheckedUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUncheckedUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUncheckedUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUncheckedUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUncheckedUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUncheckedUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionCreateNestedManyWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningUncheckedCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimUncheckedCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionUncheckedCreateNestedManyWithoutUserInput
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigUncheckedCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionUncheckedCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionUncheckedCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingUncheckedCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalUncheckedCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalUncheckedCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUpdateManyWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUncheckedUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUncheckedUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUncheckedUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUncheckedUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUncheckedUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUncheckedUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUncheckedUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUncheckedUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutFraudAlertsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionCreateNestedManyWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    campaigns?: CampaignConfigCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutFraudAlertsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningUncheckedCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimUncheckedCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionUncheckedCreateNestedManyWithoutUserInput
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    campaigns?: CampaignConfigUncheckedCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionUncheckedCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionUncheckedCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingUncheckedCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalUncheckedCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalUncheckedCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutFraudAlertsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFraudAlertsInput, UserUncheckedCreateWithoutFraudAlertsInput>
  }

  export type UserUpsertWithoutFraudAlertsInput = {
    update: XOR<UserUpdateWithoutFraudAlertsInput, UserUncheckedUpdateWithoutFraudAlertsInput>
    create: XOR<UserCreateWithoutFraudAlertsInput, UserUncheckedCreateWithoutFraudAlertsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFraudAlertsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFraudAlertsInput, UserUncheckedUpdateWithoutFraudAlertsInput>
  }

  export type UserUpdateWithoutFraudAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUpdateManyWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    campaigns?: CampaignConfigUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutFraudAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUncheckedUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUncheckedUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    campaigns?: CampaignConfigUncheckedUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUncheckedUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUncheckedUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUncheckedUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUncheckedUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUncheckedUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutCampaignsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionCreateNestedManyWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertCreateNestedManyWithoutUserInput
    nftCollections?: NftCollectionCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCampaignsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningUncheckedCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimUncheckedCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionUncheckedCreateNestedManyWithoutUserInput
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertUncheckedCreateNestedManyWithoutUserInput
    nftCollections?: NftCollectionUncheckedCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionUncheckedCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingUncheckedCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalUncheckedCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalUncheckedCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCampaignsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
  }

  export type UserUpsertWithoutCampaignsInput = {
    update: XOR<UserUpdateWithoutCampaignsInput, UserUncheckedUpdateWithoutCampaignsInput>
    create: XOR<UserCreateWithoutCampaignsInput, UserUncheckedCreateWithoutCampaignsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCampaignsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCampaignsInput, UserUncheckedUpdateWithoutCampaignsInput>
  }

  export type UserUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUpdateManyWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUpdateManyWithoutUserNestedInput
    nftCollections?: NftCollectionUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCampaignsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUncheckedUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUncheckedUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUncheckedUpdateManyWithoutUserNestedInput
    nftCollections?: NftCollectionUncheckedUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUncheckedUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUncheckedUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUncheckedUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUncheckedUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutTasksInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementCreateNestedManyWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutTasksInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningUncheckedCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimUncheckedCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementUncheckedCreateNestedManyWithoutUserInput
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigUncheckedCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionUncheckedCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionUncheckedCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingUncheckedCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalUncheckedCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalUncheckedCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
  }

  export type TaskCreateWithoutCompletionsInput = {
    id?: string
    name: string
    description: string
    type: $Enums.TaskType
    points: number
    requirements: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUncheckedCreateWithoutCompletionsInput = {
    id?: string
    name: string
    description: string
    type: $Enums.TaskType
    points: number
    requirements: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutCompletionsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutCompletionsInput, TaskUncheckedCreateWithoutCompletionsInput>
  }

  export type UserUpsertWithoutTasksInput = {
    update: XOR<UserUpdateWithoutTasksInput, UserUncheckedUpdateWithoutTasksInput>
    create: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksInput, UserUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUpdateManyWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUncheckedUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUncheckedUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUncheckedUpdateManyWithoutUserNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUncheckedUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUncheckedUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUncheckedUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUncheckedUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUncheckedUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUncheckedUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type TaskUpsertWithoutCompletionsInput = {
    update: XOR<TaskUpdateWithoutCompletionsInput, TaskUncheckedUpdateWithoutCompletionsInput>
    create: XOR<TaskCreateWithoutCompletionsInput, TaskUncheckedCreateWithoutCompletionsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutCompletionsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutCompletionsInput, TaskUncheckedUpdateWithoutCompletionsInput>
  }

  export type TaskUpdateWithoutCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    points?: IntFieldUpdateOperationsInput | number
    requirements?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateWithoutCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    points?: IntFieldUpdateOperationsInput | number
    requirements?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutClaimsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutClaimsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningUncheckedCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimUncheckedCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionUncheckedCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigUncheckedCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionUncheckedCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionUncheckedCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingUncheckedCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalUncheckedCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalUncheckedCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutClaimsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClaimsInput, UserUncheckedCreateWithoutClaimsInput>
  }

  export type UserUpsertWithoutClaimsInput = {
    update: XOR<UserUpdateWithoutClaimsInput, UserUncheckedUpdateWithoutClaimsInput>
    create: XOR<UserCreateWithoutClaimsInput, UserUncheckedCreateWithoutClaimsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutClaimsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutClaimsInput, UserUncheckedUpdateWithoutClaimsInput>
  }

  export type UserUpdateWithoutClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUncheckedUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUncheckedUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUncheckedUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUncheckedUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUncheckedUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUncheckedUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUncheckedUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUncheckedUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutPointHistoryInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionCreateNestedManyWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutPointHistoryInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningUncheckedCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimUncheckedCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionUncheckedCreateNestedManyWithoutUserInput
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigUncheckedCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionUncheckedCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionUncheckedCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingUncheckedCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalUncheckedCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalUncheckedCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutPointHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPointHistoryInput, UserUncheckedCreateWithoutPointHistoryInput>
  }

  export type UserUpsertWithoutPointHistoryInput = {
    update: XOR<UserUpdateWithoutPointHistoryInput, UserUncheckedUpdateWithoutPointHistoryInput>
    create: XOR<UserCreateWithoutPointHistoryInput, UserUncheckedCreateWithoutPointHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPointHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPointHistoryInput, UserUncheckedUpdateWithoutPointHistoryInput>
  }

  export type UserUpdateWithoutPointHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUpdateManyWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutPointHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUncheckedUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUncheckedUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUncheckedUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUncheckedUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUncheckedUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUncheckedUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUncheckedUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUncheckedUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutReferralsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionCreateNestedManyWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryCreateNestedManyWithoutUserInput
    referredBy?: ReferralCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutReferralsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningUncheckedCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimUncheckedCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionUncheckedCreateNestedManyWithoutUserInput
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigUncheckedCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionUncheckedCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionUncheckedCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingUncheckedCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalUncheckedCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalUncheckedCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutReferralsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
  }

  export type UserCreateWithoutReferredByInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionCreateNestedManyWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutReferredByInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningUncheckedCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimUncheckedCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionUncheckedCreateNestedManyWithoutUserInput
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigUncheckedCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionUncheckedCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionUncheckedCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingUncheckedCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalUncheckedCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalUncheckedCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutReferredByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput>
  }

  export type UserUpsertWithoutReferralsInput = {
    update: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
    create: XOR<UserCreateWithoutReferralsInput, UserUncheckedCreateWithoutReferralsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferralsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferralsInput, UserUncheckedUpdateWithoutReferralsInput>
  }

  export type UserUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUpdateManyWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUpdateManyWithoutUserNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutReferralsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUncheckedUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUncheckedUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUncheckedUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUncheckedUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUncheckedUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUncheckedUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUncheckedUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUncheckedUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUpsertWithoutReferredByInput = {
    update: XOR<UserUpdateWithoutReferredByInput, UserUncheckedUpdateWithoutReferredByInput>
    create: XOR<UserCreateWithoutReferredByInput, UserUncheckedCreateWithoutReferredByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReferredByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReferredByInput, UserUncheckedUpdateWithoutReferredByInput>
  }

  export type UserUpdateWithoutReferredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUpdateManyWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutReferredByInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUncheckedUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUncheckedUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUncheckedUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUncheckedUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUncheckedUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUncheckedUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUncheckedUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUncheckedUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutDailyEarningsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    airdropClaims?: AirdropClaimCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionCreateNestedManyWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutDailyEarningsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    airdropClaims?: AirdropClaimUncheckedCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionUncheckedCreateNestedManyWithoutUserInput
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigUncheckedCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionUncheckedCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionUncheckedCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingUncheckedCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalUncheckedCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalUncheckedCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutDailyEarningsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDailyEarningsInput, UserUncheckedCreateWithoutDailyEarningsInput>
  }

  export type UserUpsertWithoutDailyEarningsInput = {
    update: XOR<UserUpdateWithoutDailyEarningsInput, UserUncheckedUpdateWithoutDailyEarningsInput>
    create: XOR<UserCreateWithoutDailyEarningsInput, UserUncheckedCreateWithoutDailyEarningsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDailyEarningsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDailyEarningsInput, UserUncheckedUpdateWithoutDailyEarningsInput>
  }

  export type UserUpdateWithoutDailyEarningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    airdropClaims?: AirdropClaimUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUpdateManyWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutDailyEarningsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    airdropClaims?: AirdropClaimUncheckedUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUncheckedUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUncheckedUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUncheckedUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUncheckedUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUncheckedUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUncheckedUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutAirdropSeasonsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionCreateNestedManyWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutAirdropSeasonsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningUncheckedCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimUncheckedCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionUncheckedCreateNestedManyWithoutUserInput
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigUncheckedCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionUncheckedCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionUncheckedCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingUncheckedCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalUncheckedCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutAirdropSeasonsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAirdropSeasonsInput, UserUncheckedCreateWithoutAirdropSeasonsInput>
  }

  export type AirdropClaimCreateWithoutSeasonInput = {
    id?: string
    tokens: number
    tier: string
    paymentSignature: string
    transactionSignature?: string | null
    status: string
    claimedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAirdropClaimsInput
  }

  export type AirdropClaimUncheckedCreateWithoutSeasonInput = {
    id?: string
    userId: string
    tokens: number
    tier: string
    paymentSignature: string
    transactionSignature?: string | null
    status: string
    claimedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AirdropClaimCreateOrConnectWithoutSeasonInput = {
    where: AirdropClaimWhereUniqueInput
    create: XOR<AirdropClaimCreateWithoutSeasonInput, AirdropClaimUncheckedCreateWithoutSeasonInput>
  }

  export type AirdropClaimCreateManySeasonInputEnvelope = {
    data: AirdropClaimCreateManySeasonInput | AirdropClaimCreateManySeasonInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAirdropSeasonsInput = {
    update: XOR<UserUpdateWithoutAirdropSeasonsInput, UserUncheckedUpdateWithoutAirdropSeasonsInput>
    create: XOR<UserCreateWithoutAirdropSeasonsInput, UserUncheckedCreateWithoutAirdropSeasonsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAirdropSeasonsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAirdropSeasonsInput, UserUncheckedUpdateWithoutAirdropSeasonsInput>
  }

  export type UserUpdateWithoutAirdropSeasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUpdateManyWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutAirdropSeasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUncheckedUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUncheckedUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUncheckedUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUncheckedUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUncheckedUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUncheckedUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUncheckedUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type AirdropClaimUpsertWithWhereUniqueWithoutSeasonInput = {
    where: AirdropClaimWhereUniqueInput
    update: XOR<AirdropClaimUpdateWithoutSeasonInput, AirdropClaimUncheckedUpdateWithoutSeasonInput>
    create: XOR<AirdropClaimCreateWithoutSeasonInput, AirdropClaimUncheckedCreateWithoutSeasonInput>
  }

  export type AirdropClaimUpdateWithWhereUniqueWithoutSeasonInput = {
    where: AirdropClaimWhereUniqueInput
    data: XOR<AirdropClaimUpdateWithoutSeasonInput, AirdropClaimUncheckedUpdateWithoutSeasonInput>
  }

  export type AirdropClaimUpdateManyWithWhereWithoutSeasonInput = {
    where: AirdropClaimScalarWhereInput
    data: XOR<AirdropClaimUpdateManyMutationInput, AirdropClaimUncheckedUpdateManyWithoutSeasonInput>
  }

  export type UserCreateWithoutAirdropClaimsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionCreateNestedManyWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutAirdropClaimsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningUncheckedCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionUncheckedCreateNestedManyWithoutUserInput
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigUncheckedCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionUncheckedCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionUncheckedCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingUncheckedCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalUncheckedCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalUncheckedCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutAirdropClaimsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAirdropClaimsInput, UserUncheckedCreateWithoutAirdropClaimsInput>
  }

  export type AirdropSeasonCreateWithoutClaimsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    totalAllocation: bigint | number
    claimedAmount?: bigint | number
    startDate?: Date | string
    endDate?: Date | string | null
    nftPassRequired?: boolean
    requireApproval?: boolean
    feeAmount?: Decimal | DecimalJsLike | number | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutAirdropSeasonsInput
  }

  export type AirdropSeasonUncheckedCreateWithoutClaimsInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    totalAllocation: bigint | number
    claimedAmount?: bigint | number
    startDate?: Date | string
    endDate?: Date | string | null
    nftPassRequired?: boolean
    requireApproval?: boolean
    feeAmount?: Decimal | DecimalJsLike | number | string
    createdBy: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AirdropSeasonCreateOrConnectWithoutClaimsInput = {
    where: AirdropSeasonWhereUniqueInput
    create: XOR<AirdropSeasonCreateWithoutClaimsInput, AirdropSeasonUncheckedCreateWithoutClaimsInput>
  }

  export type UserUpsertWithoutAirdropClaimsInput = {
    update: XOR<UserUpdateWithoutAirdropClaimsInput, UserUncheckedUpdateWithoutAirdropClaimsInput>
    create: XOR<UserCreateWithoutAirdropClaimsInput, UserUncheckedCreateWithoutAirdropClaimsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAirdropClaimsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAirdropClaimsInput, UserUncheckedUpdateWithoutAirdropClaimsInput>
  }

  export type UserUpdateWithoutAirdropClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUpdateManyWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutAirdropClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUncheckedUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUncheckedUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUncheckedUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUncheckedUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUncheckedUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUncheckedUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUncheckedUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type AirdropSeasonUpsertWithoutClaimsInput = {
    update: XOR<AirdropSeasonUpdateWithoutClaimsInput, AirdropSeasonUncheckedUpdateWithoutClaimsInput>
    create: XOR<AirdropSeasonCreateWithoutClaimsInput, AirdropSeasonUncheckedCreateWithoutClaimsInput>
    where?: AirdropSeasonWhereInput
  }

  export type AirdropSeasonUpdateToOneWithWhereWithoutClaimsInput = {
    where?: AirdropSeasonWhereInput
    data: XOR<AirdropSeasonUpdateWithoutClaimsInput, AirdropSeasonUncheckedUpdateWithoutClaimsInput>
  }

  export type AirdropSeasonUpdateWithoutClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalAllocation?: BigIntFieldUpdateOperationsInput | bigint | number
    claimedAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nftPassRequired?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutAirdropSeasonsNestedInput
  }

  export type AirdropSeasonUncheckedUpdateWithoutClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalAllocation?: BigIntFieldUpdateOperationsInput | bigint | number
    claimedAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nftPassRequired?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdBy?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutNftCollectionsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionCreateNestedManyWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutNftCollectionsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningUncheckedCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimUncheckedCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionUncheckedCreateNestedManyWithoutUserInput
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigUncheckedCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionUncheckedCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingUncheckedCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalUncheckedCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalUncheckedCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutNftCollectionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNftCollectionsInput, UserUncheckedCreateWithoutNftCollectionsInput>
  }

  export type NftDistributionCreateWithoutCollectionInput = {
    id?: string
    recipientCount: number
    nftsPerUser: number
    results: JsonNullValueInput | InputJsonValue
    success?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    distributor: UserCreateNestedOneWithoutNftDistributionsInput
  }

  export type NftDistributionUncheckedCreateWithoutCollectionInput = {
    id?: string
    distributedBy: string
    recipientCount: number
    nftsPerUser: number
    results: JsonNullValueInput | InputJsonValue
    success?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NftDistributionCreateOrConnectWithoutCollectionInput = {
    where: NftDistributionWhereUniqueInput
    create: XOR<NftDistributionCreateWithoutCollectionInput, NftDistributionUncheckedCreateWithoutCollectionInput>
  }

  export type NftDistributionCreateManyCollectionInputEnvelope = {
    data: NftDistributionCreateManyCollectionInput | NftDistributionCreateManyCollectionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutNftCollectionsInput = {
    update: XOR<UserUpdateWithoutNftCollectionsInput, UserUncheckedUpdateWithoutNftCollectionsInput>
    create: XOR<UserCreateWithoutNftCollectionsInput, UserUncheckedCreateWithoutNftCollectionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNftCollectionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNftCollectionsInput, UserUncheckedUpdateWithoutNftCollectionsInput>
  }

  export type UserUpdateWithoutNftCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUpdateManyWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutNftCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUncheckedUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUncheckedUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUncheckedUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUncheckedUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUncheckedUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUncheckedUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUncheckedUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type NftDistributionUpsertWithWhereUniqueWithoutCollectionInput = {
    where: NftDistributionWhereUniqueInput
    update: XOR<NftDistributionUpdateWithoutCollectionInput, NftDistributionUncheckedUpdateWithoutCollectionInput>
    create: XOR<NftDistributionCreateWithoutCollectionInput, NftDistributionUncheckedCreateWithoutCollectionInput>
  }

  export type NftDistributionUpdateWithWhereUniqueWithoutCollectionInput = {
    where: NftDistributionWhereUniqueInput
    data: XOR<NftDistributionUpdateWithoutCollectionInput, NftDistributionUncheckedUpdateWithoutCollectionInput>
  }

  export type NftDistributionUpdateManyWithWhereWithoutCollectionInput = {
    where: NftDistributionScalarWhereInput
    data: XOR<NftDistributionUpdateManyMutationInput, NftDistributionUncheckedUpdateManyWithoutCollectionInput>
  }

  export type NftCollectionCreateWithoutDistributionsInput = {
    id?: string
    mintAddress: string
    name: string
    symbol: string
    description?: string | null
    uri: string
    supply?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutNftCollectionsInput
  }

  export type NftCollectionUncheckedCreateWithoutDistributionsInput = {
    id?: string
    mintAddress: string
    name: string
    symbol: string
    description?: string | null
    uri: string
    supply?: number
    createdBy: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NftCollectionCreateOrConnectWithoutDistributionsInput = {
    where: NftCollectionWhereUniqueInput
    create: XOR<NftCollectionCreateWithoutDistributionsInput, NftCollectionUncheckedCreateWithoutDistributionsInput>
  }

  export type UserCreateWithoutNftDistributionsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionCreateNestedManyWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionCreateNestedManyWithoutCreatorInput
    nftHoldings?: UserNftHoldingCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutNftDistributionsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningUncheckedCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimUncheckedCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionUncheckedCreateNestedManyWithoutUserInput
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigUncheckedCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionUncheckedCreateNestedManyWithoutCreatorInput
    nftHoldings?: UserNftHoldingUncheckedCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalUncheckedCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalUncheckedCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutNftDistributionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNftDistributionsInput, UserUncheckedCreateWithoutNftDistributionsInput>
  }

  export type NftCollectionUpsertWithoutDistributionsInput = {
    update: XOR<NftCollectionUpdateWithoutDistributionsInput, NftCollectionUncheckedUpdateWithoutDistributionsInput>
    create: XOR<NftCollectionCreateWithoutDistributionsInput, NftCollectionUncheckedCreateWithoutDistributionsInput>
    where?: NftCollectionWhereInput
  }

  export type NftCollectionUpdateToOneWithWhereWithoutDistributionsInput = {
    where?: NftCollectionWhereInput
    data: XOR<NftCollectionUpdateWithoutDistributionsInput, NftCollectionUncheckedUpdateWithoutDistributionsInput>
  }

  export type NftCollectionUpdateWithoutDistributionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mintAddress?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uri?: StringFieldUpdateOperationsInput | string
    supply?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutNftCollectionsNestedInput
  }

  export type NftCollectionUncheckedUpdateWithoutDistributionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mintAddress?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uri?: StringFieldUpdateOperationsInput | string
    supply?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutNftDistributionsInput = {
    update: XOR<UserUpdateWithoutNftDistributionsInput, UserUncheckedUpdateWithoutNftDistributionsInput>
    create: XOR<UserCreateWithoutNftDistributionsInput, UserUncheckedCreateWithoutNftDistributionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNftDistributionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNftDistributionsInput, UserUncheckedUpdateWithoutNftDistributionsInput>
  }

  export type UserUpdateWithoutNftDistributionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUpdateManyWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUpdateManyWithoutCreatorNestedInput
    nftHoldings?: UserNftHoldingUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutNftDistributionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUncheckedUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUncheckedUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUncheckedUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUncheckedUpdateManyWithoutCreatorNestedInput
    nftHoldings?: UserNftHoldingUncheckedUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUncheckedUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUncheckedUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutNftClaimApprovalInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionCreateNestedManyWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingCreateNestedManyWithoutUserInput
    approvedClaims?: NftClaimApprovalCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutNftClaimApprovalInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningUncheckedCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimUncheckedCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionUncheckedCreateNestedManyWithoutUserInput
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigUncheckedCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionUncheckedCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionUncheckedCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingUncheckedCreateNestedManyWithoutUserInput
    approvedClaims?: NftClaimApprovalUncheckedCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutNftClaimApprovalInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNftClaimApprovalInput, UserUncheckedCreateWithoutNftClaimApprovalInput>
  }

  export type UserCreateWithoutApprovedClaimsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionCreateNestedManyWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalCreateNestedOneWithoutUserInput
    airdropSeasons?: AirdropSeasonCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutApprovedClaimsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningUncheckedCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimUncheckedCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionUncheckedCreateNestedManyWithoutUserInput
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigUncheckedCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionUncheckedCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionUncheckedCreateNestedManyWithoutDistributorInput
    nftHoldings?: UserNftHoldingUncheckedCreateNestedManyWithoutUserInput
    nftClaimApproval?: NftClaimApprovalUncheckedCreateNestedOneWithoutUserInput
    airdropSeasons?: AirdropSeasonUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutApprovedClaimsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedClaimsInput, UserUncheckedCreateWithoutApprovedClaimsInput>
  }

  export type UserUpsertWithoutNftClaimApprovalInput = {
    update: XOR<UserUpdateWithoutNftClaimApprovalInput, UserUncheckedUpdateWithoutNftClaimApprovalInput>
    create: XOR<UserCreateWithoutNftClaimApprovalInput, UserUncheckedCreateWithoutNftClaimApprovalInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNftClaimApprovalInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNftClaimApprovalInput, UserUncheckedUpdateWithoutNftClaimApprovalInput>
  }

  export type UserUpdateWithoutNftClaimApprovalInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUpdateManyWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUpdateManyWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutNftClaimApprovalInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUncheckedUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUncheckedUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUncheckedUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUncheckedUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUncheckedUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUncheckedUpdateManyWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUncheckedUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserUpsertWithoutApprovedClaimsInput = {
    update: XOR<UserUpdateWithoutApprovedClaimsInput, UserUncheckedUpdateWithoutApprovedClaimsInput>
    create: XOR<UserCreateWithoutApprovedClaimsInput, UserUncheckedCreateWithoutApprovedClaimsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedClaimsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedClaimsInput, UserUncheckedUpdateWithoutApprovedClaimsInput>
  }

  export type UserUpdateWithoutApprovedClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUpdateManyWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUpdateOneWithoutUserNestedInput
    airdropSeasons?: AirdropSeasonUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUncheckedUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUncheckedUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUncheckedUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUncheckedUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUncheckedUpdateManyWithoutDistributorNestedInput
    nftHoldings?: UserNftHoldingUncheckedUpdateManyWithoutUserNestedInput
    nftClaimApproval?: NftClaimApprovalUncheckedUpdateOneWithoutUserNestedInput
    airdropSeasons?: AirdropSeasonUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateWithoutNftHoldingsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionCreateNestedManyWithoutUserInput
    claims?: ClaimCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryCreateNestedManyWithoutUserInput
    referrals?: ReferralCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionCreateNestedManyWithoutDistributorInput
    nftClaimApproval?: NftClaimApprovalCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutNftHoldingsInput = {
    id?: string
    walletAddress: string
    twitterId?: string | null
    twitterUsername?: string | null
    twitterName?: string | null
    twitterImage?: string | null
    twitterFollowers?: number | null
    twitterActivity?: $Enums.TwitterActivity | null
    level?: number
    streak?: number
    lastCheckIn?: Date | string | null
    referralCode?: string
    email?: string | null
    totalPoints?: number
    rank?: number
    isAdmin?: boolean
    isActive?: boolean
    totalEarnedTokens?: number
    lastLoginReward?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: number
    suspiciousFlags?: UserCreatesuspiciousFlagsInput | string[]
    isBanned?: boolean
    bannedAt?: Date | string | null
    lastActivity?: Date | string | null
    claimsEnabled?: boolean | null
    dailyEarnings?: DailyEarningUncheckedCreateNestedManyWithoutUserInput
    airdropClaims?: AirdropClaimUncheckedCreateNestedManyWithoutUserInput
    engagements?: TwitterEngagementUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskCompletionUncheckedCreateNestedManyWithoutUserInput
    claims?: ClaimUncheckedCreateNestedManyWithoutUserInput
    pointHistory?: PointHistoryUncheckedCreateNestedManyWithoutUserInput
    referrals?: ReferralUncheckedCreateNestedManyWithoutReferrerInput
    referredBy?: ReferralUncheckedCreateNestedOneWithoutReferredInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    adminSessions?: AdminSessionUncheckedCreateNestedManyWithoutAdminInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutAdminInput
    fraudAlerts?: FraudAlertUncheckedCreateNestedManyWithoutUserInput
    campaigns?: CampaignConfigUncheckedCreateNestedManyWithoutCreatorInput
    nftCollections?: NftCollectionUncheckedCreateNestedManyWithoutCreatorInput
    nftDistributions?: NftDistributionUncheckedCreateNestedManyWithoutDistributorInput
    nftClaimApproval?: NftClaimApprovalUncheckedCreateNestedOneWithoutUserInput
    approvedClaims?: NftClaimApprovalUncheckedCreateNestedManyWithoutApproverInput
    airdropSeasons?: AirdropSeasonUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutNftHoldingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNftHoldingsInput, UserUncheckedCreateWithoutNftHoldingsInput>
  }

  export type UserUpsertWithoutNftHoldingsInput = {
    update: XOR<UserUpdateWithoutNftHoldingsInput, UserUncheckedUpdateWithoutNftHoldingsInput>
    create: XOR<UserCreateWithoutNftHoldingsInput, UserUncheckedCreateWithoutNftHoldingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNftHoldingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNftHoldingsInput, UserUncheckedUpdateWithoutNftHoldingsInput>
  }

  export type UserUpdateWithoutNftHoldingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUpdateManyWithoutUserNestedInput
    claims?: ClaimUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUpdateManyWithoutUserNestedInput
    referrals?: ReferralUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUpdateManyWithoutDistributorNestedInput
    nftClaimApproval?: NftClaimApprovalUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutNftHoldingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletAddress?: StringFieldUpdateOperationsInput | string
    twitterId?: NullableStringFieldUpdateOperationsInput | string | null
    twitterUsername?: NullableStringFieldUpdateOperationsInput | string | null
    twitterName?: NullableStringFieldUpdateOperationsInput | string | null
    twitterImage?: NullableStringFieldUpdateOperationsInput | string | null
    twitterFollowers?: NullableIntFieldUpdateOperationsInput | number | null
    twitterActivity?: NullableEnumTwitterActivityFieldUpdateOperationsInput | $Enums.TwitterActivity | null
    level?: IntFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    lastCheckIn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    referralCode?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    rank?: IntFieldUpdateOperationsInput | number
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    totalEarnedTokens?: FloatFieldUpdateOperationsInput | number
    lastLoginReward?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    permissions?: NullableJsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    suspiciousFlags?: UserUpdatesuspiciousFlagsInput | string[]
    isBanned?: BoolFieldUpdateOperationsInput | boolean
    bannedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastActivity?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    claimsEnabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    dailyEarnings?: DailyEarningUncheckedUpdateManyWithoutUserNestedInput
    airdropClaims?: AirdropClaimUncheckedUpdateManyWithoutUserNestedInput
    engagements?: TwitterEngagementUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    claims?: ClaimUncheckedUpdateManyWithoutUserNestedInput
    pointHistory?: PointHistoryUncheckedUpdateManyWithoutUserNestedInput
    referrals?: ReferralUncheckedUpdateManyWithoutReferrerNestedInput
    referredBy?: ReferralUncheckedUpdateOneWithoutReferredNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    adminSessions?: AdminSessionUncheckedUpdateManyWithoutAdminNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutAdminNestedInput
    fraudAlerts?: FraudAlertUncheckedUpdateManyWithoutUserNestedInput
    campaigns?: CampaignConfigUncheckedUpdateManyWithoutCreatorNestedInput
    nftCollections?: NftCollectionUncheckedUpdateManyWithoutCreatorNestedInput
    nftDistributions?: NftDistributionUncheckedUpdateManyWithoutDistributorNestedInput
    nftClaimApproval?: NftClaimApprovalUncheckedUpdateOneWithoutUserNestedInput
    approvedClaims?: NftClaimApprovalUncheckedUpdateManyWithoutApproverNestedInput
    airdropSeasons?: AirdropSeasonUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type DailyEarningCreateManyUserInput = {
    id?: string
    tokens: number
    type: string
    claimedAt?: Date | string
  }

  export type AirdropClaimCreateManyUserInput = {
    id?: string
    seasonId: string
    tokens: number
    tier: string
    paymentSignature: string
    transactionSignature?: string | null
    status: string
    claimedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TwitterEngagementCreateManyUserInput = {
    id?: string
    tweetId: string
    engagementType: $Enums.EngagementType
    points: number
    verified?: boolean
    createdAt?: Date | string
  }

  export type TaskCompletionCreateManyUserInput = {
    id?: string
    taskId: string
    completed?: boolean
    points: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ClaimCreateManyUserInput = {
    id?: string
    amount: number
    transactionHash?: string | null
    status?: $Enums.ClaimStatus
    paymentMethod?: $Enums.PaymentMethod
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: Date | string | null
    feesPaid?: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
    updatedAt?: Date | string
    type?: string | null
    nftPasses?: NullableJsonNullValueInput | InputJsonValue
    userTier?: string | null
  }

  export type PointHistoryCreateManyUserInput = {
    id?: string
    points: number
    action: string
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ReferralCreateManyReferrerInput = {
    id?: string
    referredId: string
    points?: number
    completed?: boolean
    createdAt?: Date | string
    isActive?: boolean
  }

  export type UserAchievementCreateManyUserInput = {
    id?: string
    achievementId: string
    unlockedAt?: Date | string
    progress?: number
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    type?: $Enums.NotificationType
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
  }

  export type AdminSessionCreateManyAdminInput = {
    id?: string
    ipAddress: string
    userAgent: string
    permissions: JsonNullValueInput | InputJsonValue
    expiresAt: Date | string
    lastActivity: Date | string
    createdAt?: Date | string
  }

  export type AdminAuditLogCreateManyAdminInput = {
    id?: string
    action: string
    metadata: JsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    ipAddress: string
  }

  export type FraudAlertCreateManyUserInput = {
    id?: string
    type: string
    severity: string
    description: string
    evidence: JsonNullValueInput | InputJsonValue
    riskScore: number
    status?: string
    createdAt?: Date | string
    investigatedBy?: string | null
    resolvedAt?: Date | string | null
  }

  export type CampaignConfigCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    tokenMint: string
    totalAllocation: bigint | number
    startDate: Date | string
    endDate: Date | string
    eligibilityCriteria: JsonNullValueInput | InputJsonValue
    distributionRules: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NftCollectionCreateManyCreatorInput = {
    id?: string
    mintAddress: string
    name: string
    symbol: string
    description?: string | null
    uri: string
    supply?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NftDistributionCreateManyDistributorInput = {
    id?: string
    mintAddress: string
    recipientCount: number
    nftsPerUser: number
    results: JsonNullValueInput | InputJsonValue
    success?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserNftHoldingCreateManyUserInput = {
    id?: string
    mintAddress: string
    tokenAccount: string
    amount?: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acquiredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NftClaimApprovalCreateManyApproverInput = {
    id?: string
    userId: string
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AirdropSeasonCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    status?: string
    totalAllocation: bigint | number
    claimedAmount?: bigint | number
    startDate?: Date | string
    endDate?: Date | string | null
    nftPassRequired?: boolean
    requireApproval?: boolean
    feeAmount?: Decimal | DecimalJsLike | number | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DailyEarningUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokens?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    claimedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyEarningUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokens?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    claimedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DailyEarningUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokens?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    claimedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AirdropClaimUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokens?: FloatFieldUpdateOperationsInput | number
    tier?: StringFieldUpdateOperationsInput | string
    paymentSignature?: StringFieldUpdateOperationsInput | string
    transactionSignature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    claimedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    season?: AirdropSeasonUpdateOneRequiredWithoutClaimsNestedInput
  }

  export type AirdropClaimUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    tokens?: FloatFieldUpdateOperationsInput | number
    tier?: StringFieldUpdateOperationsInput | string
    paymentSignature?: StringFieldUpdateOperationsInput | string
    transactionSignature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    claimedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AirdropClaimUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    seasonId?: StringFieldUpdateOperationsInput | string
    tokens?: FloatFieldUpdateOperationsInput | number
    tier?: StringFieldUpdateOperationsInput | string
    paymentSignature?: StringFieldUpdateOperationsInput | string
    transactionSignature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    claimedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterEngagementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    engagementType?: EnumEngagementTypeFieldUpdateOperationsInput | $Enums.EngagementType
    points?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterEngagementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    engagementType?: EnumEngagementTypeFieldUpdateOperationsInput | $Enums.EngagementType
    points?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TwitterEngagementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tweetId?: StringFieldUpdateOperationsInput | string
    engagementType?: EnumEngagementTypeFieldUpdateOperationsInput | $Enums.EngagementType
    points?: IntFieldUpdateOperationsInput | number
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCompletionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: TaskUpdateOneRequiredWithoutCompletionsNestedInput
  }

  export type TaskCompletionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCompletionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClaimUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feesPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    nftPasses?: NullableJsonNullValueInput | InputJsonValue
    userTier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClaimUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feesPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    nftPasses?: NullableJsonNullValueInput | InputJsonValue
    userTier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClaimUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    transactionHash?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    metadata?: NullableJsonNullValueInput | InputJsonValue
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feesPaid?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    nftPasses?: NullableJsonNullValueInput | InputJsonValue
    userTier?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PointHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PointHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    referred?: UserUpdateOneRequiredWithoutReferredByNestedInput
  }

  export type ReferralUncheckedUpdateWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    referredId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReferralUncheckedUpdateManyWithoutReferrerInput = {
    id?: StringFieldUpdateOperationsInput | string
    referredId?: StringFieldUpdateOperationsInput | string
    points?: IntFieldUpdateOperationsInput | number
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserAchievementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
    achievement?: AchievementUpdateOneRequiredWithoutUserAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSessionUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSessionUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminSessionUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
  }

  export type AdminAuditLogUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
  }

  export type AdminAuditLogUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    metadata?: JsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: StringFieldUpdateOperationsInput | string
  }

  export type FraudAlertUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidence?: JsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investigatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FraudAlertUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidence?: JsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investigatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FraudAlertUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    evidence?: JsonNullValueInput | InputJsonValue
    riskScore?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    investigatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CampaignConfigUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tokenMint?: StringFieldUpdateOperationsInput | string
    totalAllocation?: BigIntFieldUpdateOperationsInput | bigint | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eligibilityCriteria?: JsonNullValueInput | InputJsonValue
    distributionRules?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignConfigUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tokenMint?: StringFieldUpdateOperationsInput | string
    totalAllocation?: BigIntFieldUpdateOperationsInput | bigint | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eligibilityCriteria?: JsonNullValueInput | InputJsonValue
    distributionRules?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CampaignConfigUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tokenMint?: StringFieldUpdateOperationsInput | string
    totalAllocation?: BigIntFieldUpdateOperationsInput | bigint | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    eligibilityCriteria?: JsonNullValueInput | InputJsonValue
    distributionRules?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NftCollectionUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    mintAddress?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uri?: StringFieldUpdateOperationsInput | string
    supply?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributions?: NftDistributionUpdateManyWithoutCollectionNestedInput
  }

  export type NftCollectionUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    mintAddress?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uri?: StringFieldUpdateOperationsInput | string
    supply?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributions?: NftDistributionUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type NftCollectionUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    mintAddress?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    symbol?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    uri?: StringFieldUpdateOperationsInput | string
    supply?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NftDistributionUpdateWithoutDistributorInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    nftsPerUser?: IntFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    success?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    collection?: NftCollectionUpdateOneRequiredWithoutDistributionsNestedInput
  }

  export type NftDistributionUncheckedUpdateWithoutDistributorInput = {
    id?: StringFieldUpdateOperationsInput | string
    mintAddress?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    nftsPerUser?: IntFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    success?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NftDistributionUncheckedUpdateManyWithoutDistributorInput = {
    id?: StringFieldUpdateOperationsInput | string
    mintAddress?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    nftsPerUser?: IntFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    success?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNftHoldingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mintAddress?: StringFieldUpdateOperationsInput | string
    tokenAccount?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNftHoldingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mintAddress?: StringFieldUpdateOperationsInput | string
    tokenAccount?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserNftHoldingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    mintAddress?: StringFieldUpdateOperationsInput | string
    tokenAccount?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    acquiredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NftClaimApprovalUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNftClaimApprovalNestedInput
  }

  export type NftClaimApprovalUncheckedUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NftClaimApprovalUncheckedUpdateManyWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AirdropSeasonUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalAllocation?: BigIntFieldUpdateOperationsInput | bigint | number
    claimedAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nftPassRequired?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claims?: AirdropClaimUpdateManyWithoutSeasonNestedInput
  }

  export type AirdropSeasonUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalAllocation?: BigIntFieldUpdateOperationsInput | bigint | number
    claimedAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nftPassRequired?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claims?: AirdropClaimUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type AirdropSeasonUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalAllocation?: BigIntFieldUpdateOperationsInput | bigint | number
    claimedAmount?: BigIntFieldUpdateOperationsInput | bigint | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nftPassRequired?: BoolFieldUpdateOperationsInput | boolean
    requireApproval?: BoolFieldUpdateOperationsInput | boolean
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateManyAchievementInput = {
    id?: string
    userId: string
    unlockedAt?: Date | string
    progress?: number
  }

  export type UserAchievementUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type UserAchievementUncheckedUpdateManyWithoutAchievementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    unlockedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: IntFieldUpdateOperationsInput | number
  }

  export type TaskCompletionCreateManyTaskInput = {
    id?: string
    userId: string
    completed?: boolean
    points: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TaskCompletionUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTasksNestedInput
  }

  export type TaskCompletionUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCompletionUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    points?: IntFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AirdropClaimCreateManySeasonInput = {
    id?: string
    userId: string
    tokens: number
    tier: string
    paymentSignature: string
    transactionSignature?: string | null
    status: string
    claimedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AirdropClaimUpdateWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokens?: FloatFieldUpdateOperationsInput | number
    tier?: StringFieldUpdateOperationsInput | string
    paymentSignature?: StringFieldUpdateOperationsInput | string
    transactionSignature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    claimedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAirdropClaimsNestedInput
  }

  export type AirdropClaimUncheckedUpdateWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokens?: FloatFieldUpdateOperationsInput | number
    tier?: StringFieldUpdateOperationsInput | string
    paymentSignature?: StringFieldUpdateOperationsInput | string
    transactionSignature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    claimedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AirdropClaimUncheckedUpdateManyWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokens?: FloatFieldUpdateOperationsInput | number
    tier?: StringFieldUpdateOperationsInput | string
    paymentSignature?: StringFieldUpdateOperationsInput | string
    transactionSignature?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    claimedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NftDistributionCreateManyCollectionInput = {
    id?: string
    distributedBy: string
    recipientCount: number
    nftsPerUser: number
    results: JsonNullValueInput | InputJsonValue
    success?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NftDistributionUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    nftsPerUser?: IntFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    success?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    distributor?: UserUpdateOneRequiredWithoutNftDistributionsNestedInput
  }

  export type NftDistributionUncheckedUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    distributedBy?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    nftsPerUser?: IntFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    success?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NftDistributionUncheckedUpdateManyWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    distributedBy?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    nftsPerUser?: IntFieldUpdateOperationsInput | number
    results?: JsonNullValueInput | InputJsonValue
    success?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}