generator client {
  provider = "prisma-client-js"
  output   = "../src/app/generated/prisma"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                String           @id @default(cuid())
  walletAddress     String           @unique
  twitterId         String?          @unique
  twitterUsername   String?
  twitterName       String?
  twitterImage      String?
  twitterFollowers  Int?             @default(0)
  // ADD: These new fields for enhanced functionality
  twitterActivity   TwitterActivity? @default(LOW)
  level             Int              @default(1)
  streak            Int              @default(0)
  lastCheckIn       DateTime?
  referralCode      String           @unique @default(cuid())
  
  email             String?          @unique
  totalPoints       Int              @default(0)
  rank              Int              @default(0)
  isAdmin           Boolean          @default(false)
  isActive          Boolean          @default(true)
  totalEarnedTokens   Float            @default(0)
  lastLoginReward     DateTime?
  
  dailyEarnings   DailyEarning[]
  airdropClaims   AirdropClaim[]
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  
  engagements       TwitterEngagement[]
  tasks             TaskCompletion[]
  claims            Claim[]
  pointHistory      PointHistory[]
  referrals         Referral[]       @relation("ReferrerUser")
  referredBy        Referral?        @relation("ReferredUser")
  // ADD: New relations
  achievements      UserAchievement[]
  notifications     Notification[]

  permissions     Json?      // For role-based access control
  riskScore       Int        @default(0)
  suspiciousFlags String[]   @default([])
  isBanned        Boolean    @default(false)
  bannedAt        DateTime?
  lastActivity    DateTime?
  claimsEnabled   Boolean?    @default(false) // New field to control claim eligibility
  


  // Relations
  adminSessions   AdminSession[]
  auditLogs       AdminAuditLog[]
  fraudAlerts     FraudAlert[]
  campaigns       CampaignConfig[]


  nftCollections    NftCollection[]
  nftDistributions  NftDistribution[]
  nftHoldings       UserNftHolding[]
  nftClaimApproval  NftClaimApproval?
  approvedClaims    NftClaimApproval[] @relation("ApprovedBy")
  airdropSeasons    AirdropSeason[]
  
  @@index([walletAddress])
  @@index([twitterId])
  @@index([totalPoints])
  // ADD: New indexes
  @@index([twitterActivity])
  @@index([level])
}

// ADD: New Achievement model (add after Analytics model):
model Achievement {
  id               String          @id @default(cuid())
  name             String
  description      String
  icon             String
  requirements     Json
  points           Int
  isSecret         Boolean         @default(false)
  createdAt        DateTime        @default(now())

  userAchievements UserAchievement[]

  @@map("achievements")
}

// ADD: New UserAchievement model:
model UserAchievement {
  id               String          @id @default(cuid())
  userId           String
  achievementId    String
  unlockedAt       DateTime        @default(now())
  progress         Int             @default(100)

  user             User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  achievement      Achievement     @relation(fields: [achievementId], references: [id], onDelete: Cascade)

  @@unique([userId, achievementId])
  @@map("user_achievements")
}

// ADD: New Notification model:
model Notification {
  id               String          @id @default(cuid())
  userId           String
  title            String
  message          String
  type             NotificationType @default(INFO)
  read             Boolean         @default(false)
  actionUrl        String?
  createdAt        DateTime        @default(now())

  user             User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}

// ADD: New TwitterAnalytics model for better tracking:
model TwitterAnalytics {
  id               String          @id @default(cuid())
  userId           String?
  tweetId          String
  likes            Int             @default(0)
  retweets         Int             @default(0)
  comments         Int             @default(0)
  impressions      Int             @default(0)
  engagement_rate  Float           @default(0)
  calculatedAt     DateTime        @default(now())

  @@unique([tweetId])
  @@map("twitter_analytics")
}

// ADD: New enums (add after PaymentMethod enum):
enum TwitterActivity {
  HIGH    // 4000 tokens
  MEDIUM  // 3500 tokens  
  LOW     // 3000 tokens
}

enum NotificationType {
  INFO
  SUCCESS
  WARNING
  ERROR
  ACHIEVEMENT
}
model TwitterEngagement {
  id                String           @id @default(cuid())
  userId            String
  tweetId           String
  engagementType    EngagementType
  points            Int
  verified          Boolean          @default(false)
  createdAt         DateTime         @default(now())
  
  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, tweetId, engagementType])
  @@index([userId])
  @@index([createdAt])
}

model Task {
  id                String           @id @default(cuid())
  name              String
  description       String
  type              TaskType
  points            Int
  requirements      Json
  isActive          Boolean          @default(true)
  expiresAt         DateTime?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  
  completions       TaskCompletion[]
  
  @@index([type])
  @@index([isActive])
}



model AdminSession {
  id           String   @id @default(cuid())
  adminId      String
  ipAddress    String
  userAgent    String
  permissions  Json
  expiresAt    DateTime
  lastActivity DateTime
  createdAt    DateTime @default(now())

  admin User @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@map("admin_sessions")
}

model AdminAuditLog {
  id        String   @id @default(cuid())
  adminId   String
  action    String
  metadata  Json
  timestamp DateTime @default(now())
  ipAddress String

  admin User @relation(fields: [adminId], references: [id], onDelete: Cascade)

  @@map("admin_audit_logs")
}

model FraudAlert {
  id          String   @id @default(cuid())
  type        String   // SYBIL_ATTACK, WALLET_CLUSTERING, etc.
  severity    String   // LOW, MEDIUM, HIGH, CRITICAL
  userId      String
  description String
  evidence    Json
  riskScore   Int
  status      String   @default("PENDING") // PENDING, INVESTIGATING, RESOLVED, FALSE_POSITIVE
  createdAt   DateTime @default(now())
  investigatedBy String?
  resolvedAt  DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("fraud_alerts")
}

model CampaignConfig {
  id              String   @id @default(cuid())
  name            String
  description     String?
  tokenMint       String
  totalAllocation BigInt
  startDate       DateTime
  endDate         DateTime
  eligibilityCriteria Json
  distributionRules   Json
  isActive        Boolean  @default(true)
  createdBy       String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  creator User @relation(fields: [createdBy], references: [id])

  @@map("campaign_configs")
}




model TaskCompletion {
  id                String           @id @default(cuid())
  userId            String
  taskId            String
  completed         Boolean          @default(false)
  points            Int
  metadata          Json?
  completedAt       DateTime?
  createdAt         DateTime         @default(now())
  
  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  task              Task             @relation(fields: [taskId], references: [id], onDelete: Cascade)
  
  @@unique([userId, taskId])
  @@index([userId])
  @@index([taskId])
}

model Claim {
  id                String           @id @default(cuid())
  userId            String
  amount            Float
  transactionHash   String?
  status            ClaimStatus      @default(PENDING)
  paymentMethod     PaymentMethod    @default(SOLANA)
  metadata          Json?
  processedAt       DateTime?
  feesPaid          Decimal  @default(0) @db.Decimal(20, 10)
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  type      String? @default("TOKEN")
  nftPasses Json?   @map("nft_passes")
  userTier  String? @map("user_tier")
  
  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

model PointHistory {
  id                String           @id @default(cuid())
  userId            String
  points            Int
  action            String
  description       String?
  metadata          Json?
  createdAt         DateTime         @default(now())
  
  user              User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([createdAt])
}

model Referral {
  id                String           @id @default(cuid())
  referrerId        String
  referredId        String           @unique
  points            Int              @default(0)
  completed         Boolean          @default(false)
  createdAt         DateTime         @default(now())
  isActive          Boolean          @default(false)
  referrer          User             @relation("ReferrerUser", fields: [referrerId], references: [id], onDelete: Cascade)
  referred          User             @relation("ReferredUser", fields: [referredId], references: [id], onDelete: Cascade)
  
  @@index([referrerId])
  @@index([referredId])
}

model SystemConfig {
  id                String           @id @default(cuid())
  key               String           @unique
  value             Json
  description       String?
  updatedAt         DateTime         @updatedAt
  
  @@index([key])
}

model Analytics {
  id                String           @id @default(cuid())
  date              DateTime         @default(now())
  totalUsers        Int              @default(0)
  activeUsers       Int              @default(0)
  totalClaims       Int              @default(0)
  totalPoints       Int              @default(0)
  totalEngagements  Int              @default(0)
  metadata          Json?
  createdAt         DateTime         @default(now())
  
  @@index([date])
}


model DailyEarning {
  id        String   @id @default(cuid())
  userId    String
  tokens    Float
  type      String   // LOGIN_BONUS, REFERRAL_BONUS, STREAK_BONUS
  claimedAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
  
  @@index([userId, claimedAt])
}

model AirdropSeason {
  id              String    @id @default(cuid())
  name            String
  description     String?
  status          String    @default("ACTIVE")
  totalAllocation BigInt    @map("total_allocation")
  claimedAmount   BigInt    @default(0) @map("claimed_amount")
  startDate       DateTime  @default(now()) @map("start_date")
  endDate         DateTime? @map("end_date")
  nftPassRequired Boolean   @default(true) @map("nft_pass_required")
  requireApproval Boolean   @default(false) @map("require_approval")
  feeAmount       Decimal   @default(4.00) @map("fee_amount")
  createdBy       String    @map("created_by")
  metadata        Json?
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  creator User @relation(fields: [createdBy], references: [id])
   claims AirdropClaim[]

  // @@map("airdrop_seasons")
}

model AirdropClaim {
  id                   String   @id @default(cuid())
  userId               String
  seasonId             String
  tokens               Float
  tier                 String   // HIGH, MEDIUM, LOW
  paymentSignature     String
  transactionSignature String?
  status               String   // PENDING, COMPLETED, FAILED
  claimedAt            DateTime @default(now())
  
  user   User          @relation(fields: [userId], references: [id])
  season AirdropSeason @relation(fields: [seasonId], references: [id])
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  
  @@unique([userId, seasonId])
  @@index([seasonId, status])
}

model NftCollection {
  id          String   @id @default(cuid())
  mintAddress String   @unique @map("mint_address")
  name        String
  symbol      String
  description String?
  uri         String
  supply      Int      @default(0)
  createdBy   String   @map("created_by")
  metadata    Json?
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  creator       User               @relation(fields: [createdBy], references: [id])
  distributions NftDistribution[]

  @@map("nft_collections")
}

model NftDistribution {
  id            String   @id @default(cuid())
  mintAddress   String   @map("mint_address")
  distributedBy String   @map("distributed_by")
  recipientCount Int     @map("recipient_count")
  nftsPerUser   Int      @map("nfts_per_user")
  results       Json
  success       Boolean  @default(true)
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  collection    NftCollection @relation(fields: [mintAddress], references: [mintAddress])
  distributor   User          @relation(fields: [distributedBy], references: [id])

  @@map("nft_distributions")
}

model NftClaimApproval {
  id         String    @id @default(cuid())
  userId     String    @unique @map("user_id")
  approved   Boolean   @default(false)
  approvedBy String?   @map("approved_by")
  approvedAt DateTime? @map("approved_at")
  createdAt  DateTime  @default(now()) @map("created_at")
  updatedAt  DateTime  @updatedAt @map("updated_at")

  user     User  @relation(fields: [userId], references: [id])
  approver User? @relation("ApprovedBy", fields: [approvedBy], references: [id])

  @@map("nft_claim_approvals")
}
model UserNftHolding {
  id           String   @id @default(cuid())
  userId       String   @map("user_id")
  mintAddress  String   @map("mint_address")
  tokenAccount String   @map("token_account")
  amount       Int      @default(1)
  metadata     Json?
  acquiredAt   DateTime @default(now()) @map("acquired_at")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id])

  @@unique([userId, mintAddress, tokenAccount])
  @@map("user_nft_holdings")
}

enum EngagementType {
  LIKE
  RETWEET
  COMMENT
  QUOTE
  FOLLOW
}

enum TaskType {
  SOCIAL_TWITTER
  SOCIAL_DISCORD
  WALLET_CONNECT
  REFERRAL
  DAILY_CHECK_IN
  CUSTOM
}

enum ClaimStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

enum PaymentMethod {
  SOLANA
  USDC
}


































